<div class="container">

<table style="width: 100%;"><tr>
<td>plot.decontaminated_density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot the decontaminated density of the unknown component for an estimated admixture model</h2>

<h3>Description</h3>

<p>Plot the decontaminated density of the unknown component in the admixture model under study, after inversion of the admixture
cumulative distribution function. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'decontaminated_density'
plot(x, ..., x_val, add_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class 'decontamin_dens' (see ?decontaminated_density).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see par).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_val</code></td>
<td>
<p>A vector of X-axis values at which to plot the decontaminated density f.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_plot</code></td>
<td>
<p>(default to FALSE) A boolean specifying if one plots the decontaminated density over an existing plot. Used for visual
comparison purpose.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The decontaminated density is obtained by inverting the admixture density, given by l = p*f + (1-p)*g, to isolate the
unknown component f after having estimated p.
</p>


<h3>Value</h3>

<p>The plot of the decontaminated density.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">####### Continuous support:
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=3000, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2500, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 6, length.out = 100), add_plot = FALSE)
plot(x = res2, col = "red", x_val = seq(from = 0, to = 6, length.out = 100), add_plot = TRUE)

####### Countable discrete support:
list.comp &lt;- list(f1 = 'pois', g1 = 'pois',
                  f2 = 'pois', g2 = 'pois')
list.param &lt;- list(f1 = list(lambda = 3), g1 = list(lambda = 2),
                   f2 = list(lambda = 3), g2 = list(lambda = 4))
sample1 &lt;- rsimmix(n=4000, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=3500, unknownComp_weight=0.85, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'pois',
                  f2 = NULL, g2 = 'pois')
list.param &lt;- list(f1 = NULL, g1 = list(lambda = 2),
                   f2 = NULL, g2 = list(lambda = 4))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 15, by = 1), add_plot = FALSE)
plot(x = res2, col = "red", x_val= seq(from=0,to=15,by=1), add_plot = TRUE)

####### Finite discrete support:
list.comp &lt;- list(f1 = 'multinom', g1 = 'multinom',
                  f2 = 'multinom', g2 = 'multinom')
list.param &lt;- list(f1 = list(size=1, prob=c(0.3,0.4,0.3)), g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = list(size=1, prob=c(0.3,0.4,0.3)), g2 = list(size=1, prob=c(0.2,0.6,0.2)))
sample1 &lt;- rsimmix(n=4000, unknownComp_weight=0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=3500, unknownComp_weight=0.9, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'multinom',
                  f2 = NULL, g2 = 'multinom')
list.param &lt;- list(f1 = NULL, g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = NULL, g2 = list(size=1, prob=c(0.2,0.6,0.2)))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to=6, by = 1), add_plot = FALSE)
plot(x = res2, col = "red", x_val = seq(from = 0, to = 6, by = 1), add_plot = TRUE)

</code></pre>


</div>