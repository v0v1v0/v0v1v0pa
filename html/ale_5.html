<div class="container">

<table style="width: 100%;"><tr>
<td>create_p_funs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a p-value functions object that can be used to generate p-values</h2>

<h3>Description</h3>

<p>Calculating p-values is not trivial for ALE statistics because ALE is
non-parametric and model-agnostic. Because ALE is non-parametric (that is,
it does not assume any particular distribution of data), the <code>ale</code> package
generates p-values by calculating ALE for many random variables; this makes the
procedure somewhat slow. For this reason, they are not calculated by default;
they must be explicitly requested. Because the <code>ale</code> package is model-agnostic (that is, it
works with any kind of R model), the <code>ale()</code> function cannot always automatically
manipulate the model object to create the p-values. It can only do so for
models that follow the standard R statistical modelling conventions, which
includes almost all built-in R algorithms (like <code>stats::lm()</code> and <code>stats::glm()</code>) and many widely
used statistics packages (like <code>mgcv</code> and <code>survival</code>), but which excludes most
machine learning algorithms (like <code>tidymodels</code> and <code>caret</code>). For non-standard
algorithms, the user needs to do a little work to help the ale function
correctly manipulate its model object:
</p>

<ul>
<li>
<p> The full model call must be passed as a character string in the argument
'random_model_call_string', with two slight modifications as follows.
</p>
</li>
<li>
<p> In the formula that specifies the model, you must add a variable named
'random_variable'. This corresponds to the random variables that <code>create_p_funs()</code>
will use to estimate p-values.
</p>
</li>
<li>
<p> The dataset on which the model is trained must be named 'rand_data'. This
corresponds to the modified datasets that will be used to train the random
variables.
</p>
</li>
</ul>
<p>See the example below for how this is implemented.
</p>


<h3>Usage</h3>

<pre><code class="language-R">create_p_funs(
  data,
  model,
  ...,
  parallel = parallel::detectCores(logical = FALSE) - 1,
  model_packages = as.character(NA),
  random_model_call_string = NULL,
  random_model_call_string_vars = character(),
  y_col = NULL,
  pred_fun = function(object, newdata, type = pred_type) {
     stats::predict(object =
    object, newdata = newdata, type = type)
 },
  pred_type = "response",
  rand_it = 1000,
  silent = FALSE,
  .testing_mode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used. Inserted to require explicit naming of subsequent arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_packages</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_model_call_string</code></td>
<td>
<p>character string. If NULL, <code>create_p_funs()</code> tries to
automatically detect and construct the call for p-values. If it cannot, the
function will fail early. In that case, a character string of the full call
for the model must be provided that includes the random variable. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_model_call_string_vars</code></td>
<td>
<p>See documentation for <code>model_call_string_vars</code>
in <code>model_bootstrap()</code>; the operation is very similar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_col</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_fun, pred_type</code></td>
<td>
<p>See documentation for <code>ale()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand_it</code></td>
<td>
<p>non-negative integer length 1. Number of times that the model
should be retrained with a new random variable. The default of 1000 should
give reasonably stable p-values. It can be reduced as low as 100 for faster
test runs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>See documentation for <code>ale()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.testing_mode</code></td>
<td>
<p>logical. Internal use only.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The return value is a list of class <code style="white-space: pre;">⁠c('p_funs', 'ale', 'list'⁠</code>) with an
<code>ale_version</code> attribute whose value is the version of the <code>ale</code> package used to
create the object. See examples for an illustration of how to inspect this list.
Its elements are:
</p>

<ul>
<li> <p><code>value_to_p</code>: a list of functions named for each each available ALE statistic.
Each function signature is <code style="white-space: pre;">⁠function(x)⁠</code> where x is a numeric. The function returns
the p-value (minimum 0; maximum 1) for the respective statistic based on the random variable analysis.
For an input x that returns p, its interpretation is that p% of random variables
obtained the same or higher statistic value. For example, to get the p-value
of a NALED of 4.2, enter <code>p_funs$value_to_p(4.2)</code>. A return value of 0.03 means
that only 3% of random variables obtained a NALED greater than or equal to 4.2.
</p>
</li>
<li> <p><code>p_to_random_value</code>: a list of functions named for each each available ALE statistic.
These are the inverse functions of <code>value_to_p</code>. The signature is <code style="white-space: pre;">⁠function(p)⁠</code>
where p is a numeric from 0 to 1. The function returns the numeric value of the
random variable statistic that would yield the provided p-value.
For an input p that returns x, its interpretation is that p% of random variables
obtained the same or higher statistic value. For example, to get the random
variable ALED for the 0.05 p-value, enter <code>p_funs$p_to_random_value(0.05)</code>.
A return value of 102 means that only 5% of random variables obtained an ALED
greater than or equal to 102.
</p>
</li>
<li> <p><code>rand_stats</code>: a tibble whose rows are each of the <code>rand_it</code> iterations of the
random variable analysis and whose columns are the ALE statistics obtained for
each random variable.
</p>
</li>
<li> <p><code>residuals</code>: the actual <code>y_col</code> values from <code>data</code> minus the predicted
values from the <code>model</code> (without random variables) on the <code>data</code>.
<code>residual_distribution</code>: the closest estimated distribution for the <code>residuals</code>
as determined by <code>univariateML::rml()</code>. This is the distribution used to generate
all the random variables.
</p>
</li>
</ul>
<h3>Approach to calculating p-values</h3>

<p>The <code>ale</code> package takes a literal frequentist approach to the calculation of
p-values. That is, it literally retrains the model 1000 times, each time
modifying it by adding a distinct random variable to the model.
(The number of iterations is customizable
with the <code>rand_it</code> argument.) The ALEs and ALE statistics are calculated for
each random variable. The percentiles of the distribution of these
random-variable ALEs are then used to determine p-values for non-random variables.
Thus, p-values are interpreted as the frequency of random variable ALE statistics
that exceed the value of ALE statistic of the actual variable in question.
The specific steps are as follows:
</p>

<ul>
<li>
<p> The residuals of the original model trained on the training data are calculated
(residuals are the actual y target value minus the predicted values).
</p>
</li>
<li>
<p> The closest distribution of the residuals is detected with
<code>univariateML::model_select()</code>.
</p>
</li>
<li>
<p> 1000 new models are trained by generating a random variable each time with
<code>univariateML::rml()</code> and then training a new model with that random variable
added.
</p>
</li>
<li>
<p> The ALEs and ALE statistics are calculated for each random variable.
</p>
</li>
<li>
<p> For each ALE statistic, the empirical cumulative distribution function
(from <code>stats::ecdf()</code>) is used to create a function to determine p-values
according to the distribution of the random variables' ALE statistics.
</p>
</li>
</ul>
<h3>References</h3>

<p>Okoli, Chitu. 2023.
“Statistical Inference Using Machine Learning and Classical Techniques Based
on Accumulated Local Effects (ALE).” arXiv. <a href="https://arxiv.org/abs/2310.09877">https://arxiv.org/abs/2310.09877</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Sample 1000 rows from the ggplot2::diamonds dataset (for a simple example)
set.seed(0)
diamonds_sample &lt;- ggplot2::diamonds[sample(nrow(ggplot2::diamonds), 1000), ]

# Create a GAM model with flexible curves to predict diamond price
# Smooth all numeric variables and include all other variables
gam_diamonds &lt;- mgcv::gam(
  price ~ s(carat) + s(depth) + s(table) + s(x) + s(y) + s(z) +
    cut + color + clarity,
  data = diamonds_sample
)
summary(gam_diamonds)

# Create p-value functions
pf_diamonds &lt;- create_p_funs(
  diamonds_sample,
  gam_diamonds,
  # only 100 iterations for a quick demo; but usually should remain at 1000
  rand_it = 100,
)

# Examine the structure of the returned object
str(pf_diamonds)
# In RStudio: View(pf_diamonds)

# Calculate ALEs with p-values
ale_gam_diamonds &lt;- ale(
  diamonds_sample,
  gam_diamonds,
  p_values = pf_diamonds
)

# Plot the ALE data. The horizontal bands in the plots use the p-values.
ale_gam_diamonds$plots |&gt;
  patchwork::wrap_plots()


# For non-standard models that give errors with the default settings,
# you can use 'random_model_call_string' to specify a model for the estimation
# of p-values from random variables as in this example.
# See details above for an explanation.
pf_diamonds &lt;- create_p_funs(
  diamonds_sample,
  gam_diamonds,
  random_model_call_string = 'mgcv::gam(
    price ~ s(carat) + s(depth) + s(table) + s(x) + s(y) + s(z) +
        cut + color + clarity + random_variable,
    data = rand_data
  )',
  # only 100 iterations for a quick demo; but usually should remain at 1000
  rand_it = 100,
)




</code></pre>


</div>