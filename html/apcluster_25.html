<div class="container">

<table style="width: 100%;"><tr>
<td>apclusterK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Affinity Propagation for Pre-defined Number of Clusters</h2>

<h3>Description</h3>

<p>Runs affinity propagation clustering for a given similarity matrix
adjusting input preferences iteratively in order to achieve a desired
number of clusters
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'matrix,missing'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE)
## S4 method for signature 'Matrix,missing'
apclusterK(s, x, K, ...)
## S4 method for signature 'dgTMatrix,missing'
apclusterK(s, x, K, prc=10, bimaxit=20,
     exact=FALSE, maxits=1000, convits=100, lam=0.9, includeSim=FALSE,
     details=FALSE, nonoise=FALSE, seed=NA, verbose=TRUE)
## S4 method for signature 'sparseMatrix,missing'
apclusterK(s, x, K, ...)
## S4 method for signature 'function,ANY'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE, ...)
## S4 method for signature 'character,ANY'
apclusterK(s, x, K, prc=10, bimaxit=20, exact=FALSE,
     maxits=1000, convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
     nonoise=FALSE, seed=NA, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix in sparse or dense
format or a similarity
function either specified as the name of a package-provided
similarity function as character string or a user provided
function object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a matrix or data
frame, rows are interpreted as samples and columns are 
interpreted as features; apart from matrices or data frames, 
<code>x</code> may be any other structured data type that
contains multiple data items - provided that an appropriate
<code>length</code> function is available that
returns the number of items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>desired number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prc</code></td>
<td>
<p>the algorithm stops if the number of clusters does not
deviate more than prc percent from desired value K; set to 0 if you
want to have exactly K clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bimaxit</code></td>
<td>
<p>maximum number of bisection steps to perform; note that
no warning is issued if the number of clusters is still not in
the desired range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>flag indicating whether or not to compute the initial
preference range exactly (see <code>preferenceRange</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxits</code></td>
<td>
<p>maximal number of iterations that <code>apcluster</code>
should execute</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convits</code></td>
<td>
<p><code>apcluster</code> terminates if the examplars have not
changed for <code>convits</code> iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>damping factor for  <code>apcluster</code>; should be a value in
the range [0.5, 1);
higher values correspond to heavy damping which may be
needed if oscillations occur</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code>APResult</code> object. The default is <code>FALSE</code>
if <code>apclusterK</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>if <code>TRUE</code>, more detailed information about the
algorithm's progress is stored in the output object
(see <code>APResult</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonoise</code></td>
<td>
<p><code>apcluster</code> adds a small amount of noise to
<code>s</code> to prevent degenerate cases; if <code>TRUE</code>,
this is disabled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value, if <code>NA</code>,
the seed remains unchanged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>flag indicating whether status information should be
displayed during bisection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for the methods with signatures <code>character,ANY</code> and
<code>function,ANY</code>, all other arguments are passed to the selected 
similarity function as they are; for the methods with signatures
<code>Matrix,missing</code> and <code>sparseMatrix,missing</code>, further
arguments are passed on to the <code>apclusterK</code> methods with
signatures <code>Matrix,missing</code> and <code>dgTMatrix,missing</code>,
respectively.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>apclusterK</code> first runs <code>preferenceRange</code> to determine
the range of meaningful choices of the input preference <code>p</code>. Then
it decreases <code>p</code> exponentially for a few iterations to obtain a
good initial guess for <code>p</code>. If the number of clusters is still
too far from the desired goal, bisection is applied.
</p>
<p>When called with a similarity matrix as input, the function performs
the procedure described above. When called with the name of a package-provided
similarity function or a user-provided similarity function object and 
input data, the function first computes the similarity matrix before
running <code>apclusterK</code> on this similarity matrix. The similarity
matrix is returned for later use as part of the APResult object
depending on whether <code>includeSim</code> was set to <code>TRUE</code> (see
argument description above).
</p>
<p>Apart from minor adaptations and optimizations, the implementation is
largely analogous to Frey's and Dueck's Matlab code
(see <a href="https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/">https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/</a>).
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns a
<code>APResult</code> object.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer and Andreas Kothmeier</p>


<h3>References</h3>

<p><a href="https://github.com/UBod/apcluster">https://github.com/UBod/apcluster</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code>apcluster</code>, <code>preferenceRange</code>,
<code>APResult</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## create three Gaussian clouds
cl1 &lt;- cbind(rnorm(70, 0.2, 0.05), rnorm(70, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
cl3 &lt;- cbind(rnorm(60, 0.8, 0.04), rnorm(60, 0.8, 0.05))
x &lt;- rbind(cl1, cl2, cl3)

## run affinity propagation such that 3 clusters are obtained
apres &lt;- apclusterK(negDistMat(r=2), x, K=3)

## show details of clustering results
show(apres)

## plot clustering result
plot(apres, x)

## create sparse similarity matrix
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

sim &lt;- negDistMat(x, r=2)
ssim &lt;- as.SparseSimilarityMatrix(sim, lower=-0.2)

## run apcluster() on the sparse similarity matrix
apres &lt;- apclusterK(ssim, K=2)
apres
</code></pre>


</div>