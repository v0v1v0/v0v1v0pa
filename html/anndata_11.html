<div class="container">

<table style="width: 100%;"><tr>
<td>concat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>concat</h2>

<h3>Description</h3>

<p>Concatenates AnnData objects along an axis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">concat(
  adatas,
  axis = 0L,
  join = "inner",
  merge = NULL,
  uns_merge = NULL,
  label = NULL,
  keys = NULL,
  index_unique = NULL,
  fill_value = NULL,
  pairwise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adatas</code></td>
<td>
<p>The objects to be concatenated. If a Mapping is passed, keys are used for the <code>keys</code> argument and values are concatenated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis</code></td>
<td>
<p>Which axis to concatenate along.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join</code></td>
<td>
<p>How to align values when concatenating. If "outer", the union of the other axis is taken. If "inner", the intersection. See <code>concatenation</code> for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>How elements not aligned to the axis being concatenated along are selected. Currently implemented strategies include: * <code>NULL</code>: No elements are kept. * <code>"same"</code>: Elements that are the same in each of the objects. * <code>"unique"</code>: Elements for which there is only one possible value. * <code>"first"</code>: The first element seen at each from each position. * <code>"only"</code>: Elements that show up in only one of the objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uns_merge</code></td>
<td>
<p>How the elements of <code>.uns</code> are selected. Uses the same set of strategies as the <code>merge</code> argument, except applied recursively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>Column in axis annotation (i.e. <code>.obs</code> or <code>.var</code>) to place batch information in. If it's NULL, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keys</code></td>
<td>
<p>Names for each object being added. These values are used for column values for <code>label</code> or appended to the index if <code>index_unique</code> is not <code>NULL</code>. Defaults to incrementing integer labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_unique</code></td>
<td>
<p>Whether to make the index unique by using the keys. If provided, this is the delimeter between "orig_idxindex_uniquekey". When <code>NULL</code>, the original indices are kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_value</code></td>
<td>
<p>When <code>join="outer"</code>, this is the value that will be used to fill the introduced indices. By default, sparse arrays are padded with zeros, while dense arrays and DataFrames are padded with missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairwise</code></td>
<td>
<p>Whether pairwise elements along the concatenated dimension should be included. This is FALSE by default, since the resulting arrays are often not meaningful.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the <code>concatenation</code> section in the docs for a more in-depth description.
</p>
<p>warning: This function is marked as experimental for the <code>0.7</code> release series, and will supercede the <code>AnnData$concatenate()</code> method in future releases.
</p>
<p>warning: If you use <code>join='outer'</code> this fills 0s for sparse data when variables are absent in a batch. Use this with care. Dense data is filled with <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Preparing example objects
a &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(
    a = 1,
    b = 2,
    c = list(
      c.a = 3,
      c.b = 4
    )
  )
)

b &lt;- AnnData(
  X = matrix(c(4, 5, 6, 7, 8, 9), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("b", "c"), row.names = c("s3", "s4")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  varm = list(
    ones = matrix(rep(1L, 15), nrow = 3),
    rand = matrix(rnorm(15), nrow = 3)
  ),
  uns = list(
    a = 1,
    b = 3,
    c = list(
      c.a = 3
    )
  )
)

c &lt;- AnnData(
  X = matrix(c(10, 11, 12, 13), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(3L, 4L), row.names = c("var3", "var4")),
  uns = list(
    a = 1,
    b = 4,
    c = list(
      c.a = 3,
      c.b = 4,
      c.c = 5
    )
  )
)

# Concatenating along different axes
concat(list(a, b))$to_df()
concat(list(a, c), axis = 1L)$to_df()

# Inner and outer joins
inner &lt;- concat(list(a, b))
inner
inner$obs_names
inner$var_names

outer &lt;- concat(list(a, b), join = "outer")
outer
outer$var_names
outer$to_df()

# Keeping track of source objects
concat(list(a = a, b = b), label = "batch")$obs
concat(list(a, b), label = "batch", keys = c("a", "b"))$obs
concat(list(a = a, b = b), index_unique = "-")$obs

# Combining values not aligned to axis of concatenation
concat(list(a, b), merge = "same")
concat(list(a, b), merge = "unique")
concat(list(a, b), merge = "first")
concat(list(a, b), merge = "only")

# The same merge strategies can be used for elements in .uns
concat(list(a, b, c), uns_merge = "same")$uns
concat(list(a, b, c), uns_merge = "unique")$uns
concat(list(a, b, c), uns_merge = "first")$uns
concat(list(a, b, c), uns_merge = "only")$uns

## End(Not run)
</code></pre>


</div>