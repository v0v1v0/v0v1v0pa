<div class="container">

<table style="width: 100%;"><tr>
<td>nested_quadrature</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nested, sparse Gaussian quadrature in AGHQ</h2>

<h3>Description</h3>

<p>Compute a whole sequence of log normalizing constants
for <code>1,3,5,...,k</code> points,
using only the function evaluations from the <code>k</code>-point nested rule.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nested_quadrature(optresults, k, ndConstruction = "product", ...)

adaptive_nested_quadrature(optresults, k, ndConstruction = "product", ...)

get_quadtable(p, k, ndConstruction = "product", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>optresults</code></td>
<td>
<p>The results of calling <code>aghq::optimize_theta()</code>: see return value of that function.
The dimension of the parameter <code>p</code> will be taken from <code>optresults$mode</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer, the number of quadrature points to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndConstruction</code></td>
<td>
<p>Create a multivariate grid using a product or sparse construction?
Passed directly to <code>mvQuad::createNIGrid()</code>, see that function for further details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to <code>optresults$ff</code>, see <code>?optimize_theta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Dimension of the variable of integration.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>get_quadtable</code> currently uses <code>mvQuad</code> to compute the nodes and weights. This will be replaced
by a manual reading of the pre-tabulated nodes and weights.
</p>
<p><code>nested_quadrature</code> and <code>adaptive_nested_quadrature</code> take the <strong>log</strong> function values, just like <code>optimize_theta()</code>,
and return the <strong>log</strong> of the base/adapted quadrature rule.
</p>


<h3>Value</h3>

<p>For <code>get_quadtable</code>, a pre-computed table of nodes for the <code>k</code>-point rule,
with weights for the points from each of the <code>1,3,...,k</code>-point rules, for passing to
<code>nested_quadrature</code>. For <code>nested_quadrature</code> and <code>adaptive_nested_quadrature</code>, a named numeric vector of <code>optresults$fn</code>
values for each <code>k</code>.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code>aghq()</code>,
<code>get_hessian()</code>,
<code>get_log_normconst()</code>,
<code>get_mode()</code>,
<code>get_nodesandweights()</code>,
<code>get_numquadpoints()</code>,
<code>get_opt_results()</code>,
<code>get_param_dim()</code>,
<code>laplace_approximation()</code>,
<code>marginal_laplace_tmb()</code>,
<code>marginal_laplace()</code>,
<code>normalize_logpost()</code>,
<code>optimize_theta()</code>,
<code>plot.aghq()</code>,
<code>print.aghqsummary()</code>,
<code>print.aghq()</code>,
<code>print.laplacesummary()</code>,
<code>print.laplace()</code>,
<code>print.marginallaplacesummary()</code>,
<code>summary.aghq()</code>,
<code>summary.laplace()</code>,
<code>summary.marginallaplace()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Same setup as optimize_theta
logfteta &lt;- function(eta,y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
}
set.seed(84343124)
y &lt;- rpois(10,5) # Mode should be sum(y) / (10 + 1)
truemode &lt;- log((sum(y) + 1)/(length(y) + 1))
objfunc &lt;- function(x) logfteta(x,y)
funlist &lt;- list(
  fn = objfunc,
  gr = function(x) numDeriv::grad(objfunc,x),
  he = function(x) numDeriv::hessian(objfunc,x)
)
opt_sparsetrust &lt;- optimize_theta(funlist,1.5)

</code></pre>


</div>