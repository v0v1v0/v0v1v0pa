<div class="container">

<table style="width: 100%;"><tr>
<td>scaleGen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute scaled allele frequencies</h2>

<h3>Description</h3>

<p>The generic function <code>scaleGen</code> is an analogue to the <code>scale</code>
function, but is designed with further arguments giving scaling options.<br></p>


<h3>Usage</h3>

<pre><code class="language-R">scaleGen(x, ...)

## S4 method for signature 'genind'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c("asis", "mean", "zero"),
  truenames = TRUE
)

## S4 method for signature 'genpop'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c("asis", "mean", "zero"),
  truenames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a genind and genpop object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>a logical stating whether alleles frequencies should be
centred to mean zero (default to TRUE). Alternatively, a vector of numeric
values, one per allele, can be supplied: these values will be substracted
from the allele frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical stating whether alleles frequencies should be scaled
(default to TRUE). Alternatively, a vector of numeric values, one per
allele, can be supplied: these values will be substracted from the allele
frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NA.method</code></td>
<td>
<p>a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truenames</code></td>
<td>
<p>no longer used; kept for backward compatibility</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Methods are defined for genind and genpop
objects.  Both return data.frames of scaled allele frequencies.
</p>


<h3>Value</h3>

<p>A matrix of scaled allele frequencies with genotypes
(genind) or populations in (genpop) in rows and
alleles in columns.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## load data
data(microbov)
obj &lt;- genind2genpop(microbov)

## apply scaling
X1 &lt;- scaleGen(obj)

## compute PCAs with and without scaling
pcaObj &lt;- dudi.pca(obj, scale = FALSE, scannf = FALSE) # pca with no scaling
pcaX1  &lt;- dudi.pca(X1, scale = FALSE, scannf = FALSE, nf = 100) # pca scaled using scaleGen()
pcaX2  &lt;- dudi.pca(obj, scale = TRUE, scannf = FALSE, nf = 100) # pca scaled in-PCA

## get the loadings of alleles for the two scalings
U1 &lt;- pcaObj$c1
U2 &lt;- pcaX1$c1
U3 &lt;- pcaX2$c1

## find an optimal plane to compare loadings
## use a procustean rotation of loadings tables
pro1 &lt;- procuste(U1, U2, nf = 2)
pro2 &lt;- procuste(U2, U3, nf = 2)
pro3 &lt;- procuste(U1, U3, nf = 2)

## graphics
par(mfrow=c(2, 3))
# eigenvalues
barplot(pcaObj$eig, main = "Eigenvalues\n no scaling")
barplot(pcaX1$eig, main = "Eigenvalues\n scaleGen scaling")
barplot(pcaX2$eig, main = "Eigenvalues\n in-PCA scaling")
# differences between loadings of alleles
s.match(pro1$scorX, pro1$scorY, clab = 0,
        sub = "no scaling -&gt; scaling (procustean rotation)")
s.match(pro2$scorX, pro2$scorY, clab = 0,
        sub = "scaling scaleGen -&gt; in-PCA scaling")
s.match(pro3$scorX, pro3$scorY, clab = 0,
        sub = "no scaling -&gt; in-PCA scaling")


## End(Not run)

</code></pre>


</div>