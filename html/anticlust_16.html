<div class="container">

<table style="width: 100%;"><tr>
<td>optimal_anticlustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal ("exact") algorithms for anticlustering</h2>

<h3>Description</h3>

<p>Wrapper function that gives access to all optimal algorithms for anticlustering 
that are available in anticlust.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimal_anticlustering(x, K, objective, solver = NULL, time_limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The data input. Can be one of two structures: (1) A feature
matrix where rows correspond to elements and columns correspond
to variables (a single numeric variable can be passed as a
vector). (2) An N x N matrix dissimilarity matrix; can be an
object of class <code>dist</code> (e.g., returned by
<code>dist</code> or <code>as.dist</code>) or a <code>matrix</code>
where the entries of the upper and lower triangular matrix
represent pairwise dissimilarities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>How many anticlusters should be created or alternatively:
(a) A vector describing the size of each group (the latter
currently only works for <code>objective = "dispersion")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective</code></td>
<td>
<p>The anticlustering objective, can be "diversity",
"variance", "kplus" or "dispersion".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>Optional. The solver used to obtain the optimal
method.  Currently supports "glpk", "symphony", and
"lpSolve". See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_limit</code></td>
<td>
<p>Time limit in seconds, given to the solver.
Default is there is no time limit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a wrapper for all optimal methods supported in anticlust
(currently and in the future).  As compared to
<code>anticlustering</code>, it allows to specify the solver to
obtain an optimal solution and it can be used to obtain optimal
solutions for all supported anticlustering objectives (variance,
diversity, k-plus, dispersion). For the objectives "variance",
"diversity" and "kplus", the optimal ILP method in Papenberg and
Klau (2021) is used, which maximizes the sum of all pairwise
intra-cluster distances (given user specified number of clusters,
for equal-sized clusters).  To employ k-means anticlustering
(i.e. set <code>objective = "variance"</code>), the squared Euclidean
distance is used. For k-plus anticlustering, the squared Euclidean
distance based on the extended k-plus data matrix is used (see
<code>kplus_moment_variables</code>).  For the diversity (and the
dispersion), the Euclidean distance is used by default, but any
user-defined dissimilarity matrix is possible.
</p>
<p>The dispersion is solved optimal using the approach described in
<code>optimal_dispersion</code>.
</p>
<p>The optimal methods make use of "solvers" that actually implement
the algorithm for finding optimal solutions. The package anticlust
supports three solvers:
</p>

<ul>
<li>
<p>The default solver lpSolve (&lt;https://sourceforge.net/projects/lpsolve/&gt;).
</p>
</li>
<li>
<p>GNU linear programming kit (&lt;http://www.gnu.org/software/glpk/&gt;), 
available from the package Rglpk and requested using <code>solver = "glpk"</code>.
The R package Rglpk has to be installed manually if this solver should be used.
</p>
</li>
<li>
<p>The Symphony solver (&lt;https://github.com/coin-or/SYMPHONY&gt;),
available from the package Rsymphony and requested using <code>solver = "symphony"</code>.
(The package Rsymphony has to be installed manually if this solver should be used).
</p>
</li>
</ul>
<p>For the maximum dispersion problem, it seems that the Symphony
solver is fastest, while the lpSolve solver seems to be good for
maximum diversity. However, note that in general the dispersion can
be solved optimally for much larger data sets than the diversity.
</p>
<p>If a <code>time_limit</code> is set and the function cannot find in the optimal
objective in the given time, it will throw an error.
</p>


<h3>Value</h3>

<p>A vector of length N that assigns a group (i.e, a number
between 1 and <code>K</code>) to each input element.
</p>


<h3>Author(s)</h3>

<p>Martin Papenberg <a href="mailto:martin.papenberg@hhu.de">martin.papenberg@hhu.de</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data &lt;- matrix(rnorm(24), ncol = 2)

# These calls are equivalent for k-means anticlustering:
optimal_anticlustering(data, K = 2, objective = "variance")
optimal_anticlustering(dist(data)^2, K = 2, objective = "diversity")

# These calls are equivalent for k-plus anticlustering:
optimal_anticlustering(data, K = 2, objective = "kplus")
optimal_anticlustering(dist(kplus_moment_variables(data, 2))^2, K = 2, objective = "diversity")

</code></pre>


</div>