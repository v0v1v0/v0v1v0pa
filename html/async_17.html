<div class="container">

<table style="width: 100%;"><tr>
<td>graphAsync</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw a graph representation of a coroutine.</h2>

<h3>Description</h3>

<p><code>graphAsync</code> will traverse the objects representing a
generator or async and render a graph of its structure
using Graphviz (if it is installed.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">graphAsync(
  obj,
  basename = if (is.name(substitute(obj))) as.character(substitute(obj)) else
    stop("Please specify basename"),
  type = "pdf",
  ...,
  envs = TRUE,
  vars = FALSE,
  handlers = FALSE,
  orphans = FALSE,
  dot = find_dot(),
  filename = paste0(basename, ".", type),
  dotfile = if (type == "dot") filename else paste0(basename, ".dot")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>A generator, async or stream object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basename</code></td>
<td>
<p>The base file name. If <code>basename="X"</code> and
<code>type="pdf"</code> you will end up with two files, <code>"X.dot"</code> and
<code>"X.pdf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>the output format. If "dot", we will just write a
Graphviz dot file. If another extension like "pdf" or "svg", will
write a DOT file and then attempt to invoke Graphviz <code>dot</code> (if it
is available according to <code>Sys.which</code>) to produce the image.
If <code>type=""</code> <code>graphAsync</code> will return graphviz DOT language as a
character vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envs</code></td>
<td>
<p>If <code>TRUE</code>, multiple nodes that share the same
environment will be grouped together in clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>If <code>TRUE</code>, context variables used in each state node
will be included on the graph, with edges indicating
reads/stores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handlers</code></td>
<td>
<p>If <code>TRUE</code>, state nodes will have thin edges
connecting to trampoline handlers they call, in addition to the
dashed edges connecting to the next transition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orphans</code></td>
<td>
<p>If <code>TRUE</code>, nodes will be included even if there are
no connections to them (this mostly being interface methods and
unused handlers).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dot</code></td>
<td>
<p>Optional path to the <code>dot</code> executable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Optionally specify the output picture file name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dotfile</code></td>
<td>
<p>Optionally specify the output DOT file name.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>graphAsync</code> will write a Graphviz DOT format file describing the
given generator or async/await block. The graph shows the
generator as a state machine with nodes that connect to each other.
</p>
<p>If <code>type</code> is something other than <code>dot</code> <code style="white-space: pre;">⁠graphAsync will then try to invoke Graphviz ⁠</code>dot' to turn the graph description into an image
file.
</p>
<p>The green octagonal node is where the program starts, while red
"stop" and blue "return" are where it ends. Nodes in green type on
dark background show code that runs in the host language
unmodified; gray nodes implement control flow. Dark arrows carry a
value; gray edges carry no value. A "semicolon" node receives a
value and discards it.
</p>
<p>Some nodes share a context with other nodes, shown by an enclosing
box. Contexts can have state variables, shown as a rectangular
record; orange edges from functions to variables represent writes;
blue edges represent reads.
</p>
<p>Dashed edges represent a state transition that goes through a
trampoline handler. Dashed edges have a Unicode symbol representing
the type of trampoline; (DOUBLE VERTICAL BAR) for await/yield; (TOP
ARC ANTICLOCKWISE ARROW WITH PLUS) or (TOP ARC CLOCKWISE ARROW WITH
MINUS) to wind on or off an exception handler; (ANTICLOCKWISE
TRIANGLE-HEADED BOTTOM U-SHAPED ARROW) for a plain trampoline with
no side effects (done once per loop, to avoid overflowing the
stack.)  Meanwhile, a thin edge connects to the trampoline handler.
(So the user-facing "yield" function registers a continuation to
the next step but actually calls the generator's yield handler.)
</p>


<h3>Value</h3>

<p>If <code>type=""</code>, a character vector of DOT source. Else
The name of the file that was created.
</p>


<h3>Examples</h3>

<pre><code class="language-R">randomWalk &lt;- gen({x &lt;- 0; repeat {yield(x); x &lt;- x + rnorm(1)}})
## Not run: 
graphAsync(randomWalk, "pdf")
# writes "randomWalk.dot" and invokes dot to make "randomWalk.pdf"

#or, display it in an R window with the Rgraphviz package:
g &lt;- Rgraphviz::agread("randomWalk.dot")
Rgraphviz::plot(g)

## End(Not run)
#Or render an HTML sidget using DiagrammeR:
## Not run: 
dot &lt;- graphAsync(randomWalk, type="")
DiagrammeR::DiagrammeR(paste0(dot, collapse="\n"), type="grViz")

## End(Not run)
</code></pre>


</div>