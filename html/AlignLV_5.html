<div class="container">

<table style="width: 100%;"><tr>
<td>Alignment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple-Group Factor Analysis Alignment from <code>mirt</code> or <code>lavaan</code>
</h2>

<h3>Description</h3>

<p>Performs alignment (<a href="https://www.statmodel.com/Alignment.shtml">https://www.statmodel.com/Alignment.shtml</a>) using
single-group models estimated in mirt or lavaan.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Alignment(
  fitList,
  estimator,
  SE = FALSE,
  eps.alignment = 0.01,
  clf.ignore.quantile = 0.1,
  bifactor.marginal = FALSE,
  hyper.first = "variances",
  center.means = TRUE,
  nstarts = 10,
  ncores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fitList</code></td>
<td>
<p>A <code>list</code> of fitted model objects. Currently only works
for single-group, unidimensional or bifactor models with no covariates
estimated in <code>mirt</code> or <code>lavaan</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>The model type used, either <code>'mirt.grm'</code> for the graded
response model estimated in <code>mirt</code> or <code>'lavaan.ordered'</code> for the
categorical factor analysis model applied by <code>lavaan</code> when the
<code>ordered</code> input includes all variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE</code></td>
<td>
<p>Whether to also return standard errors from parameter estimates
after alignment. SE's are transformed using the delta method from those
provided in the original model objects, which must (for <code>mirt</code>), have
been fitted with standard errors estimated (<code>SE=TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.alignment</code></td>
<td>
<p>A numeric scalar for the alignment simplicity function,
given by (Asparouhov &amp; Muthén, 2014, <em>Structural Equation Modeling</em>):
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sqrt{x^2+\epsilon}}</code>
</p>

<p>where $x$ is the difference between corresponding estimates in each pair of
aligned models. Lower values may cause numerical instability; default 0.01</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clf.ignore.quantile</code></td>
<td>
<p>Another protection from numerical instability;
CLF values less than the <code>clf.ignore.quantile</code> of the full set of CLF
values are ignored when calculating the complexity function at each step.
Default 0.1 for removing the lowest 10% of CLF values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bifactor.marginal</code></td>
<td>
<p>A logical scalar indicating whether, for bifactor
models, alignment should take place on the marginal, rather than conditional,
metric for slopes (Ip, 2010, <em>Applied Psychological Measurement</em>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyper.first</code></td>
<td>
<p>A string scalar denoting which hyperparameter to align
first. Asparouhov &amp; Muthén (2014) align all parameters simultaneously
(<code>'no'</code>); <code>'variances'</code> (default) performs a two-step process,
first aligning variances, then aligning means conditional on variance
estimates from the first step. <code>'means'</code> does the reverse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.means</code></td>
<td>
<p>A logical scalar. Alignment fixes the first group's mean
to zero to estimate the others. If <code>center.means</code> is <code>TRUE</code>
(default), aligned means and models are returned after subtracting the
weighted mean <code>weighted.mean</code> from all mean estimates,
yielding
a (weighted) grand mean of zero. Variances are automatically rescaled such
that their weighted product (i.e., log of weighted mean of
<code>e^(variance)</code>) is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstarts</code></td>
<td>
<p>Number of starting values for alignment; default is 10</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of processor cores to distribute alignment starts
across; on systems that support multicore processing, using additional cores
can speed up the alignment step by roughly a factor of the number of cores.
Defaults to 1 for no parallel processing. Requires the <code>doRNG</code>
package and defaults to sequential processing if not installed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether stuff gets printed to the console. May
help with debugging.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Currently, no automated process provides statistical tests for DIF.
Instead, I recommend interpreting the DIF impact directly by comparing
scores obtained from a single-group model combining all groups, and the
multiple models produced by <code>Alignment</code>. If standard errors
are requested from <code>getEstimates.mirt</code>, or
<code>getEstimates.lavaan</code>, and then the corresponding
<code>transformEstimates.mirt.grm</code> or
<code>transformEstimates.lavaan.ordered</code> is applied, SE's after
alignment can be
obtained and used for multiple comparison testing, but this is not yet
automated. Alternatively, consider re-fitting models with means and
variances fixed to those obtained from alignment to obtain these standard
errors. In the latter case, especially when priors are used as in
<code>mirt</code>, your estimates may not match those from <code>Alignment</code>
exactly.
</p>
<p>For <code>lavaan</code>, the metric for alignment must be the "theta"
parameterization, which is not the default, in order to properly search for
latent means and variances, because only then do the transformations apply.
My current thinking: under the delta parameterization, the transformed
estimates (calculate delta, incorporate it into parameters, then
transform parameters, BUT don't reverse the delta transformation) do NOT
yield an equivalent model, but DO yield a model that can be compared
across groups. In order to get an equivalent model, you also need to
reverse the delta transformation at the end. To account for this, if
the the extra argument toCompare should be turned on <code>TRUE</code> if
transformed parameters are to be compared for equivalence across groups.
Turning it off results in NOT applying the reverse of the delta
transformation at the end. This currently is fixed to TRUE and cannot
be modified, but you can access
<code>transformEstimates.lavaan.ordered</code>
directly if you want to play around.
</p>
<p>If <code>parallel==TRUE</code>, a parallel backend with the <code>doParallel</code> package
leverages multi-core processing if the number of cores specified in
<code>ncores</code> is greater than one. Uses <code>%dorng%</code> to pass the
R session's seed to the alignment optimizer, such that you can replicate
random starts with <code>set.seed</code> (see example).
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fit</code> A <code>list</code> of fitted objects of type <code>mirt</code> or <code>lavaan</code>,
depending
on the estimator, where models were re-estimated with means and variances
set to those obtained from alignment.
</p>
</li>
<li> <p><code>est.og</code> A nested <code>list</code> of parameter estimates and standard errors
provided to
the alignment optimizer from the provided models. Each element corresponds
to a provided model, and each element thereof corresponds to a parameter
name (e.g., <code>a</code> and <code>d</code> parameters from <code>mirt.grm</code>) and contains a matrix of
the corresponding estimates.
</p>
</li>
<li> <p><code>est</code> The estimates from <code>est.og</code>, transformed after alignment using the
obtained mean and variance estimates therefrom.
</p>
</li>
<li> <p><code>hypers</code> A <code>list</code> of two-element numeric vectors, where <code>mean</code> gives the
estimated mean from alignment in the corresponding group, and <code>var</code> the
estimated variance.
</p>
</li>
<li> <p><code>parout</code> Optimizer output for the alignment step, used to examine
convergence. Contains the following columns:
</p>

<ul>
<li> <p><code>f</code> The final complexity function value from alignment.
</p>
</li>
<li> <p><code>convergence</code> The <code>convergence</code> output from <code>optim</code>
</p>
</li>
<li> <p><code>M.2</code> to <code>M.</code>(number of groups minus 2) The estimated means from
alignment
</p>
</li>
<li> <p><code>V.2</code> to <code>M.</code>(number of groups minus 2) The estimated variances from
alignment
</p>
</li>
</ul>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">#load data
library(mirt)
library(lavaan)
library(purrr)
library(tibble)
library(magrittr)
dat=expand.table(Bock1997)
#fit configural models
fit.mirt=mirt(dat,1,SE=TRUE)
fit.lavaan=cfa(model='G =~ Item.1+Item.2+Item.3',data=dat,
               ordered=c('Item.1','Item.2','Item.3'),
               std.lv=TRUE,parameterization='delta')
(fit.lavaan@ParTable)%&gt;%tibble::as_tibble()%&gt;%print(n=Inf)
#test stuff
tab=fit.lavaan@ParTable
tab$start[23]=3
tab$est[23]=3
fit.lavaan2=lavaan(tab,data=fit.lavaan@Data)

#get estimates
est.mirt=getEstimates.mirt(fit.mirt,SE=TRUE,bifactor.marginal=FALSE)
est.lavaan=getEstimates.lavaan(fit.lavaan,SE=TRUE)

#test transformations
newMean=10
newVar=2
test.mirt=transformEstimates.mirt.grm(newMean,newVar,est.mirt)
test.lavaan=transformEstimates.lavaan.ordered(
              newMean,newVar,est.lavaan,toCompare=TRUE)
#load and test equivalence
tfit.mirt=loadEstimates.mirt.grm(fit.mirt,newMean,newVar,newpars=test.mirt,
                                 verbose=TRUE)
test.mirt=mirt::coef(fit.mirt)
test.mirt
tfit.lavaan=loadEstimates.lavaan.ordered(
              fit.lavaan,newMean,newVar,newpars=test.lavaan,
              verbose=TRUE)
tfit.lavaan@ParTable%&gt;%tibble::as_tibble()%&gt;%print(n=Inf)
test.lavaan

#now on stacked estimates
estList=list(est.mirt%&gt;%purrr::imap(function(x,n){
  rownames(x)[2]=paste0(rownames(x)[2],'_ho')
  if(!n%in%c('a','se.a'))colnames(x)[2]=paste0(colnames(x)[2],'_ho')
  x
}),est.mirt%&gt;%purrr::imap(function(x,n){
  rownames(x)[1]=paste0(rownames(x)[1],'_hi')
  if(!n%in%c('a','se.a'))colnames(x)[1]=paste0(colnames(x)[1],'_hi')
  x
}))
stack=stackEstimates(estList)
test.stack=transformEstimates.mirt.grm(c(0,0),c(1,1),stack)
sf.stack=SF.mplus3D(c(0,1),stack,combn(1:2,2),c(100,200),'mirt.grm',
                                       eps.alignment=0.01,
                                       clf.ignore.quantile=0.1)
test.stack2=transformEstimates.mirt.grm(c(0,1),c(1,1/2),stack)

#try align?
#lavaan
set.seed(0)
sim.base=list(simdata(a=as.numeric(est.mirt$a),d=est.mirt$d,N=5000,
                      itemtype='graded',sigma=matrix(1),mu=0),
              simdata(a=as.numeric(est.mirt$a),d=est.mirt$d,N=5000,
                      itemtype='graded',sigma=matrix(2),mu=1))
fit.base=sim.base%&gt;%purrr::map(~cfa(model="G =~ Item_1 + Item_2 + Item_3",
                             data=as.data.frame(.),
                             ordered=paste0('Item_',1:3),std.lv=TRUE,
                             parameterization='delta'))
fit.base%&gt;%purrr::map(lavInspect,'est')%&gt;%purrr::transpose()
est.base=purrr::map(fit.base,getEstimates.lavaan,SE=TRUE)
#not run: using parallel processes with ncores=3
set.seed(1)
# align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
#                         hyper.first='variances',ncores=3,
#                         eps.alignment=0.01,clf.ignore.quantile=0.1,
#                        estimator='lavaan.ordered',center.means=FALSE,
#                        verbose=TRUE)
# #same seed
# set.seed(1)
# align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
#                         hyper.first='variances',ncores=3,
#                         eps.alignment=0.01,clf.ignore.quantile=0.1,
#                         estimator='lavaan.ordered',center.means=FALSE,
#                         verbose=TRUE)
#sequential
align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
                        hyper.first='variances',ncores=1,
                        eps.alignment=0.01,clf.ignore.quantile=0.1,
                        estimator='lavaan.ordered',center.means=FALSE,
                        verbose=TRUE)
align.stack
fit.align=Alignment(fit.base,'lavaan.ordered',center.means=FALSE,SE=TRUE,
            verbose=TRUE)

#mirt
fit.base2=list()
for(i in 1:length(sim.base)){
  fit.base2[[i]]=mirt(sim.base[[i]],1,'graded',SE=TRUE)
}
est.base2=purrr::map(fit.base2,getEstimates.mirt,SE=TRUE,
bifactor.marginal=FALSE)
#not run: using parallel processes with ncores=3
# align.stack2=align.optim(stackEstimates(est.base2),c(100,200),nstarts=3,
#                          hyper.first='variances',ncores=3,
#                          eps.alignment=0.01,clf.ignore.quantile=0.1,
#                          estimator='mirt.grm',center.means=FALSE)
align.stack2=align.optim(stackEstimates(est.base2),c(100,200),nstarts=3,
                         hyper.first='variances',ncores=1,
                         eps.alignment=0.01,clf.ignore.quantile=0.1,
                         estimator='mirt.grm',center.means=FALSE,
                         verbose=TRUE)
align.stack2
fit.align2=Alignment(fit.base2,'mirt.grm',center.means=FALSE,SE=TRUE)

#did it work?
fit.align$hypers
fit.align2$hypers
fit.align$est%&gt;%purrr::transpose()%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
fit.align2$est%&gt;%purrr::transpose()%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
fit.align$fit
fit.align2$fit
(fit.align$fit%&gt;%purrr::map(~.@ParTable%&gt;%
tibble::as_tibble()%&gt;%dplyr::filter(free!=0))%&gt;%
  purrr::transpose())[c('start','est')]%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
(fit.align2$fit%&gt;%purrr::map(coef)%&gt;%
    purrr::transpose())[paste0('Item_',1:3)]%&gt;%
    purrr::map(~mean(.[[1]]-.[[2]]))
#appears so!

</code></pre>


</div>