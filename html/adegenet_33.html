<div class="container">

<table style="width: 100%;"><tr>
<td>Accessors</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Accessors for adegenet objects</h2>

<h3>Description</h3>

<p>An accessor is a function that allows to interact with slots of an
object in a convenient way. Several accessors are available for genind or
genpop objects. The operator "$" and "$&lt;-" are used to
access the slots, being equivalent to "@" and "@&lt;-".<br></p>
<p>The operator "[" is a flexible way to subset data by individuals,
populations, alleles, and loci. When using a matrix-like syntax,
subsetting will apply to the dimensios of the @tab slot. In addition,
specific arguments <code>loc</code> and <code>pop</code> can be used to indicate
subsets of loci and populations. The argument <code>drop</code> is a logical
indicating if alleles becoming non-polymorphic in a new dataset should
be removed (default: FALSE). Examples:<br></p>

<ul>
<li>
<p> "obj[i,j]" returns "obj" with a subset 'i' of individuals and 'j' of
alleles.<br></p>
</li>
<li>
<p> "obj[1:10,]" returns an object with only the first 10 genotypes (if
"obj" is a genind) or the first 10 populations (if
"obj" is a genpop) <br></p>
</li>
<li>
<p> "obj[1:10, 5:10]" returns an object keeping the first 10 entities and
the alleles 5 to 10.<br></p>
</li>
<li>
<p> "obj[loc=c(1,3)]" returns an object keeping only the 1st and 3rd
loci, using <code>locNames(obj)</code> as reference; logicals, or named loci
also work; this overrides other subsetting of alleles.<br></p>
</li>
<li>
<p> "obj[pop=2:4]" returns an object keeping only individuals from the
populations 2, 3 and 4, using <code>popNames(obj)</code> as reference;
logicals, or named populations also work; this overrides other
subsetting of individuals.<br></p>
</li>
<li>
<p> "obj[i=1:2, drop=TRUE]" returns an object keeping only the first
two individuals (or populations), dropping the alleles no longer
present in the data.<br></p>
</li>
</ul>
<p>The argument <code>treatOther</code> handles the treatment of objects in the
<code>@other</code> slot (see details). The argument <code>drop</code> can be set
to TRUE to drop alleles that are no longer represented in the subset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nInd(x, ...)
nLoc(x, ...)
nAll(x, onlyObserved = FALSE, ...)
nPop(x, ...)
pop(x)
indNames(x, ...)
## S4 method for signature 'genind'
indNames(x, ...)
locNames(x, ...)
## S4 method for signature 'genind'
locNames(x, withAlleles=FALSE, ...)
## S4 method for signature 'genpop'
locNames(x, withAlleles=FALSE, ...)
popNames(x, ...)
## S4 method for signature 'genind'
popNames(x, ...)
popNames(x, ...)
## S4 method for signature 'genpop'
popNames(x, ...)
ploidy(x, ...)
## S4 method for signature 'genind'
ploidy(x, ...)
## S4 method for signature 'genpop'
ploidy(x, ...)
## S4 method for signature 'genind'
other(x, ...)
## S4 method for signature 'genpop'
other(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a genind or a genpop object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyObserved</code></td>
<td>
<p>a logical indicating whether the allele count should
also include the alleles with onlyObserved columns in the matrix. Defaults
to <code>FALSE</code>, which will report only the observed alleles in the
given population. <code>onlyObserved = TRUE</code> will be the equivalent of
<code>table(locFac(x))</code>, but faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withAlleles</code></td>
<td>
<p>a logical indicating whether the result should be
of the form [locus name].[allele name], instead of [locus name].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to other methods
(currently not used).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The "[" operator can treat elements in the <code>@other</code> slot as
well. For instance, if <code>obj@other$xy</code> contains spatial
coordinates, the <code>obj[1:3, ]@other$xy</code> will contain the spatial
coordinates of the genotypes (or population) 1,2 and 3. This is
handled through the argument <code>treatOther</code>, a logical defaulting
to TRUE. If set to FALSE, the <code>@other</code> returned unmodified.<br></p>
<p>Note that only matrix-like, vector-like and lists can be proceeded in
<code>@other</code>. Other kind of objects will issue a warning an be
returned as they are, unless the argument <code>quiet</code> is left to
TRUE, its default value.<br></p>
<p>The <code>drop</code> argument can be set to TRUE to retain only alleles
that are present in the subset. To achieve better control of
polymorphism of the data, see <code>isPoly</code>.
</p>
<p><code>nAll()</code> reflects the number of columns per locus present in the current
gen object. If <code>onlyObserved = TRUE</code>, then the number of columns with at
least one non-missing allele is shown. 
</p>


<h3>Value</h3>

<p>A genind or genpop object.
</p>


<h3>Methods</h3>


<dl>
<dt>nInd</dt>
<dd>
<p>returns the number of individuals in the <code>genind</code> object</p>
</dd>
<dt>nLoc</dt>
<dd>
<p>returns the number of loci</p>
</dd>
<dt>nAll</dt>
<dd>
<p>returns the number of observed alleles in each locus</p>
</dd>
<dt>nPop</dt>
<dd>
<p>returns the number of populations</p>
</dd>
<dt>pop</dt>
<dd>
<p>returns a factor assigning individuals to populations.</p>
</dd>
<dt>pop&lt;-</dt>
<dd>
<p>replacement method for the <code>@pop</code> slot of an
object.</p>
</dd>
<dt>popNames</dt>
<dd>
<p>returns the names of populations.</p>
</dd>
<dt>popNames&lt;-</dt>
<dd>
<p>sets the names of populations using a vector of
length <code>nPop(x)</code>.</p>
</dd>
<dt>indNames</dt>
<dd>
<p>returns the names of individuals.</p>
</dd>
<dt>indNames&lt;-</dt>
<dd>
<p>sets the names of individuals using a vector of
length <code>nInd(x)</code>.</p>
</dd>
<dt>locNames</dt>
<dd>
<p>returns the names of markers and/or alleles.</p>
</dd>
<dt>locNames&lt;-</dt>
<dd>
<p>sets the names of markers using a vector of
length <code>nLoc(x)</code>.</p>
</dd>
<dt>locFac</dt>
<dd>
<p>returns a factor that defines which locus each column of the <code>@tab</code> slot belongs to</p>
</dd>
<dt>ploidy</dt>
<dd>
<p>returns the ploidy of the data.</p>
</dd>
<dt>ploidy&lt;-</dt>
<dd>
<p>sets the ploidy of the data using an integer.</p>
</dd>
<dt>alleles</dt>
<dd>
<p>returns the alleles of each locus.</p>
</dd>
<dt>alleles&lt;-</dt>
<dd>
<p>sets the alleles of each locus using a list with
one character vector for each locus.</p>
</dd>
<dt>other</dt>
<dd>
<p>returns the content of the <code>@other</code> slot
(misc. information); returns <code>NULL</code> if the slot is onlyObserved or of
length zero.</p>
</dd>
<dt>other&lt;-</dt>
<dd>
<p>sets the content of the <code>@other</code> slot
(misc. information); the provided value needs to be a list; it
not, provided value will be stored within a list.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>Examples</h3>

<pre><code class="language-R">data(nancycats)
nancycats
pop(nancycats) # get the populations
indNames(nancycats) # get the labels of individuals
locNames(nancycats) # get the labels of the loci
alleles(nancycats)  # get the alleles
nAll(nancycats)     # count the number of alleles

head(tab(nancycats)) # get allele counts

# get allele frequencies, replace NAs
head(tab(nancycats, freq = TRUE, NA.method = "mean")) 

# let's isolate populations 4 and 8
popNames(nancycats)
obj &lt;- nancycats[pop=c(4, 8)]
obj
popNames(obj)
pop(obj)
nAll(obj, onlyObserved = TRUE) # count number of alleles among these two populations
nAll(obj) # count number of columns in the data
all(nAll(obj, onlyObserved = TRUE) == lengths(alleles(obj))) # will be FALSE since drop = FALSE
all(nAll(obj) == lengths(alleles(obj))) # will be FALSE since drop = FALSE

# let's isolate two markers, fca23 and fca90
locNames(nancycats)
obj &lt;- nancycats[loc=c("fca23","fca90")]
obj
locNames(obj)

# illustrate pop
obj &lt;- nancycats[sample(1:100, 10)]
pop(obj)
pop(obj) &lt;- rep(c('b', 'a'), each = 5)
pop(obj)

# illustrate locNames
locNames(obj)
locNames(obj, withAlleles = TRUE)
locNames(obj)[1] &lt;- "newLocus"
locNames(obj)
locNames(obj, withAlleles=TRUE)

# illustrate how 'other' slot is handled
data(sim2pop)
nInd(sim2pop)
other(sim2pop[1:6]) # xy is subsetted automatically
other(sim2pop[1:6, treatOther=FALSE]) # xy is left as is

</code></pre>


</div>