<div class="container">

<table style="width: 100%;"><tr>
<td>make</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a Shiny app (object or files) from an R function</h2>

<h3>Description</h3>

<p>Create a Shiny app (object or files) from an R function
</p>


<h3>Usage</h3>

<pre><code class="language-R">makeApp(fun, withGoButton = FALSE)

makeFiles(fun, withGoButton = FALSE, directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A function 
(preferably a symbol – a long self-explanatory name – pointing to a pre-defined
function object, rather than an anonymous function) 
with zero or more arguments/parameters. <strong>Every argument must have a default value</strong>,
which will be used to define each argument's:
</p>

<ul>
<li>
<p> type/class,
</p>
</li>
<li>
<p> allowed values,
</p>
</li>
<li>
<p> pre-selected/start-up value.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withGoButton</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code> (default: <code>FALSE</code>).
It indicates if the (re)evaluation of <code>fun</code> in the Shiny app should be immediately
triggered  by every change in the value of any argument/parameter
(<code>withGoButton</code> = <code>FALSE</code>) or if the (re)calculation should be started
only when a specific button is pressed (<code>withGoButton</code> = <code>TRUE</code>).
The latter is preferred if the (re)evaluation of <code>fun</code> is significantly
time-consuming or if <code>fun</code> has no arguments (because then, without the button,
only refreshing the web page would trigger the (re)evaluation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directory</code></td>
<td>
<p>Path to a directory/folder where <code>makeFiles</code> should save the
compiled <code>server.R</code> and <code>ui.R</code> files.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<dl>
<dt>makeApp</dt>
<dd>
<p>A Shiny app object as returned by <code>as.shiny.appobj</code>.</p>
</dd>
<dt>makeFiles</dt>
<dd>
<p><code>NULL</code>. This function saves two plain text files:
<code>ui.R</code> and <code>server.R</code> with the R code of function <code>fun</code>
translated into a Shiny app. If these files need further manual changes,
it is recommended that they are first re-formatted e.g. in RStudio
(top menu -&gt; Code -&gt; Reformat Code or Ctrl+Shift+A) or programmatically
(e.g. <a href="https://github.com/google/rfmt">https://github.com/google/rfmt</a>).</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(shiny)

### Example 1: Trivial anonymous function
makeApp(function(x=1:3, y=5:9) x+y)

### Example 2: Nicer function and argument names
`Histogram for normal distribution` &lt;-
    function(`Number of observations` =
             # as.integer =&gt; the argument interpreted as categorical:
             as.integer(c(100,10,1000)))
        # Generic R plots as "return values" are supported:
        plot(hist(rnorm(`Number of observations`)))
makeApp(`Histogram for normal distribution`)

### Example 3: Data frame in (upload CSV), data frame out (displayed and downloadable as CSV)
`Table of sin and cos values` &lt;-
    function(`Upload CSV file with column "x"` =
                 data.frame(x = seq(0, 2*pi, .25))) {
        dta &lt;- `Upload CSV file with column "x"`
        data.frame(X = dta$x,
                   `Sin of X` = sin(dta$x),
                   `Cos of X` = cos(dta$x),
                   check.names = FALSE)
    }
makeApp(`Table of sin and cos values`)

### Example 4: Arbitrary input and output files
openxlsx::write.xlsx(data.frame(x=1:5,
                                y=11:15),
                     'my_test_file.xlsx')
`Excel file in and out` &lt;-
    function(`Input Excel file` =
                 File('my_test_file.xlsx')) { # File() obligatory here!
        my.data &lt;- openxlsx::read.xlsx(`Input Excel file`)
        my.data2 &lt;- within(my.data,
                           z &lt;- x + y)
        openxlsx::write.xlsx(my.data2,
                             'my_test_file_2.xlsx')
        File('my_test_file_2.xlsx') # File() obligatory here too!
    }
makeApp(`Excel file in and out`)

### Example 5: Using a button as a (re-)evaluation trigger
### Use this option if:
### - the evaluation of your functon takes time, so it should not be re-evaluated with every
###   minor change of the value of inputs/arguments/parameter;
### - the function is impure e.g. depends on some external data fetched internally and takes no
###   arguments/parameters -- in such a case the function would be re-evaluated only through
###   page refresh of the browser; the button is a faster and a more elegant solution.
`Get "GDP and main components" from Eurostat` &lt;-
    function() {
        # Getting data from
        # http://ec.europa.eu/eurostat/estat-navtree-portlet-prod/BulkDownloadListing ...
        # ... ?sort=1&amp;file=data%2Fnama_10_gdp.tsv.gz
        x &lt;- eurodata::importData('nama_10_gdp')
        head(x, 10)
    }
makeApp(`Get "GDP and main components" from Eurostat`,
        withGoButton = TRUE)

### Example 6: Lists of inputs (arguments) and the output list (composite return value)
### are always decomposed
`A function with lists everywhere` &lt;-
    function(`First argument group,` = list(`number one` = 1:3,
                                            `number two` = letters[1:3]),
             `2nd arg group,` = list(`1st argument` = 11:14,
                                     `second arg.` = LETTERS[1:5]))
        list(`Some text` =
                 as.character(c(`First argument group,`$`number two`,
                                `2nd arg group,`$`second arg.`)),
             `Some numbers` =
                 `First argument group,`$`number one` +
                 `2nd arg group,`$`1st argument`,
             `Even a ggplot2 chart` =
                 ggplot2::qplot(a,b,data=data.frame(a=1:20,b=log(1:20))))
makeApp(`A function with lists everywhere`)

## End(Not run)
</code></pre>


</div>