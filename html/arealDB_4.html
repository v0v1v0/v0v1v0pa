<div class="container">

<table style="width: 100%;"><tr>
<td>normGeometry</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normalise geometries</h2>

<h3>Description</h3>

<p>Harmonise and integrate geometries into a standardised format
</p>


<h3>Usage</h3>

<pre><code class="language-R">normGeometry(
  input = NULL,
  pattern = NULL,
  query = NULL,
  thresh = 10,
  outType = "gpkg",
  priority = "ontology",
  beep = NULL,
  simplify = FALSE,
  update = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>[<code>character(1)</code>]<br> path of the file to normalise. If this
is left empty, all files at stage two as subset by <code>pattern</code> are
chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>[<code>character(1)</code>]<br> an optional regular expression. Only
dataset names which match the regular expression will be processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>[<code>character(1)</code>]<br> part of the SQL query (starting from
WHERE) used to subset the input geometries, for example <code>where NAME_0
= 'France'</code>. The first part of the query (where the layer is defined) is
derived from the meta-data of the currently handled geometry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>[<code>integerish(1)</code>]<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outType</code></td>
<td>
<p>[<code>character(1)</code>]<br> the output file-type, see
<code>st_drivers</code> for a list. If a file-type supports layers, they
are stored in the same file, otherwise the different layers are provided
separately. For an R-based workflow, <code>"rds"</code> could be an efficient
option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priority</code></td>
<td>
<p>[<code>character(1)</code>]<br> how to match the new geometries with
the already harmonised database. This can either be
</p>

<ul>
<li> <p><code>"spatial"</code>: where all territories are intersected spatially or
</p>
</li>
<li> <p><code>"ontology"</code>: where territories are matched by comparing their
name with the ontology
and those that do not match are intersected spatially,
</p>
</li>
<li> <p><code>"both"</code>: where territories are matched with the ontology and
spatially, and conflicts are indicated
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beep</code></td>
<td>
<p>[<code>integerish(1)</code>]<br> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code>beep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>[<code>logical(1)</code>]<br> whether or not to simplify geometries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p>[<code>logical(1)</code>]<br> whether or not the physical files should
be updated (<code>TRUE</code>) or the function should merely return the geometry
inventory of the handled files (<code>FALSE</code>, default). This is helpful to
check whether the metadata specification and the provided file(s) are
properly specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br> be verbose about what is happening
(default <code>FALSE</code>). Furthermore, you can use
<code>suppressMessages</code> to make this function completely silent.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To normalise geometries, this function proceeds as follows:
</p>
 <ol>
<li>
<p> Read in <code>input</code> and extract initial metadata from
the file name. </p>
</li>
<li>
<p> In case filters are set, the new geometry is filtered
by those. </p>
</li>
<li>
<p> The territorial names are matched with the gazetteer to
harmonise new territorial names (at this step, the function might ask the
user to edit the file 'matching.csv' to align new names with already
harmonised names). </p>
</li>
<li>
<p> Loop through every nation potentially included in
the file that shall be processed and carry out the following steps:
</p>
 <ul>
<li>
<p> In case the geometries are provided as a list of simple
feature POLYGONS, they are dissolved into a single MULTIPOLYGON per main
polygon. </p>
</li>
<li>
<p> In case the nation to which a geometry belongs has not yet
been created at stage three, the following steps are carried out:
</p>
 <ol><li>
<p> Store the current geometry as basis of the respective
level (the user needs to make sure that all following levels of the same
dataseries are perfectly nested into those parent territories, for example
by using the GADM dataset) </p>
</li></ol>
</li>
<li>
<p> In case the nation to which the geometry
belongs has already been created, the following steps are carried out:
</p>
 <ol>
<li>
<p> Check whether the new geometries have the same coordinate
reference system as the already existing database and re-project the new
geometries if this is not the case. </p>
</li>
<li>
<p> Check whether all new geometries
are already exactly matched spatially and stop if that is the case. </p>
</li>
<li>
<p>Check whether the new geometries are all within the already defined
parents, and save those that are not as a new geometry. </p>
</li>
<li>
<p> Calculate
spatial overlap and distinguish the geometries into those that overlap with
more and those with less than <code>thresh</code>. </p>
</li>
<li>
<p> For all units that did
match, copy gazID from the geometries they overlap. </p>
</li>
<li>
<p> For all units that
did not match, rebuild metadata and a new gazID. </p>
</li>
</ol>
</li>
<li>
<p> If update = TRUE,
store the processed geometry at stage three.</p>
</li>
</ul>
</li>
<li>
<p> Move the geometry to
the folder '/processed', if it is fully processed.</p>
</li>
</ol>
<h3>Value</h3>

<p>This function harmonises and integrates so far unprocessed geometries
at stage two into stage three of the geospatial database. It produces for
each main polygon (e.g. nation) in the registered geometries a spatial file
of the specified file-type.
</p>


<h3>See Also</h3>

<p>Other normalise functions: 
<code>normTable()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(dev.interactive()){
  library(sf)

  # build the example database
  makeExampleDB(until = "regGeometry", path = tempdir())

  # normalise all geometries ...
  normGeometry(nation = "estonia", update = TRUE)

  # ... and check the result
  st_layers(paste0(tempdir(), "/adb_geometries/stage3/Estonia.gpkg"))
  output &lt;- st_read(paste0(tempdir(), "/adb_geometries/stage3/Estonia.gpkg"))
}
</code></pre>


</div>