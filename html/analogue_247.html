<div class="container">

<table style="width: 100%;"><tr>
<td>tran</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Common data transformations and standardizations</h2>

<h3>Description</h3>

<p>Provides common data transformations and standardizations useful for
palaeoecological data. The function acts as a wrapper to function
<code>decostand</code> in package vegan for several of the
available options.
</p>
<p>The <code>formula</code> method allows a convenient method for selecting or
excluding subsets of variables before applying the chosen
transformation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
tran(x, method, a = 1, b = 0, p = 2, base = exp(1),
     na.rm = FALSE, na.value = 0, ...)

## S3 method for class 'formula'
tran(formula, data = NULL, subset = NULL,
     na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix-like object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>transformation or standardization method to apply. See
Details for available options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Constant to multiply <code>x</code> by. <code>method = "log"</code>
only. Can be a vector, in which case the vector of values to
multiply each column of <code>x</code> by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Constant to add to <code>x</code> before taking logs. <code>method
      = "log"</code> only. Can be a vector, in which case the vector of values
to add to each column of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>The power to use in the power transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>the base with respect to which logarithms are
computed. See <code>log</code> for further details. The default is
to compute natural logarithms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values be removed before some computations?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.value</code></td>
<td>
<p>The value with which to replace missing values
(<code>NA</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>decostand</code>, or
other <code>tran</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A model formula describing the variables to be
transformed. The formula should have only a right hand side,
e.g.~<code>~ foo + bar</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, subset, na.action</code></td>
<td>
<p>See <code>model.frame</code> for
details on these arguments. <code>data</code> will generally be the
object or environment within which the variables in the forumla are
searched for.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function offers following transformation and standardization
methods for community data:
</p>

<ul>
<li> <p><code>sqrt</code>: take the square roots of the observed values.
</p>
</li>
<li> <p><code>cubert</code>: take the cube root of the observed values.
</p>
</li>
<li> <p><code>rootroot</code>: take the fourth root of the observed
values. This is also known as the root root transformation (Field
et al 1982).
</p>
</li>
<li> <p><code>log</code>: take the logarithms of the observed values. The
tansformation applied can be modified by constants <code>a</code> and
<code>b</code> and the <code>base</code> of the logarithms. The transformation
applied is <code class="reqn">x^* = \log_{\mathrm{base}}(ax + b)</code>
</p>
</li>
<li> <p><code>log1p</code>: computes <code class="reqn">log(1 + x)</code> accurately also for
<code class="reqn">|x| &lt;&lt; 1</code> via <code>log1p</code>. Note the arguments <code>a</code>
and <code>b</code> have no effect in this method.
</p>
</li>
<li> <p><code>expm1</code>: computes <code class="reqn">exp(x) - 1)</code> accurately for
<code class="reqn">|x| &lt;&lt; 1</code> via <code>expm1</code>.
</p>
</li>
<li> <p><code>reciprocal</code>: returns the multiplicative inverse or
reciprocal, <code class="reqn">1/x</code>, of the observed values.
</p>
</li>
<li> <p><code>freq</code>: divide by column (variable, species)  maximum and
multiply by the number of non-zero items, so that the average of
non-zero entries is 1 (Oksanen 1983).
</p>
</li>
<li> <p><code>center</code>: centre all variables to zero mean.
</p>
</li>
<li> <p><code>range</code>: standardize values into range 0 ... 1. If all
values are constant, they will be transformed to 0.
</p>
</li>
<li> <p><code>percent</code>: convert observed count values to percentages.
</p>
</li>
<li> <p><code>proportion</code>: convert observed count values to proportions.
</p>
</li>
<li> <p><code>standardize</code>: scale <code>x</code> to zero mean and unit
variance.
</p>
</li>
<li> <p><code>pa</code>: scale <code>x</code> to presence/absence scale (0/1).
</p>
</li>
<li> <p><code>missing</code>: replace missing values with <code>na.value</code>.
</p>
</li>
<li> <p><code>chi.square</code>: divide by row sums and square root of
column sums, and adjust for square root of matrix total
(Legendre &amp; Gallagher 2001). When used with the Euclidean
distance, the distances should be similar to the the
Chi-square distance used in correspondence analysis. However, the
results from <code>cmdscale</code> would still differ, since
CA is a weighted ordination method.
</p>
</li>
<li> <p><code>hellinger</code>: square root of observed values that have
first been divided by row (site) sums (Legendre &amp; Gallagher 2001).
</p>
</li>
<li> <p><code>wisconsin</code>: applies the Wisconsin double
standardization, where columns (species, variables) are first
standardized by maxima and then sites (rows) by site totals.
</p>
</li>
<li> <p><code>pcent2prop</code>: convert percentages to proportions.
</p>
</li>
<li> <p><code>prop2pcent</code>: convert proportions to percentages.
</p>
</li>
<li> <p><code>logRatio</code>: applies a log ransformation (see <code>log</code>
above) to the data, then centres the data by rows (by subtraction of
the mean for row <em>i</em> from the observations in row
<em>i</em>). Using this transformation subsequent to PCA results in
Aitchison's Log Ratio Analysis (LRA), a means of dealing with closed
compositional data such as common in palaeoecology (Aitchison, 1983).
</p>
</li>
<li> <p><code>power</code>: applies a power tranformation.
</p>
</li>
<li> <p><code>rowCentre</code>, <code>rowCenter</code>: Centres <code>x</code> by rows
through the subtraction of the corresponding row mean from the
observations in the row.
</p>
</li>
<li> <p><code>colCentre</code> <code>colCenter</code>: Centres <code>x</code> by columns
through the subtraction of the corresponding column mean from the
observations in the row.
</p>
</li>
<li> <p><code>none</code> <code>none</code>: no transformation is applied.
</p>
</li>
</ul>
<h3>Value</h3>

<p>Returns the suitably transformed or standardized <code>x</code>. If <code>x</code>
is a data frame, the returned value is like-wise a data frame. The
returned object also has an attribute <code>"tran"</code> giving the name of
applied transformation or standardization <code>"method"</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson. Much of the functionality of <code>tran</code> is
provided by <code>decostand</code>, written by Jari Oksanen.</p>


<h3>References</h3>

<p>Aitchison, J. (1983) Principal components analysis of compositional
data. <em>Biometrika</em> <strong>70</strong>(1); 57–65.
</p>
<p>Field, J.G., Clarke, K.R., &amp; Warwick, R.M. (1982) A practical strategy
for analysing multispecies distributions patterns. <em>Marine
Ecology Progress Series</em> <strong>8</strong>; 37–52.
</p>
<p>Legendre, P. &amp; Gallagher, E.D. (2001) Ecologically meaningful
transformations for ordination of species data. <em>Oecologia</em>
<strong>129</strong>; 271-280.
</p>
<p>Oksanen, J. (1983) Ordination of boreal heath-like vegetation with
principal component analysis, correspondence analysis and
multidimensional scaling. <em>Vegetatio</em> <strong>52</strong>; 181-189.
</p>


<h3>See Also</h3>

<p><code>decostand</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(swapdiat)
## convert percentages to proportions
sptrans &lt;- tran(swapdiat, "pcent2prop")

## apply Hellinger transformation
spHell &lt;- tran(swapdiat, "hellinger")

## Dummy data to illustrate formula method
d &lt;- data.frame(A = runif(10), B = runif(10), C = runif(10))
## simulate some missings
d[sample(10,3), 1] &lt;- NA
## apply tran using formula
tran(~ . - B, data = d, na.action = na.pass,
     method = "missing", na.value = 0)
</code></pre>


</div>