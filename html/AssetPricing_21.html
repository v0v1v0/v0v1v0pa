<div class="container">

<table style="width: 100%;"><tr>
<td>xsolve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimal pricing policy
</h2>

<h3>Description</h3>

<p>Determines (by solving a coupled system of differential equations)
the optimal prices as functions of (residual) time for a
number perishable assets. Prices may be discrete or continuous.
For continuous prices, the price sensitivity function may either
be a smooth (twice differentiable) function or a function which
is piecewise linear in price.
</p>


<h3>Usage</h3>

<pre><code class="language-R">   xsolve(S, lambda, gprob=1, tmax=NULL, qmax, prices=NULL, nout=300,
          type="sip", alpha=NULL, salval=0, epsilon=NULL,
          method="lsoda",verbInt=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>

<p>An expression, or list of expressions, or a function or list
of functions, specifying the price sensitivity functions
<code>S_j(x,t)</code>.  See <b>Details</b>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A function (of residual time <code>t</code> — see <code>tmax</code>) or
a positive constant, specifying the intensity of the (generally
inhomogeneous) Poisson process of arrival times of groups of
potential customers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gprob</code></td>
<td>

<p>A function (to calculate probabilities) or a numeric vector of 
probabilities determining the distribution of the size of
an arriving group of customers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmax</code></td>
<td>

<p>The maximum residual time; think of this as being the initial time
at which the assets go on sale (with time <em>decreasing</em> to zero,
at which point the value of each asset drops to the “salvage
value” (<code>salval</code>), usually <code>0</code>).  The system of differential
equations is solved over the time interval [0,<code>tmax</code>].
See <b>Details</b>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qmax</code></td>
<td>

<p>The maximum number of assets available for sale, i.e. the number
of assets available at the starting (residual) time <code>tmax</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prices</code></td>
<td>

<p>A numeric vector (with positive values) listing the possible
prices at which items may be offered for sale in the discrete
pricing scenario.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nout</code></td>
<td>

<p>The number of points at which values of the solution are to be
provided.  These are taken to be equispaced on
[0,<code>tmax</code>].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Scalar character string taking one of the two values <code>"sip"</code>
(singly indexed prices) and <code>"dip"</code> (doubly indexed prices).
In the <code>"dip"</code> case the price of the asset which is quoted
to the arriving group is allowed to depend upon the group size
(as well as upon (residual) time as well as on the number of
assets remaining for sale.  In the <code>"sip"</code> case the quoted
price does not depend upon group size.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>A numeric scalar between 0 and 1 specifying the probability that an
arriving group of size <code>j &gt; q</code> (where <code>q</code> is the number
of assets remaining for sale) will <em>consider</em> purchasing
(all of) these remaining assets.  It is irrelevant (and defaults
to 1 as a “place holder”) if customers always arrive singly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>salval</code></td>
<td>

<p>A (non-negative) numeric scalar specifying the “salvage
value” of an asset — i.e. the quantity to which the value of an
asset drops at residual time <code>t=0</code>.  Usually <code>salval</code>
is equal to 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>A numeric scalar used in determining the optimal price
in settings in which this involves maximizing over a discrete set.
See <b>Details</b>.  It defaults to <code>.Machine$double.eps^0.25</code>
in the case of discrete prices and to <code>.Machine$double.eps^0.5</code>
when the price sensitivity function is piecewise linear.
It is ignored if the price sensitivity function is smooth.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Character string specified the solution method to be used
by the differential equation solver <code>ode()</code>.  There is
a fairly large number of possible methods.  See
<code>ode()</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbInt</code></td>
<td>

<p>A scalar value which controls “verbosity”.
If <code>verbInt &gt; 0</code> then a “progress report” is
printed every <code>verbInt</code> <em>seconds</em> (roughly).  That is
if the current value of <code>Sys.time()</code> is greater than or
equal to the value stored at the time of the last report, plus
<code>verbInt</code> seconds, then a new “report” is printed out.
If <code>verbInt</code> is less than or equal to 0 then the solution
process runs “silently”.  See section <b>Progress
Reports</b> for a bit more detail.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If prices are modelled as being continuous, and if the price
sensitivity function is differentiable, a coupled system
of differential equations for the optimal prices is solved.
If the prices are modelled as being discrete or if the price
sensitivity function is piecewise linear in price, then a
coupled system of differential equations for the expected
value of the stock is solved, with the optimal price being
determined at each step by maximizing over an appropriate finite
discrete set.  These differential equations are solved by the
<code>ode()</code> function from the <code>deSolve</code>
package.
</p>
<p>The components of the argument <code>S</code> should be provided as
expressions when the price sensitivity functions are assumed to
be smooth, and these should be amenable to differentiation with
respect to <code>x</code> and <code>t</code> via the function <code>deriv3()</code>.
</p>
<p>Note that in general the expression or expressions will depend upon
a number of <em>parameters</em> as well as upon <code>x</code> and <code>t</code>.
The values of these parameters are specified via an attribute or
attributes.  If <code>S</code> is a (single) expression it has (must have)
an attribute called <code>parvec</code> which is a <em>named</em> vector of
parameter values.  If <code>S</code> is a list of expressions each entry
of the list has (must have) such an attribute.
</p>
<p>In the “piecewise linear” context <code>S</code> can be
specified <em>only</em> as a single function.  It is then assumed
that the price sensitivity function for a group of size <code>j</code>
is given by <code>S_j(x,t) = S(x,t)^j</code>.  Such piecewise linear
price sensitivity functions should be built using the function
<code>buildS()</code>.
</p>
<p>In the case of discrete prices the argument <code>S</code> must be a
function or list of functions specifying the price sensitivity
functions <code>S_j(x,t)</code>.  These functions need only be defined
for the prices listed in the <code>prices</code> argument.
</p>
<p>If <code>S</code> is a single expression or function, then
<code>S_j(x,t)</code> is taken to be this expression or function raised
to the power <code>j</code>.  If <code>S</code> is a list, then <code>S_j(x,t)</code>
is taken to be its <code>j</code>-th entry.
</p>
<p>In the case where argument <code>S</code> is a piecewise linear
price sensitivity function, the argument <code>tmax</code> is, if not
specified, taken to be the value of the corresponding attribute
of <code>S</code>.  In this setting, if <code>tmax</code> <em>is</em> specified
it must be less than or equal to the corresponding attribute
of <code>S</code>.
</p>
<p>For discrete prices and for piecewise linear price sensitivity
functions, determining the optimal price involves maximizing
expected values over finite discrete sets.  It can happen that the
location of the maximum can make a sudden “jump” from one
time step to the next, causing anomalous looking discontinuities
in the optimal price functions.  To avoid this, we check on the
change in the expected value at each of the possible new prices
as compared with that at the “previous” price.
</p>
<p>If the maximal “improvement” in expected value is less
than or equal to <code>epsilon</code> then the “new” price is
set equal to the previous value.  If the maximal improvement
is greater than <code>epsilon</code> then those values of price,
where the expected value is greater than the maximum value minus
<code>epsilon</code>, are considered and the one which is closest to
the previous price is chosen.
</p>
<p>If <code>epsilon</code> is set equal to a value less than or equal to
<code>0</code> then the smoothing strategy described above is dispensed
with. In this case the maximum is taken to be the first of the
(possibly) multiple maxima of the expected value.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The optimal pricing policy, chosen to maximize the expected
value of the remaining assets at any given time; an object of
class <code>flap</code> (“function list for asset pricing”).  (In
the case of discrete prices it also inherits from <code>pwc.flap</code>
(<code>pwc</code> stands for “piecewise constant”), and if
<code>type=="dip"</code> it also inherits from <code>di.flap</code>.)
If <code>type=="sip"</code> it has the form of a list of functions
<code>x_q(t)</code>, with <code>q</code> running from 1 to <code>qmax</code>
If <code>type=="dip"</code> if has the form of a list of functions
<code>x_qj(t)</code> with <code>q</code> running from 1 to <code>qmax</code> and
<code>j</code> running from 1 to <code>min(q,jmax)</code> where <code>jmax</code>
is the maximum group size.
</p>
<p>In the case of continuous prices these functions will be
continuous functions created by <code>splinefun()</code>.  In the
case of discrete prices these functions will be piecewise constant
(of class <code>stepfun</code>) created by <code>stepfun()</code>.
</p>
<p>Note that <code>x</code> has an <em>attribute</em> <code>qmax</code> specifying
the maximum number of assets available for sale, i.e. the number
of assets available at the starting (residual) time <code>tmax</code>.
Of course if <code>type=="sip"</code> then this attribute is simply
the length of <code>x</code>.  Note that if <code>type == "dip"</code> then
the entry <code>x[[i]]</code> is equal to the function <code>x_qj(t)</code>
where <code>i = (j-1)*(qmax - j/2) + q</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are (spline)
functions <code>v_q(t)</code> specifying the (optimal) expected value
of <code>q</code> assets at time <code>t</code> corresponding to the (optimal)
pricing policy <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vdot</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are
the derivatives (with respect to <code>t</code>) of the functions
<code>v_q(t)</code> described above.  The values of these derivatives
are determined sequentially in the process of solving the system
of differential equations for the optimal pricing policy.
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>A substantial change was made to this package as of the change
of version number from 0.0-11 to 0.1-0.  Previously the differential
equations which arise were solved via a “locally produced”
roll-your-own Runge-Kutta procedure.  Now they are solved (in a
more sophisticated manner) using the package <code>deSolve</code>.  This
increases the solution speed by a factor of about 7.  There will
be (minor, it is to be hoped) numerical differences in solutions
produced from the same input.
</p>


<h3>Progress Reports</h3>

<p>The “progress reports” produced when <code>verbInt &gt; 0</code>
consist of rough estimates of the percentage of <code>[0,tmax]</code>
(the interval over which the differential equation is being solved)
remaining to be covered.  A rough estimate of the total elapsed
time since the solution process started is also printed out.
</p>
<p>Having “progress reports” printed out appears to have no
(or at worst negligible) impact on computation time.'
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee, and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533–540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1–25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code>vsolve()</code>, <code>plot.AssetPricing()</code>,
<code>buildS()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#
# In these examples "qmax" has been set equal to 5 which is
# an unrealistically low value for the total number of assets.
# This is done so as to reduce the time for package checking on CRAN.
#
# Smooth price sensitivity function.
S &lt;- expression(exp(-kappa*x/(1+gamma*exp(-beta*t))))
attr(S,"parvec") &lt;- c(kappa=10/1.5,gamma=9,beta=1)

# Optimal pricing policy assuming customers arrive singly:
lambda1 &lt;- function(tt){
	84*(1-tt)
}
X1 &lt;- xsolve(S=S,lambda=lambda1,gprob=1,tmax=1,qmax=5,
             type="sip",verbInt=5)
# Optimal pricing policy assuming customers arrive in groups of
# size up to 5, with group size probabilities 1/3, 4/15, 1/5, 2/15,
# and 1/15 respectively.
lambda2 &lt;- function(tt){
	36*(1-tt)
}
X2 &lt;- xsolve(S=S,lambda=lambda2,gprob=(5:1)/15,tmax=1,qmax=5,
             type="sip", alpha=0.5,verbInt=5)

# Note that the intensity functions lambda1() and lambda2() are
# such that the expected total number of customers is 42 in each case.

# Discrete prices:
lambda3 &lt;- function(t){42}
S      &lt;- function(x,t){
                e &lt;- numeric(2)
                e[x==1] &lt;- exp(-2*t)
                e[x==0.6] &lt;- 1.0
                e
          }
X3 &lt;- xsolve(S=S,lambda=lambda3,gprob=1,tmax=1,qmax=5,prices=c(1,0.6),
             type="sip",verbInt=5)

# Piecewise linear price sensitivity function.
#
# Take S as in the example for buildS.
# This takes a loonnngggg time; the procedure is slow
# in the piecewise linear setting.
## Not run: 
l0 &lt;- get("lambda",envir=environment(get("alpha",envir=environment(S))[[1]]))
lambda4 &lt;- function(t){apply(l0(t),1,sum)}
X4 &lt;- xsolve(S=S,lambda=lambda4,gprob=(5:1)/15,qmax=30,type="sip",
                   alpha=0.5,verbInt=20)

## End(Not run)
</code></pre>


</div>