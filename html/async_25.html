<div class="container">

<table style="width: 100%;"><tr>
<td>stream</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create an asynchronous iterator by writing sequential code.</h2>

<h3>Description</h3>

<p>(Experimental as of async 0.3) <code>stream(...)</code> constructs a channel
object, i.e. an asynchronous iterator, which will compute and
return values according to sequential code written in <code>expr</code>. A
<code>stream</code> is a coroutine wearing a channel interface in the same
way that <code>async</code> is a coroutine wearing a promise interface, and a
gen is a coroutine sitting behind an iteror interface.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stream(
  expr,
  ...,
  split_pipes = TRUE,
  lazy = TRUE,
  compileLevel = getOption("async.compileLevel"),
  debugR = FALSE,
  debugInternal = FALSE,
  trace = getOption("async.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A coroutine expression, using some combination of
<code>yield</code>, <code>await</code>, <code>awaitNext</code>, <code>yieldFrom</code>, standard control flow
operators and other calls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Undocumented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_pipes</code></td>
<td>
<p>See description under async; defaults to
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lazy</code></td>
<td>
<p>If TRUE, start paused, and pause after <code>yield()</code> (see above.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compileLevel</code></td>
<td>
<p>Compilation level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debugR</code></td>
<td>
<p>Set TRUE to single-step debug at R level. Use <code>debugAsync()</code>
to enable or disable debugging on a stream after it has been created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debugInternal</code></td>
<td>
<p>Set TRUE to single-step debug at coroutine
implementation level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>An optional tracing function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In a stream expression, you can call <code>yield()</code> to emit a value, and
<code>await()</code> to wait for a value from a promise. To have your stream
wait for values from another stream or channel, call
<code>awaitNext()</code>; you can also use <code>awaitNext</code> when you are writing an
<code>async</code>. You can also use a simple <code>for</code> loop to consume all future
values from a stream or channel.
</p>
<p>The lower-level interface to consume values from a stream is by using
nextThen from the channel interface.
</p>
<p>Streams come in both "lazy" and "eager" varieties. If <code>lazy=TRUE</code>,
a stream starts idle, and does not process anything
until it is woken up by a call to its channel's <code>nextThen</code>. It will
pause after reaching <code>yield</code> if there are no more outstanding
requests. If <code>lazy=FALSE</code>, a stream will begin executing
immediately, not pausing on <code>yield</code>, possibly queuing up emitted
values until it needs to <code>await</code> something.
</p>
<p>(For comparison, in this package, gen are lazy in that they do
not start executing until a call to <code>nextOr</code> and pause
immediately after <code>yield</code>, while async blocks are eager,
starting at construction and running until they hit an <code>await</code>.)
</p>
<p>Like its coroutine counterparts, if <code>stream</code> is given a function
expression, like <code>stream(function(...)  ...)</code>, it will return a
"stream function" i.e. a function that constructs a stream object.
</p>


<h3>Value</h3>

<p>An object with (at least) classes "stream", "channel",
"coroutine", "iteror", "iter".
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# emit values _no more than_ once per second
count_to &lt;- stream(function(n, interval=1) {
  for (i in 1:n) {
    await(delay(interval))
    yield(i)
  }
})

accumulate &lt;- stream(function(st, sum=0) {
  for (i in st) {sum &lt;- sum + i; yield(sum)}
})

print_each &lt;- async(function(st) for (i in st) print(i))

count_to(10) |&gt; accumulate() |&gt; print_each()

</code></pre>


</div>