<div class="container">

<table style="width: 100%;"><tr>
<td>euclidean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Euclidean and related distances</h2>

<h3>Description</h3>

<p>These distance and diversity measures are mathematically similar to the
Euclidean distance between two vectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">euclidean(x, y)

rms_distance(x, y)

chord(x, y)

hellinger(x, y)

geodesic_metric(x, y)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>Numeric vectors</p>
</td>
</tr></table>
<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Euclidean distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sqrt{\sum_i (x_i - y_i) ^ 2}.</code>
</p>

<p>Relation of <code>euclidean()</code> to other definitions:
</p>

<ul>
<li>
<p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "euclidean"</code>.
</p>
</li>
<li>
<p> Equivalent to <code>vegdist()</code> with <code>method = "euclidean"</code>.
</p>
</li>
<li>
<p> Equivalent to the <code>euclidean()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li>
<li>
<p> Equivalent to the <code>structeuclidean</code> calculator in Mothur, to
<code>speciesprofile</code> if <code>x</code> and <code>y</code> are transformed to
relative abundance, and to <code>memeuclidean</code> if <code>x</code> and <code>y</code>
are transformed to presence/absence.
</p>
</li>
<li>
<p> Equivalent to <code class="reqn">D_1</code> in Legendre &amp; Legendre.
</p>
</li>
<li>
<p> Equivalent to the <em>distance between species profiles</em>,
<code class="reqn">D_{18}</code> in Legendre &amp; Legendre if <code>x</code> and <code>y</code> are
transformed to relative abundance.
</p>
</li>
</ul>
<p>The <em>root-mean-square</em> distance or <em>average</em> distance is similar
to Euclidean distance. As the name implies, it is computed as the square
root of the mean of the squared differences between elements of <code>x</code>
and <code>y</code>: </p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sqrt{\frac{1}{n} \sum_i^n (x_i - y_i) ^ 2}.</code>
</p>

<p>Relation of <code>rms_distance()</code> to other definitions:
</p>

<ul><li>
<p> Equivalent to <code class="reqn">D_2</code> in Legendre &amp; Legendre.
</p>
</li></ul>
<p>The <em>chord</em> distance is the Euclidean distance after scaling each
vector by its root sum of squares, <code class="reqn">\sqrt{\sum_i x_i^2}</code>. The chord
distance between any two vectors ranges from 0 to <code class="reqn">\sqrt{2}</code>.
Relation of <code>chord()</code> to other definitions:
</p>

<ul><li>
<p> Equivalent to <code class="reqn">D_3</code> in Legendre &amp; Legendre.
</p>
</li></ul>
<p>The <em>Hellinger</em> distance is equal to the chord distance computed after
a square-root transformation. Relation of <code>hellinger()</code> to other
definitions:
</p>

<ul>
<li>
<p> Equivalent to <code class="reqn">D_{17}</code> in Legendre &amp; Legendre.
</p>
</li>
<li>
<p> Equivalent to the <code>hellinger</code> calculator in Mothur.
</p>
</li>
</ul>
<p>The <em>geodesic metric</em> is a transformed version of the chord distance.
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \textrm{arccos} \left(1 - \frac{d_c^2(x, y)}{2} \right),</code>
</p>

<p>where <code class="reqn">d_c</code> is the chord distance. It gives the length of the arc on a
hypersphere between the vectors, if the vectors are normalized to unit
length. Relation of <code>geodesic_metric()</code> to other definitions:
</p>

<ul><li>
<p> Equivalent to <code class="reqn">D_4</code> in Legendre &amp; Legendre.
</p>
</li></ul>
<h3>Value</h3>

<p>The distance between <code>x</code> and <code>y</code>. The chord distance,
Hellinger distance, and geodesic metric are not defined if all elements
of either vector are zero. We return <code>NaN</code> in this case.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
euclidean(x, y)
# The "distance between species profiles"
euclidean(x / sum(x), y / sum(y))
rms_distance(x, y)
chord(x, y)
hellinger(x, y)
# Hellinger is chord distance after square root transform
chord(sqrt(x), sqrt(y))
geodesic_metric(x, y)

# No species in common with x
v &lt;- c(0, 0, 0, 5, 0, 5)
chord(v, x)
sqrt(2)
</code></pre>


</div>