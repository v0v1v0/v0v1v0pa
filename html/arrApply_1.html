<div class="container">

<table style="width: 100%;"><tr>
<td>arrApply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>High Performance Variant of apply()</h2>

<h3>Description</h3>

<p>High performance variant of apply() for a fixed set of functions.
Considerable speedup obtained by this implementation is a trade-off for universality, user defined
functions cannot be used with arrApply. However, about 20 most currently employed
functions are available for usage. They can be divided in three types: </p>

<ul>
<li>
<p> reducing functions (like mean(), sum() etc., giving a scalar when applied to a vector);
</p>
</li>
<li>
<p> mapping function (like normalise(), cumsum() etc., giving a vector of the same length
as the input vector)
</p>
</li>
<li>
<p> and finally, vector reducing function (like diff() which produces
result vector of a length different from the length of input vector).
</p>
</li>
</ul>
<p>Optional or mandatory additional arguments required by some functions
(e.g. norm type for norm() or normalise() functions) can be
passed as named arguments in '...'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">arrApply(arr, idim = 1L, fun = "sum", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>arr</code></td>
<td>
<p>numeric array of arbitrary dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idim</code></td>
<td>
<p>integer, dimension number along which a function must be applied</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>character string, function name to be applied</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named parameters. Optional parameters can be helpful for
the following functions:</p>

<ul>
<li>
<p> sd(), var() [norm_type: 0 normalisation using N-1 entries (default);
1 normalisation using N entries];
</p>
</li>
<li>
<p> norm() [p: integer &gt;= 1 (default=2) or one of "-inf", "inf", "fro".]
</p>
</li>
<li>
<p> normalise() [p: integer &gt;= 1, default=2]
</p>
</li>
<li>
<p> diff() [k: integer &gt;= 1 (default=1) number of recursive application of diff().
The size of idim-th dimension will be reduced by k.]
</p>
</li>
<li>
<p> trapz() [x: numerical vector of the same length as idim-th size of arr]
</p>
</li>
</ul>
<p>Mandatory parameter:</p>

<ul>
<li>
<p> multv(), divv(), addv(), subv() [v: numerical vector of the same
length as idim-th size of arr]
</p>
</li>
<li>
<p> quantile() [p: vector of probabilities in interval [0; 1]]
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following functions can be used as argument 'fun' (brackets
[] indicate additional parameters that can be passed in '...'): </p>

<ul>
<li>
<p> reducing functions: </p>

<ul>
<li>
<p> sum()
</p>
</li>
<li>
<p> prod()
</p>
</li>
<li>
<p> all()
</p>
</li>
<li>
<p> any()
</p>
</li>
<li>
<p> min()
</p>
</li>
<li>
<p> max()
</p>
</li>
<li>
<p> mean()
</p>
</li>
<li>
<p> median()
</p>
</li>
<li>
<p> sd() [norm_type]
</p>
</li>
<li>
<p> var() [norm_type]
</p>
</li>
<li>
<p> norm() [p],
</p>
</li>
<li>
<p> trapz() [x] (trapezoidal integration with respect to spacing in x,
if x is provided, otherwise unit spacing is used)
</p>
</li>
<li>
<p> range();
</p>
</li>
</ul>
</li>
<li>
<p> mapping functions:</p>

<ul>
<li>
<p> normalise() [p]
</p>
</li>
<li>
<p> cumsum()
</p>
</li>
<li>
<p> cumprod()
</p>
</li>
<li>
<p> multv() [v]
(multiply a given dimension by a vector v, term by term)
</p>
</li>
<li>
<p> divv() [v]
(divide by a vector v)
</p>
</li>
<li>
<p> addv() [v] (add a vector v)
</p>
</li>
<li>
<p> subv() [v] (subtract
a vector v);
</p>
</li>
</ul>
</li>
<li>
<p> vector reducing/augmenting function:</p>

<ul>
<li>
<p> diff() [k]
</p>
</li>
<li>
<p> conv() [v, shape] (convolve with vector v; shape="full" is equivalent
to R's <code>convolve(..., rev(v), type="open")</code>).
</p>
</li>
<li>
<p> quantile() [p] (calculate quantiles corresponding to probabilities p;
equivalent to R's <code>quantile(..., probs=p, type=8)</code>).
</p>
</li>
</ul>
</li>
</ul>
<p>RcppArmadillo is used to do the job in very fast way but it comes at price
of not allowing NA in the input numeric array.
Vectors are allowed at input. They are considered as arrays of dimension 1.
So in this case, <code>idim</code> can only be 1.
NB. Here, range() is different from R version of the homonym function.
In Armadillo, when applied to a vector, it returns a scalar max-min,
while in R, it return a 2-component vector (min, max).
</p>


<h3>Value</h3>

<p>output array of dimension cut by 1 (the idim-th dimension
will disappear for reducing functions) or of the same dimension
as the input arr for mapping and vector reducing
functions. For vector reducing functions, the idim-th dimension
will be different from idim-th dimension of arr.
The type of result (numeric or logical) depends on the function applied,
logical for all() and any(), numerical â€“ for all other functions.
</p>


<h3>Author(s)</h3>

<p>Serguei Sokol &lt;sokol at insa-toulouse.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R"> arr=matrix(1:12, 3, 4)
 v1=arrApply(arr, 2, "mean")
 v2=rowMeans(arr)
 stopifnot(all(v1==v2))
 
 arr=array(1:24, dim=2:4) # dim(arr)=c(2, 3, 4)
 mat=arrApply(arr, 2, "prod") # dim(mat)=c(2, 4), the second dimension is cut out
 stopifnot(all(mat==apply(arr, c(1, 3), prod)))

</code></pre>


</div>