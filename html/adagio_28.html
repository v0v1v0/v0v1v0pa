<div class="container">

<table style="width: 100%;"><tr>
<td>maxsub</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Maximal Sum Subarray
</h2>

<h3>Description</h3>

<p>Find a subarray with maximal positive sum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">maxsub(x, inds = TRUE)

maxsub2d(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inds</code></td>
<td>
<p>logical; shall the indices be returned?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>maxsub</code> finds a contiguous subarray whose sum is maximally positive.
This is sometimes called Kadane's algorithm.
<code>maxsub</code> will use a very fast version with a running time of
<code>O(n)</code> where <code>n</code> is the length of the input vector <code>x</code>.
</p>
<p><code>maxsub2d</code> finds a (contiguous) submatrix whose sum of elements is
maximally positive. The approach taken here is to apply the one-dimensional
routine to summed arrays between all rows of <code>A</code>. This has a run-time
of <code>O(n^3)</code>, though a run-time of <code>O(n^2 log n)</code> seems possible
see the reference below.
<code>maxsub2d</code> can solve a 100-by-100 matrix in a few seconds –
but beware of bigger ones.
</p>


<h3>Value</h3>

<p>Either just a maximal sum, or a list this sum as component <code>sum</code> plus
the start and end indices as a vector <code>inds</code>.
</p>


<h3>Note</h3>

<p>In special cases, the matrix <code>A</code> may be sparse or (as in the example
section) only have one nonzero element in each row and column. Expectation 
is that there may exists a more efficient (say <code>O(n^2)</code>) algorithm in 
these special cases.
</p>


<h3>Author(s)</h3>

<p>HwB  &lt;hwborchers@googlemail.com&gt;
</p>


<h3>References</h3>

<p>Bentley, Jon (1986). “Programming Pearls”, Column 7.
Addison-Wesley Publ. Co., Reading, MA.
</p>
<p>T. Takaoka (2002). Efficient Algorithms for the Maximum Subarray Problem by
Distance Matrix Multiplication. The Australasian Theory Symposion, CATS 2002.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##  Find a maximal sum subvector
set.seed(8237)
x &lt;- rnorm(1e6)
system.time(res &lt;- maxsub(x, inds = TRUE))
res

##  Standard example: Find a maximal sum submatrix
A &lt;- matrix(c(0,-2,-7,0, 9,2,-6,2, -4,1,-4,1, -1,8,0,2),
            nrow = 4, ncol = 4, byrow =TRUE)
maxsub2d(A)
# $sum:  15
# $inds: 2 4 1 2 , i.e., rows = 2..4, columns = 1..2

## Not run: 
##  Application to points in the unit square:
set.seed(723)
N &lt;- 50; w &lt;- rnorm(N)
x &lt;- runif(N); y &lt;- runif(N)
clr &lt;- ifelse (w &gt;= 0, "blue", "red")
plot(x, y, pch = 20, col = clr, xlim = c(0, 1), ylim = c(0, 1))

xs &lt;- unique(sort(x)); ns &lt;- length(xs)
X  &lt;- c(0, ((xs[1:(ns-1)] + xs[2:ns])/2), 1)
ys &lt;- unique(sort(y)); ms &lt;- length(ys)
Y  &lt;- c(0, ((ys[1:(ns-1)] + ys[2:ns])/2), 1)
abline(v = X, col = "gray")
abline(h = Y, col = "gray")

A &lt;- matrix(0, N, N)
xi &lt;- findInterval(x, X); yi &lt;- findInterval(y, Y)
for (i in 1:N) A[yi[i], xi[i]] &lt;- w[i]

msr &lt;- maxsub2d(A)
rect(X[msr$inds[3]], Y[msr$inds[1]], X[msr$inds[4]+1], Y[msr$inds[2]+1])

## End(Not run)
</code></pre>


</div>