<div class="container">

<table style="width: 100%;"><tr>
<td>dke.fun</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function for density estimation
</h2>

<h3>Description</h3>

<p>The (S3) generic function <code>dkde.fun</code> computes the density.
Its default method does so with the given kernel 
and bandwidth <code class="reqn">h</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dke.fun(Vec, ...)
## Default S3 method:
dke.fun(Vec, h, type_data = c("discrete", "continuous"), 
ker = c("BE", "GA", "LN", "RIG"), x = NULL, a0 = 0, a1 = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Vec</code></td>
<td>

<p>The data sample from which the estimate is to be computed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>The bandwidth or smoothing parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_data</code></td>
<td>

<p>The data sample type. Data can be continuous or discrete (categorical or count). Here, in this function , we deal with continuous data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ker</code></td>
<td>

<p>A character string giving the smoothing kernel to be used which is the associated kernel: "BE" extended beta, "GA" gamma, "LN" lognormal and "RIG" reciprocal inverse Gaussian.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>The points of the grid at which the density  is to be estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>

<p>The left bound of the support used for extended beta kernel. Default value is 0 for beta kernel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a1</code></td>
<td>

<p>The right bound of the support used for extended beta kernel. Default value is 1 for beta kernel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The associated  kernel estimator <code class="reqn">\widehat{f}_n</code> of  <code class="reqn">f</code> is defined in the above sections.
We recall that in general, the sum of the estimated values on the support is not equal to 1. In practice, we compute the global normalizing constant <code class="reqn">C_n</code> before computing the estimated density <code class="reqn">\tilde{f}_n</code>; see e.g. Libengué (2013).
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data - same as input Vec.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>The asssociated kernel used to compute the density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>The bandwidth used to compute the density estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval.points</code></td>
<td>
<p>The coordinates of the points where the 
density  is estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est.fn</code></td>
<td>
<p>The estimated density values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C_n</code></td>
<td>
<p>The global normalizing constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hist</code></td>
<td>
<p>The histogram corresponding to the observations.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>W. E. Wansouwé, S. M. Somé and C. C. Kokonendji 
</p>


<h3>References</h3>

<p>Libengué, F.G. (2013). <em>Méthode Non-Paramétrique par Noyaux Associés Mixtes et Applications</em>, Ph.D. Thesis Manuscript (in French) to Université  de Franche-Comté, Besançon, France and Université de Ouagadougou, Burkina Faso, June 2013, <b>LMB no. 14334</b>, Besançon.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## A sample data with n=100.
V&lt;-rgamma(100,1.5,2.6)
##The bandwidth can be the one obtained by cross validation.
h&lt;-0.052
## We choose Gamma kernel.

est&lt;-dke.fun(V,h,"continuous","GA")
</code></pre>


</div>