<div class="container">

<table style="width: 100%;"><tr>
<td>compute_pdf_and_cdf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Density and Cumulative Distribution Function</h2>

<h3>Description</h3>

<p>Compute the density and cumulative distribution function of the approximate posterior.
The density is approximated on a find grid using a polynomial interpolant.
The CDF can't be computed exactly (if it could, you wouldn't be using quadrature!),
so a fine grid is laid down and the CDF is approximated at each grid point
using a simpler integration rule and a polynomial interpolant. This method tends
to work well, but won't always.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute_pdf_and_cdf(obj, ...)

## Default S3 method:
compute_pdf_and_cdf(
  obj,
  transformation = default_transformation(),
  finegrid = NULL,
  interpolation = "auto",
  ...
)

## S3 method for class 'list'
compute_pdf_and_cdf(obj, transformation = default_transformation(), ...)

## S3 method for class 'aghq'
compute_pdf_and_cdf(obj, transformation = obj$transformation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>Either the output of <code>aghq::aghq()</code>, its list of marginal distributions
(element <code>marginals</code>), or an individual <code>data.frame</code> containing one of
these marginal distributions as output by <code>aghq::marginal_posterior()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Used to pass additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transformation</code></td>
<td>
<p>Optional. Calculate pdf/cdf for a transformation of the parameter
whose posterior was normalized using adaptive quadrature.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finegrid</code></td>
<td>
<p>Optional, a grid of values on which to compute the CDF. The default makes
use of the values in <code>margpost</code> but if the results are unsuitable, you may wish to
modify this manually.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolation</code></td>
<td>
<p>Which method to use for interpolating the marginal posterior, <code>'polynomial'</code> (default)
or <code>'spline'</code>? If <code>k &gt; 3</code> then the polynomial may be unstable and you should use the spline, but the spline
doesn't work <em>unless</em> <code>k &gt; 3</code> so it's not the default. See <code>interpolate_marginal_posterior()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tbl_df/tbl/data.frame with columns <code>theta</code>, <code>pdf</code> and <code>cdf</code> corresponding
to the value of the parameter and its estimated PDF and CDF at that value.
</p>


<h3>See Also</h3>

<p>Other summaries: 
<code>compute_quantiles()</code>,
<code>interpolate_marginal_posterior()</code>,
<code>marginal_posterior()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)
opt_sparsetrust_2d &lt;- optimize_theta(funlist2d,c(1.5,1.5))
margpost &lt;- marginal_posterior(opt_sparsetrust_2d,3,1) # margpost for theta1
thepdfandcdf &lt;- compute_pdf_and_cdf(margpost)
with(thepdfandcdf,{
  plot(pdf~theta,type='l')
  plot(cdf~theta,type='l')
})

</code></pre>


</div>