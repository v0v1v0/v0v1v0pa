<div class="container">

<table style="width: 100%;"><tr>
<td>confset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computing Confidence Set for the Kullback-Leibler Best Model
</h2>

<h3>Description</h3>

<p>This function computes the confidence set on the best model given
the data and model set.  <code>confset</code> implements three different
methods proposed by Burnham and Anderson (2002).
</p>


<h3>Usage</h3>

<pre><code class="language-R">confset(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
        method = "raw", level = 0.95, delta = 6, c.hat = 1)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>a character value, either as <code>raw</code>, <code>ordinal</code>, or
<code>ratio</code>, indicating the method for determining the confidence set
for the best model (see 'Description' above for details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>

<p>the level of confidence (i.e., sum of model probabilities) used to
determine the confidence set on the best model when using the <code>raw</code>
method.  Note that the argument is not used for the other methods of
determining the confidence set on the best model. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>the delta (Q)AIC(c) value associated with the cutoff point to determine
the confidence set for the best model.  Note that the argument is only
used when <code>method = ratio</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>confset</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The first and simplest (<code>method = 'raw'</code>), relies on summing the
Akaike weights (i.e., model probabilities) of the ranked models until we
reach a given cutpoint (e.g., 0.95 for a 95 percent set).
</p>
<p>The second method (<code>method = 'ordinal'</code>) suggested is based on the
classification of the models on an ordinal scale based on the delta
(Q)AIC(c).  The models are grouped in different classes based on their
weight of support as determined by the delta (Q)AIC(c) values:
substantial support (delta (Q)AIC(c) &lt;= 2), some support (2 &lt; delta
(Q)AIC(c) &lt;= 7), little support (7 &lt; delta (Q)AIC(c) &lt;= 10), no support
(delta (Q)AIC(c) &gt; 10).
</p>
<p>The third method (<code>method = 'ratio'</code>) is based on identifying the
ratios of model likelihoods (i.e., exp(-delta_(Q)AIC(c)/2) ) that exceed
a cutpoint, similar to the building of profile likelihood intervals.  An
evidence ratio of each model relative to the top-ranked model is
computed and the ratios exceeding the cutpoint determine which models
are included in the confidence set.  Note here that small cutoff points 
are suggested (e.g., 0.125, 0.050).  The cutoff point is linked to delta
(Q)AIC(c) by the following relationship:  <code class="reqn">cutoff =
  exp(-1*\delta_{(Q)AIC(c)}/2)</code>.
</p>


<h3>Value</h3>

<p><code>confset</code> returns an object of class <code>confset</code> as a list with
the following components, depending on which method is used:
</p>
<p>when <code>method = 'raw'</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the confidence level used to determine the confidence set
on the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>a reduced table with the models included in the confidence
set.</p>
</td>
</tr>
</table>
<p>when <code>method = 'ordinal'</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>substantial</code></td>
<td>
<p>a reduced table with the models included in the
confidence set for which delta (Q)AIC(c) &lt;= 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>some</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which 2 &lt; delta (Q)AIC(c) &lt;= 7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>little</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which 7 &lt; delta (Q)AIC(c) &lt;= 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>none</code></td>
<td>
<p>a reduced table with the models included in the confidence
set for which delta (Q)AIC(c) &gt; 10.</p>
</td>
</tr>
</table>
<p>when <code>method = 'ratio'</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>identifies the method of determining the confidence set on
the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>the cutoff value for the ratios used to determine the
confidence set on the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>the delta (Q)AIC(c) used to compute the cutoff value for
ratios to determine the confidence set on the best model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>a reduced table with the models included in the confidence
set.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108–115.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>c_hat</code>,
<code>evidence</code>, <code>importance</code>, <code>modavg</code>,
<code>modavgShrink</code>, <code>modavgPred</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##anuran larvae example from Mazerolle (2006)
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list()
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[4]] &lt;- glm(Num_anura ~ Type, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[5]] &lt;- glm(Num_anura ~ log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[6]] &lt;- glm(Num_anura ~ log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[7]] &lt;- glm(Num_anura ~ Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[8]] &lt;- glm(Num_anura ~ 1, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df
##note the very low overdispersion: in this case, the analysis could be
##conducted without correcting for c-hat as its value is reasonably close
##to 1  

##assign names to each model
Modnames &lt;- c("type + logperim + invertpred", "type + logperim",
              "type + invertpred", "type", "logperim + invertpred",
              "logperim", "invertpred", "intercept only") 

##compute confidence set based on 'raw' method
confset(cand.set = Cand.mod, modnames = Modnames, second.ord = TRUE,
        method = "raw")  


##example with linear mixed model
## Not run: 
require(nlme)

##set up candidate model list for Orthodont data set shown in Pinheiro
##and Bates (2000:  Mixed-effect models in S and S-PLUS. Springer Verlag:
##New York.)
Cand.models &lt;- list()
Cand.models[[1]] &lt;- lme(distance ~ age, random = ~age | Subject,
                        data = Orthodont, method = "ML")
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1 | Subject, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont,
                        random = ~ 1 | Subject, method = "ML")

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute confidence set based on 'raw' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "raw")
##round to 4 digits after decimal point
print(confset(cand.set = Cand.models, modnames = Modnames,
              second.ord = TRUE, method = "raw"), digits = 4)

confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        level = 0.9, method = "raw")

##compute confidence set based on 'ordinal' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ordinal")

##compute confidence set based on 'ratio' method
confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ratio", delta = 4)

confset(cand.set = Cand.models, modnames = Modnames, second.ord = TRUE,
        method = "ratio", delta = 8)
detach(package:nlme)

## End(Not run)
</code></pre>


</div>