<div class="container">

<table style="width: 100%;"><tr>
<td>plotSPC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create Soil Profile Sketches</h2>

<h3>Description</h3>

<p>Generate a diagram of soil profile sketches from a <code>SoilProfileCollection</code> object. The <a href="http://ncss-tech.github.io/aqp/articles/Introduction-to-SoilProfileCollection-Objects.html">Introduction to SoilProfileCollection Objects Vignette</a> contains many examples and discussion of the large number of arguments to this function. The <a href="https://ncss-tech.github.io/AQP/aqp/sketches.html">Soil Profile Sketches</a> tutorial has longer-form discussion and examples pertaining to suites of related arguments.
</p>
<p>Options can be used to conveniently specify sets of arguments that will be used in several calls to <code>plotSPC()</code> within a single R session. For example, arguments can be specified in a named list (<code>.a</code>) and set using: <code>options(.aqp.plotSPC.args = .a)</code>. Reset these options via <code>options(.aqp.plotSPC.args = NULL)</code>. Arguments explicitly passed to <code>plotSPC()</code> will override arguments set via <code>options()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotSPC(
  x,
  color = "soil_color",
  width = ifelse(length(x) &lt; 2, 0.15, 0.25),
  name = hzdesgnname(x),
  name.style = "right-center",
  label = idname(x),
  raggedBottom = NULL,
  hz.depths = FALSE,
  hz.depths.offset = ifelse(fixLabelCollisions, 0.03, 0),
  hz.depths.lines = fixLabelCollisions,
  depth.axis = list(style = "traditional", cex = cex.names * 1.15),
  alt.label = NULL,
  alt.label.col = "black",
  cex.names = 0.5,
  cex.id = cex.names + (0.2 * cex.names),
  font.id = 2,
  srt.id = 0,
  print.id = TRUE,
  id.style = "auto",
  plot.order = 1:length(x),
  relative.pos = 1:length(x),
  add = FALSE,
  scaling.factor = 1,
  y.offset = rep(0, times = length(x)),
  x.idx.offset = 0,
  n = length(x),
  max.depth = ifelse(is.infinite(max(x)), 200, max(x)),
  n.depth.ticks = 10,
  shrink = FALSE,
  shrink.cutoff = 3,
  shrink.thin = NULL,
  abbr = FALSE,
  abbr.cutoff = 5,
  divide.hz = TRUE,
  hz.distinctness.offset = NULL,
  hz.topography.offset = NULL,
  hz.boundary.lty = NULL,
  density = NULL,
  show.legend = TRUE,
  col.label = color,
  col.palette = c("#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FEE08B",
    "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"),
  col.palette.bias = 1,
  col.legend.cex = 1,
  n.legend = 8,
  lwd = 1,
  lty = 1,
  default.color = grey(0.95),
  fixLabelCollisions = hz.depths,
  fixOverlapArgs = list(method = "E", q = 1),
  cex.depth.axis = cex.names,
  axis.line.offset = -2,
  plot.depth.axis = TRUE,
  ...
)

## S4 method for signature 'SoilProfileCollection,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>quoted column name containing R-compatible color descriptions, or numeric / categorical data to be displayed thematically; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>scaling of profile widths (typically 0.1 - 0.4)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>quoted column name of the (horizon-level) attribute containing horizon designations or labels, if missing <code>hzdesgnname(x)</code> is used. Suppress horizon name printing by setting <code>name = NA</code> or <code>name = ''</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name.style</code></td>
<td>
<p>one of several possible horizon designations labeling styles: <code>c('right-center', 'left-center', 'left-top', 'center-center', 'center-top')</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>quoted column name of the (site-level) attribute used to identify profile sketches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raggedBottom</code></td>
<td>
<p>either quoted column name of the (site-level) attribute (logical) used to mark profiles with a truncated lower boundary, or <code>FALSE</code> suppress ragged bottom depths when <code>max.depth &lt; max(x)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.depths</code></td>
<td>
<p>logical, annotate horizon top depths to the right of each sketch (<code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.depths.offset</code></td>
<td>
<p>numeric, user coordinates for left-right adjustment for horizon depth annotation; reasonable values are usually within 0.01-0.05 (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.depths.lines</code></td>
<td>
<p>logical, draw segments between horizon depth labels and actual horizon depth; this is useful when including horizon boundary distinctness and/or <code>fixLabelCollisions = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depth.axis</code></td>
<td>
<p>logical or list. Use a logical to suppress (<code>FALSE</code>) or add depth axis using defaults (<code>TRUE</code>). Use a list to specify one or more of:
</p>

<ul>
<li> <p><code>style</code>: character, one of 'traditional', 'compact', or 'tape'
</p>
</li>
<li> <p><code>line</code>: numeric, negative values move axis to the left (does not apply to <code>style = 'tape'</code>)
</p>
</li>
<li> <p><code>cex</code>: numeric, scaling applied to entire depth axis
</p>
</li>
<li> <p><code>interval</code>: numeric, axis interval
See examples.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt.label</code></td>
<td>
<p>quoted column name of the (site-level) attribute used for secondary annotation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt.label.col</code></td>
<td>
<p>color used for secondary annotation text</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.names</code></td>
<td>
<p>baseline character scaling applied to all text labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.id</code></td>
<td>
<p>character scaling applied to <code>label</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font.id</code></td>
<td>
<p>font style applied to <code>label</code>, default is 2 (bold)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srt.id</code></td>
<td>
<p>rotation applied to <code>label</code>, only when <code>id.style = 'top'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.id</code></td>
<td>
<p>logical, print <code>label</code> above/beside each profile? (<code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.style</code></td>
<td>
<p><code>label</code> printing style: 'auto' (default) = simple heuristic used to select from: 'top' = centered above each profile, 'side' = 'along the top-left edge of profiles'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.order</code></td>
<td>
<p>integer vector describing the order in which individual soil profiles should be plotted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative.pos</code></td>
<td>
<p>vector of relative positions along the x-axis, within {1, n}, ignores <code>plot.order</code> see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>logical, add to an existing figure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling.factor</code></td>
<td>
<p>vertical scaling of profile depths, useful for adding profiles to an existing figure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.offset</code></td>
<td>
<p>numeric vector of vertical offset for top of profiles in depth units of <code>x</code>, can either be a single numeric value or vector of length = <code>length(x)</code>. A vector of y-offsets will be automatically re-ordered according to <code>plot.order</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.idx.offset</code></td>
<td>
<p>integer specifying horizontal offset from 0 (left-hand edge)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer describing amount of space along x-axis to allocate, defaults to <code>length(x)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.depth</code></td>
<td>
<p>numeric. The lower depth for all sketches, deeper profiles are truncated at this depth. Use larger values to arbitrarily extend the vertical dimension, convenient for leaving extract space for annotation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.depth.ticks</code></td>
<td>
<p>suggested number of ticks in depth scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrink</code></td>
<td>
<p>logical, reduce character scaling for 'long' horizon by 80%</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrink.cutoff</code></td>
<td>
<p>character length defining 'long' horizon names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrink.thin</code></td>
<td>
<p>integer, horizon thickness threshold for shrinking horizon names by 80%, only activated when <code>shrink = TRUE</code> (<code>NULL</code> = no shrinkage)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abbr</code></td>
<td>
<p>logical, abbreviate <code>label</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abbr.cutoff</code></td>
<td>
<p>suggested minimum length for abbreviated <code>label</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>divide.hz</code></td>
<td>
<p>logical, divide horizons with line segment? (<code>TRUE</code>), see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.distinctness.offset</code></td>
<td>
<p><code>NULL</code>, or quoted column name (horizon-level attribute) containing vertical offsets used to depict horizon boundary distinctness (same units as profiles), see details and <code>hzDistinctnessCodeToOffset()</code>; consider setting <code>hz.depths.lines = TRUE</code> when used in conjunction with <code>hz.depths = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.topography.offset</code></td>
<td>
<p><code>NULL</code>, or quoted column name (horizon-level attribute) containing offsets used to depict horizon boundary topography (same units as profiles), see details and <code>hzTopographyCodeToOffset()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hz.boundary.lty</code></td>
<td>
<p>quoted column name (horizon-level attribute) containing line style (integers) used to encode horizon topography</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>fill density used for horizon color shading, either a single integer or a quoted column name (horizon-level attribute) containing integer values (default is <code>NULL</code>, no shading)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical, show legend? (default is <code>TRUE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.label</code></td>
<td>
<p>thematic legend title</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.palette</code></td>
<td>
<p>color palette used for thematic sketches (default is <code>rev(brewer.pal(10, 'Spectral'))</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.palette.bias</code></td>
<td>
<p>color ramp bias (skew), see <code>colorRamp()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.legend.cex</code></td>
<td>
<p>scaling of thematic legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.legend</code></td>
<td>
<p>approximate number of classes used in numeric legend, max number of items per row in categorical legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>line width multiplier used for sketches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>line style used for sketches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.color</code></td>
<td>
<p>default horizon fill color used when <code>color</code> attribute is <code>NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixLabelCollisions</code></td>
<td>
<p>use <code>fixOverlap()</code> to attempt fixing hz depth labeling collisions, will slow plotting of large collections; enabling also sets <code>hz.depths.lines = TRUE</code>. Additional arguments to <code>fixOverlap()</code> can be passed via <code>fixOverlapArgs</code>. Overlap collisions cannot be fixed within profiles containing degenerate or missing horizon depths (e.g. top == bottom).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixOverlapArgs</code></td>
<td>
<p>a named list of arguments to <code>fixOverlap()</code>. Overlap adjustments are attempted using electrostatic simulation with arguments: <code>list(method = 'E', q = 1)</code>. Alternatively, select adjustment by simulated annealing via <code>list(method = 'S')</code>. See <code>electroStatics_1D()</code> and <code>SANN_1D()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.depth.axis</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) character scaling applied to depth scale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis.line.offset</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) horizontal offset applied to depth axis (default is -2, larger numbers move the axis to the right)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.depth.axis</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) logical, plot depth axis?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed into lower level plotting functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>(not used)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Depth limits (<code>max.depth</code>) and number of depth ticks (<code>n.depth.ticks</code>) are <em>suggestions</em> to the <code>pretty()</code> function. You may have to tinker with both parameters to get what you want.
</p>
<p>The 'side' <code>id.style</code> is useful when plotting a large collection of profiles, and/or, when profile IDs are long.
</p>
<p>If the column containing horizon designations is not specified (the <code>name</code> argument), a column (presumed to contain horizon designation labels) is guessed based on regular expression matching of the pattern 'name'â€“this usually works, but it is best to manual specify the name of the column containing horizon designations.
</p>
<p>The <code>color</code> argument can either name a column containing R-compatible colors, possibly created via <code>munsell2rgb()</code>, or column containing either numeric or categorical (either factor or character) values. In the second case, values are converted into colors and displayed along with a simple legend above the plot. Note that this functionality makes several assumptions about plot geometry and is most useful in an interactive setting.
</p>
<p>Adjustments to the legend can be specified via <code>col.label</code> (legend title), <code>col.palette</code> (palette of colors, automatically expanded), <code>col.legend.cex</code> (legend scaling), and <code>n.legend</code> (approximate number of classes for numeric variables, or, maximum number of legend items per row for categorical variables). Currently, <code>plotSPC</code> will only generate two rows of legend items. Consider reducing the number of classes if two rows isn't enough room.
</p>
<p>Profile sketches can be added according to relative positions along the x-axis (vs. integer sequence) via <code>relative.pos</code> argument. This should be a vector of positions within {1,n} that are used for horizontal placement. Default values are <code>1:length(x)</code>. Care must be taken when both <code>plot.order</code> and <code>relative.pos</code> are used simultaneously: <code>relative.pos</code> specifies horizontal placement after sorting. <code>addDiagnosticBracket()</code> and <code>addVolumeFraction()</code> use the <code>relative.pos</code> values for subsequent annotation.
</p>
<p>Relative positions that are too close will result in overplotting of sketches. Adjustments to relative positions such that overlap is minimized can be performed with <code>fixOverlap(pos)</code>, where <code>pos</code> is the original vector of relative positions.
</p>
<p>The <code>x.idx.offset</code> argument can be used to shift a collection of pedons from left to right in the figure. This can be useful when plotting several different <code>SoilProfileCollection</code> objects within the same figure. Space must be pre-allocated in the first plotting call, with an offset specified in the second call. See examples below.
</p>
<p>Horizon depths (e.g. cm) are converted to figure y-coordinates via: y = (depth * scaling.factor) + y.offset.
</p>


<h3>Note</h3>

<p>A new plot of soil profiles is generated, or optionally added to an existing plot.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Beaudette, D.E., Roudier P., and A.T. O'Geen. 2013. Algorithms for Quantitative Pedology: A Toolkit for
Soil Scientists. Computers &amp; Geosciences. 52:258 - 268.
</p>


<h3>See Also</h3>

<p><code>fixOverlap()</code>, <code>explainPlotSPC()</code>, SoilProfileCollection, <code>pretty()</code>, <code>hzDistinctnessCodeToOffset()</code>, <code>addBracket()</code>, <code>profileGroupLabels()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))


# example data
data(sp1)
# usually best to adjust margins
par(mar = c(0,0,3,0))

# add color vector
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom

# init horizon designation 
hzdesgnname(sp1) &lt;- 'name'

# plot profiles
plotSPC(sp1, id.style = 'side')

# title, note line argument:
title('Sample Data 1', line = 1, cex.main = 0.75)

# plot profiles without horizon-line divisions
plotSPC(sp1, divide.hz = FALSE)

# diagonal lines encode horizon boundary distinctness
sp1$hzD &lt;- hzDistinctnessCodeToOffset(sp1$bound_distinct)
plotSPC(sp1, hz.distinctness.offset = 'hzD', name.style = 'center-center')

# plot horizon color according to some property
data(sp4)
depths(sp4) &lt;- id ~ top + bottom
hzdesgnname(sp4) &lt;- 'name'
plotSPC(sp4, color = 'clay')

# another example
data(sp2)
depths(sp2) &lt;- id ~ top + bottom
hzdesgnname(sp2) &lt;- 'name'
site(sp2) &lt;- ~ surface

# some of these profiles are very deep, truncate plot at 400cm
# label / re-order with site-level attribute: `surface`
plotSPC(sp2, label = 'surface', plot.order = order(sp2$surface), 
max.depth = 400)

# example using a categorical attribute
plotSPC(sp2, color = "plasticity", 
max.depth = 400)

# plot two SPC objects in the same figure
par(mar = c(1,1,1,1))

# plot the first SPC object and
# allocate space for the second SPC object
plotSPC(sp1, n = length(sp1) + length(sp2))

# plot the second SPC, starting from the first empty space
plotSPC(sp2, x.idx.offset = length(sp1), add = TRUE)


##
## demonstrate horizon designation shrinkage
##

data("jacobs2000")

# shrink "long" horizon names
plotSPC(
  jacobs2000, 
  name = 'name',
  name.style = 'center-center', 
  shrink = TRUE, 
  cex.names = 0.8
)

# shrink horizon names in "thin" horizons
plotSPC(
  jacobs2000, 
  name = 'name',
  name.style = 'center-center', 
  shrink = TRUE, 
  shrink.thin = 15,
  cex.names = 0.8,
)


##
## demonstrate adaptive legend
##

data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# make some fake categorical data
horizons(sp3)$fake.data &lt;- sample(letters[1:15], size = nrow(sp3), replace=TRUE)

# better margins
par(mar=c(0,0,3,1))

# note that there are enough colors for 15 classes (vs. previous limit of 10)
# note that the legend is split into 2 rows when length(classes) &gt; n.legend argument
plotSPC(sp3, color='fake.data', name='fake.data', cex.names=0.8)

# make enough room in a single legend row
plotSPC(sp3, color='fake.data', name='fake.data', cex.names=0.8, n.legend=15)


##
## demonstrate y.offset argument
## must be of length 1 or length(x)
##

# example data and local copy
data("jacobs2000")
x &lt;- jacobs2000
hzdesgnname(x) &lt;- 'name'

# y-axis offsets, simulating a elevation along a hillslope sequence
# same units as horizon depths in `x`
# same order as profiles in `x`
y.offset &lt;- c(-5, -10, 22, 65, 35, 15, 12)

par(mar = c(0, 0, 2, 2))

# y-offset at 0
plotSPC(x, color = 'matrix_color', cex.names = 0.66)

# constant adjustment to y-offset
plotSPC(x, color = 'matrix_color', cex.names = 0.66, y.offset = 50)

# attempt using invalid y.offset
# warning issued and default value of '0' used
# plotSPC(x, color = 'matrix_color', cex.names = 0.66, y.offset = 1:2)

# variable y-offset
# fix overlapping horizon depth labels
par(mar = c(0, 0, 1, 0))
plotSPC(
  x, 
  y.offset = y.offset, 
  color = 'matrix_color', 
  cex.names = 0.75, 
  shrink = TRUE,
  hz.depths = TRUE, 
  hz.depths.offset = 0.05,
  fixLabelCollisions = TRUE,
  name.style = 'center-center'
)



# random y-axis offsets
yoff &lt;- runif(n = length(x), min = 1, max = 100)

# random gradient of x-positions
xoff &lt;- runif(n = length(x), min = 1, max = length(x))

# note profiles overlap
plotSPC(x, 
        relative.pos = xoff, 
        y.offset = yoff, 
        color = 'matrix_color', 
        cex.names = 0.66, 
        hz.depths = TRUE, 
        name.style = 'center-center'
)


# align / adjust relative x positions
set.seed(111)
pos &lt;- alignTransect(xoff, x.min = 1, x.max = length(x), thresh = 0.65)

# y-offset is automatically re-ordered according to
# plot.order

par(mar = c(0.5, 0.5, 0.5, 0.5))
plotSPC(x, 
        plot.order = pos$order, 
        relative.pos = pos$relative.pos, 
        y.offset = yoff, 
        color = 'matrix_color', 
        cex.names = 0.66, 
        hz.depths = TRUE, 
        name.style = 'center-center'
)

box()

</code></pre>


</div>