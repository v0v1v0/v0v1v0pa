<div class="container">

<table style="width: 100%;"><tr>
<td>index.colours</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quantisation of colours and indexing a grDevices raster image</h2>

<h3>Description</h3>

<p>Converts an image represented by a grDevices <code>raster</code> object into a
matrix containing numeric indices of a quantised colour palette.
</p>


<h3>Usage</h3>

<pre><code class="language-R">index.colours(
  x,
  length.out = 8,
  palette = NULL,
  background = "#FFFFFF",
  dither = c("none", "floyd-steinberg", "JJN", "stucki", "atkinson", "burkse", "sierra",
    "two-row-sierra", "sierra-lite"),
  colour.depth = c("12 bit", "24 bit"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A raster object (<code>grDevices::as.raster()</code>), or a <code>matrix</code>
containing <code>character</code> strings representing colours. <code>x</code> can also
be a <code>list</code> of such matrices or rasters. All elements of this list should
have identical dimensions. An overall palette will be generated for elements in the
list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.out</code></td>
<td>
<p>A <code>numeric</code> value indicating the number of desired
colours in the indexed palette.
</p>
<p>It can also be a <code>character</code> string indicating which special
Amiga display mode should be used when indexing colours.
‘<code>HAM6</code>’ and ‘<code>HAM8</code>’ are supported.
See <code>rasterToBitmap()</code> for more details on these
special modes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p>A vector of no more than <code>length.out</code> colours, to be used
for the bitmap image. When missing or set to <code>NULL</code>, a palette will be
generated based on the provided colours in raster <code>x</code>. In that case,
<code>stats::kmeans()</code> is used on the hue, saturation, brightness and
alpha values of the colours in <code>x</code> for clustering the colours. The cluster
centres will be used as palette colours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>background</code></td>
<td>
<p>On the Amiga, indexed images could not be semi-transparent.
Only a single colour could be designated as being fully transparent. The
“background'' argument should contain a background colour with which
semi-transparent colours should be mixed, before colour quantisation. It is
white by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dither</code></td>
<td>
<p>Dither the output image using the algorithm specified here.
See the usage section for possible options. By default no dithering ("<code>none</code>")
is applied. See <code>dither()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour.depth</code></td>
<td>
<p>A <code>character</code> string indicating the colour depth to be used.
Can be either "<code style="white-space: pre;">⁠12 bit⁠</code>" (default, standard on an Amiga with original chipset),
or "<code style="white-space: pre;">⁠24 bit⁠</code>".
</p>
<p>This argument is overruled when <code>length.out</code> is set to “<code>HAM6</code>”
or “<code>HAM8</code>”. In that case the colour depth linked to that special mode
is used (12 bit for HAM6, 24 bit for HAM8).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments that are passed onto <code>stats::kmeans()</code> (see
<code>palette</code> argument).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Determines the optimal limited palette by clustering colours in an image
with <code>stats::kmeans()</code>. The result of the optimisation routine
will depend on the randomly chosen cluster centres by this algorithm. This
means that the result may slightly differ for each call to this function. If
you want reproducible results, you may want to reset the random seed
(<code>set.seed()</code>) before each call to this function.
</p>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with the same dimensions as <code>x</code> containing
<code>numeric</code> index values. The corresponding palette is returned as attribute,
as well as the index value for the fully transparent colour in the palette.
When <code>x</code> is a <code>list</code> a <code>list</code> of matrices is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other colour.quantisation.operations: 
<code>dither()</code>
</p>
<p>Other raster.operations: 
<code>AmigaBitmapFont</code>,
<code>as.raster.AmigaBasicShape()</code>,
<code>bitmapToRaster()</code>,
<code>dither()</code>,
<code>rasterToAmigaBasicShape()</code>,
<code>rasterToAmigaBitmapFont()</code>,
<code>rasterToBitmap()</code>,
<code>rasterToHWSprite()</code>,
<code>rasterToIFF()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## first: Let's make a raster out of the 'volcano' data, which we can use in the example:
volcano.raster &lt;- as.raster(t(matrix(terrain.colors(1 + diff(range(volcano)))[volcano -
  min(volcano) + 1], nrow(volcano))))

## This will create an image of the original raster using an indexed palette:
volcano.index &lt;- index.colours(volcano.raster)

## The index values can be converted back into colours, using the palette:
volcano.index &lt;- as.raster(apply(volcano.index, 2,
                                 function(x) attributes(volcano.index)$palette[x]))

## Create an indexed image using dithering
volcano.dith &lt;- index.colours(volcano.raster, dither = "floyd-steinberg")
volcano.dith &lt;- as.raster(apply(volcano.dith, 2,
                                function(x) attributes(volcano.dith)$palette[x]))

## plot the images side by side for comparison
par(mfcol = c(1, 3))
plot(volcano.raster, interpolate = F)
plot(volcano.index, interpolate = F)
plot(volcano.dith, interpolate = F)

## End(Not run)
</code></pre>


</div>