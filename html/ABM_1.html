<div class="container">

<table style="width: 100%;"><tr>
<td>ABM-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Agent Based Model Simulation Framework</h2>

<h3>Description</h3>

<p>This package provides a framework to simulate agent based models that are
based on states and events.
</p>


<h3>Details</h3>



<h4>Agent</h4>

<p>The concept of this framework is agent, which is an object of the Agent
class. An agent maintains its own state, which is a named R list storing any
R values in it. (see State ). The main task of an agent is to manage events
(see Event), and handle them in chronological order.
</p>



<h4>Population</h4>

<p>An object of the Population class manages agents and their contacts. The
contacts of agents are managed by Contact objects. The main functionality for
a contact object is to provide contacts of a given individuals at a given
time. For example, <code>newRandomMixing()</code> returns such an object that finds a
random agent in the population as a contact. the effect of contacts on the
states of agents are defined using a state transition rule. Please see
<code>addTransition</code> method of Simulation for more details.
</p>



<h4>Simulation</h4>

<p>The Simulation class inherits the Population class. So a simulation
manages agents and their contacts. Thus, the class also inherits the Agent
class. So a simulation can have its own state, and events attached
(scheduled) to it. In addition, it also manages all the transitions, using
its <code>addTransition</code> method. At last, it maintains loggers, which record
(or count) the state changes, and report their values at specified times.
</p>
<p>During a simulation the earliest event in the simulation is picked out,
unscheduled (detached), and handled, which potentially causes the state
change of the agent (or another agent in the simulation). The state change is
then logged by loggers (see <code>newCounter()</code> and
<code>newStateLogger()</code> for more details) that recognize the state
change.
</p>



<h4>Usage</h4>

<p>To use this framework, we start by creating a simulation
object, populate the simulation with agents (either using the argument in
the constructor, or use its <code>addAgent</code> method), and
initialize the agents with their initial states using its <code>setState</code> method.
</p>
<p>We then attach (<code>schedule()</code>) events to agents (possibly to the populations or
the simulation object too), so that these events change the agents' state.
For models which agents' states are defined by discrete states, such as the
SIR epidemic model, the events are managed by the framework through state
transitions, using rules defined by the <code>addTransition</code> method of
the Simulation class.
</p>
<p>At last, we add loggers to the simulation using
the Simulation class' <code>addLogger</code> method' and either <code>newCounter()</code> or
<code>newStateLogger()</code>. At last, run the simulation using
its <code>run</code> method, which returns the observations of the loggers
at the requested time points as a data.frame object.
</p>
<p>For more information and examples, please see the <a href="https://github.com/junlingm/ABM/wiki/">Wiki</a> pages on Github.
</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Junling Ma <a href="mailto:junlingm@uvic.ca">junlingm@uvic.ca</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/junlingm/ABM">https://github.com/junlingm/ABM</a>
</p>
</li>
<li>
<p> Report bugs at <a href="https://github.com/junlingm/ABM/issues">https://github.com/junlingm/ABM/issues</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># simulate an SIR model using the Gillespie method
# the population size
N = 10000
# the initial number of infectious agents
I0 = 10
# the transmission rate
beta = 0.4
# the recovery rate
gamma = 0.2
# an waiting time egenerator that handles 0 rate properly
wait.exp = function(rate) {
  if (rate == 0) Inf else rexp(1, rate)
}
# this is a function that rescheduled all the events. When the
# state changed, the old events are invalid because they are
# calculated from the old state. This is possible because the
# waiting times are exponentially distributed
reschedule = function(time, agent, state) {
  clearEvents(agent)
  t.inf = time + wait.exp(beta*state$I*state$S/N)
  schedule(agent, newEvent(t.inf, handler.infect))
  t.rec = time + wait.exp(gamma*state$I)
  schedule(agent, newEvent(t.rec, handler.recover))
}
# The infection event handler
# an event handler take 3 arguments
#   time is the current simulation time
#   sim is an external pointer to the Simulation object.
#   agent is the agent that the event is scheduled to
handler.infect = function(time, sim, agent) {
  x = getState(agent)
  x$S = x$S - 1
  x$I = x$I + 1
  setState(agent, x)
  reschedule(time, agent, x)
}
# The recovery event handler
handler.recover = function(time, sim, agent) {
  x = getState(agent)
  x$R = x$R + 1
  x$I = x$I - 1
  setState(agent, x)
  reschedule(time, agent, x)
}
# create a new simulation with no agent in it.
# note that the simulation object itself is an agent
sim = Simulation$new()
# the initial state
x = list(S=N-I0, I=I0, R=0)
sim$state = x
# schedule an infection event and a recovery event
reschedule(0, sim$get, sim$state)
# add state loggers that saves the S, I, and R states
sim$addLogger(newStateLogger("S", NULL, "S"))
sim$addLogger(newStateLogger("I", NULL, "I"))
sim$addLogger(newStateLogger("R", sim$get, "R"))
# now the simulation is setup, and is ready to run
result = sim$run(0:100)
# the result is a data.frame object
print(result)

# simulate an agent based SEIR model
# specify an exponential waiting time for recovery
gamma = newExpWaitingTime(0.2)
# specify a tansmission rate
beta = 0.4
# specify a exponentially distributed latent period
sigma =newExpWaitingTime(0.5)
# the population size
N = 10000
# create a simulation with N agents, initialize the first 5 with a state "I" 
# and the remaining with "S".
sim = Simulation$new(N, function(i) if (i &lt;= 5) "I" else "S")
# add event loggers that counts the individuals in each state.
# the first variable is the name of the counter, the second is
# the state for counting. States should be lists. However, for
# simplicity, if the state has a single value, then we 
# can specify the list as the value, e.g., "S", and the state
# is equivalent to list("S")
sim$addLogger(newCounter("S", "S"))
sim$addLogger(newCounter("E", "E"))
sim$addLogger(newCounter("I", "I"))
sim$addLogger(newCounter("R", "R"))
# create a random mixing contact pattern and attach it to sim
m = newRandomMixing()
sim$addContact(m)
# the transition for leaving latent state anbd becoming infectious
sim$addTransition("E"-&gt;"I", sigma)
# the transition for recovery
sim$addTransition("I"-&gt;"R", gamma)
# the transition for tranmission, which is caused by the contact m
# also note that the waiting time can be a number, which is the same
# as newExpWaitingTime(beta)
sim$addTransition("I" + "S" -&gt; "I" + "E" ~ m, beta)
# run the simulation, and get a data.frame object
result = sim$run(0:100)
print(result)

</code></pre>


</div>