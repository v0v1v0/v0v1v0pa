<div class="container">

<table style="width: 100%;"><tr>
<td>AhoCorasickSearch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast searching for one or more keywords in one or more texts</h2>

<h3>Description</h3>

<p>Builds an Aho-Corasick trie from one or more keywords and uses it to
search one or more texts. For a large number of keywords, Aho-Corasick is much faster
than a naive approach (such as <code>lapply(keywords, gregexpr, text)</code>).
</p>
<p>Use <code>AhoCorasickSearchList</code> instead of <code>AhoCorasickSearch</code> when you want to keep the matches
of each input text separate. If the input texts have names, the resulting list of matches will include those
names and non-matched texts will be excluded from the results. If the input texts do
not have names, then the resulting list of matches will be in the same order as the
input texts, and non-matched texts will be kept to preserve that order. Thus, it is more
efficient to use named input texts (so non-matched texts can be dropped).
</p>
<p>The default alphabet allows all 128 ASCII characters in the keywords and the texts.
Characters outside this range will cause an error. A more efficient trie is possible
if the alphabet size can be reduced. For example, DNA sequences use at most 19 distinct
characters and usually only 4; protein sequences use at most 26 distinct characters and
usually only 20. Set the <code>alphabet</code> parameter if a reduced alphabet is appropriate.
</p>
<p>UTF-8 (Unicode) matching is not currently supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">AhoCorasickSearch(
  keywords,
  text,
  alphabet = "ascii",
  groupByKeyword = FALSE,
  iterationFeedback = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>keywords</code></td>
<td>
<p>Character vector of one or more keywords</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text</code></td>
<td>
<p>Character vector of one or more texts to search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphabet</code></td>
<td>
<p>Alphabet to use; one of <code>ascii</code>, <code>aminoacid</code>, or <code>nucleicacid</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupByKeyword</code></td>
<td>
<p>If true, matches are grouped by keyword (instead of by text)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterationFeedback</code></td>
<td>
<p>When set to a positive integer <code>i</code>, console output will indicate when searching every <code>i</code>th text</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List of matches, grouped by either text or by keyword
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://www.codeproject.com/Articles/12383/Aho-Corasick-string-matching-in-C">Aho-Corasick string matching in C#</a> for the article this package is based on
</p>
</li>
<li> <p><code>matchPDict</code> for a more memory efficient, but DNA-only, implementation of the algorithm
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">listEquals = function(a, b) { is.null(unlist(a)) &amp;&amp; is.null(unlist(b)) ||
                              !is.null(a) &amp;&amp; !is.null(b) &amp;&amp; all(unlist(a) == unlist(b)) }

# 1. Search for multiple keywords in a single text
keywords = c("Abra", "cadabra", "is", "the", "Magic", "Word")
oneSearch = AhoCorasickSearch(keywords, "Is Abracadabra the Magic Word?")
stopifnot(listEquals(oneSearch[[1]][[1]], list(keyword="Abra", offset=4)))
stopifnot(listEquals(oneSearch[[1]][[2]], list(keyword="cadabra", offset=8)))
stopifnot(listEquals(oneSearch[[1]][[3]], list(keyword="the", offset=16)))
stopifnot(listEquals(oneSearch[[1]][[4]], list(keyword="Magic", offset=20)))
stopifnot(listEquals(oneSearch[[1]][[5]], list(keyword="Word", offset=26)))

# 2. Search multiple named texts in a named list with keyword grouping and aminoacid alphabet
# * all matches to a keyword are accessed by name
# * non-matched keywords are dropped
proteins = c(protein1="PEPTIDEPEPTIDEDADADARARARARAKEKEKEKEPEPTIDE",
             protein2="DERPADERPAPEWPEWPEEPEERAWRAWWARRAGTAGPEPTIDEKESEQUENCE")
peptides = c("PEPTIDE", "DERPA", "SEQUENCE", "KEKE", "PEPPIE")

peptideSearch = AhoCorasickSearch(peptides, proteins, alphabet="aminoacid", groupByKeyword=TRUE)
stopifnot(listEquals(peptideSearch$PEPTIDE, list(list(keyword="protein1", offset=1),
                                                 list(keyword="protein1", offset=8),
                                                 list(keyword="protein1", offset=37),
                                                 list(keyword="protein2", offset=38))))
stopifnot(listEquals(peptideSearch$DERPA, list(list(keyword="protein2", offset=1),
                                               list(keyword="protein2", offset=6))))
stopifnot(listEquals(peptideSearch$SEQUENCE, list(list(keyword="protein2", offset=47))))
stopifnot(listEquals(peptideSearch$KEKE, list(list(keyword="protein1", offset=29),
                                              list(keyword="protein1", offset=31),
                                              list(keyword="protein1", offset=33))))
stopifnot(listEquals(peptideSearch$PEPPIE, NULL))

# 3. Grouping by keyword without text names: offsets are given without reference to the text
names(proteins) = NULL
peptideSearch = AhoCorasickSearch(peptides, proteins, groupByKeyword=TRUE)
stopifnot(listEquals(peptideSearch$PEPTIDE, list(1, 8, 37, 38)))
stopifnot(listEquals(peptideSearch$DERPA, list(1, 6)))
stopifnot(listEquals(peptideSearch$SEQUENCE, list(47)))
stopifnot(listEquals(peptideSearch$KEKE, list(29, 31, 33)))
</code></pre>


</div>