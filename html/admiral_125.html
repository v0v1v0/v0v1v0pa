<div class="container">

<table style="width: 100%;"><tr>
<td>event_joined</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a <code>event_joined</code> Object</h2>

<h3>Description</h3>

<p>The <code>event_joined</code> object is used to define events as input for the
<code>derive_extreme_event()</code> and <code>derive_vars_extreme_event()</code> functions.
This object should be used if the event does not depend on a single
observation of the source dataset but on multiple observations. For example,
if the event needs to be confirmed by a second observation of the source
dataset.
</p>
<p>The events are selected by calling <code>filter_joined()</code>. See its documentation
for more details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">event_joined(
  dataset_name = NULL,
  condition,
  order = NULL,
  join_vars,
  join_type,
  first_cond = NULL,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  set_values_to = NULL,
  keep_source_vars = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataset_name</code></td>
<td>
<p>Dataset name of the dataset to be used as input for the
event. The name refers to the dataset specified for <code>source_datasets</code> in
<code>derive_extreme_event()</code>. If the argument is not specified, the input
dataset (<code>dataset</code>) of <code>derive_extreme_event()</code> is used.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>An unquoted condition for selecting the observations, which
will contribute to the extreme event.
</p>
<p>The condition is applied to the joined dataset for selecting the confirmed
observations. The condition can include summary functions like <code>all()</code> or
<code>any()</code>. The joined dataset is grouped by the original observations. I.e.,
the summary function are applied to all observations up to the confirmation
observation. For example in the oncology setting when using this function
for confirmed best overall response,  <code>condition = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code> selects observations with response "CR" and for all
observations up to the confirmation observation the response is "CR" or
"NE" and there is at most one "NE".
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>If specified, the specified variables or expressions are used to
select the first observation.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join_vars</code></td>
<td>
<p>Variables to keep from joined dataset
</p>
<p>The variables needed from the other observations should be specified for
this parameter. The specified variables are added to the joined dataset
with suffix ".join". For example to select all observations with <code>AVALC == "Y"</code> and <code>AVALC == "Y"</code> for at least one subsequent visit <code>join_vars = exprs(AVALC, AVISITN)</code> and <code>condition = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join</code> could be specified.
</p>
<p>The <code style="white-space: pre;">⁠*.join⁠</code> variables are not included in the output dataset.
</p>
<p><em>Permitted Values</em>: a named list of expressions, e.g., created by <code>exprs()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code> is specified all observations after the original observations are
kept.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first_cond</code></td>
<td>
<p>Condition for selecting range of data
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>first_cond_upper</code> instead.
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the subsequent observations, all
observations are removed.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>condition</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>condition</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event, e.g. <code>exprs(PARAMCD = "WSP", PARAM  = "Worst Sleeping Problems")</code>. The values can be a symbol, a
character string, a numeric value, <code>NA</code> or an expression.
</p>
<p><em>Permitted Values</em>: a named list of expressions, e.g., created by <code>exprs()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_source_vars</code></td>
<td>
<p>Variables to keep from the source dataset
</p>
<p>The specified variables are kept for the selected observations. The
variables specified for <code>by_vars</code> (of <code>derive_extreme_event()</code>) and created
by <code>set_values_to</code> are always kept.
</p>
<p><em>Permitted Values</em>: A list of expressions where each element is
a symbol or a tidyselect expression, e.g., <code>exprs(VISIT, VISITNUM, starts_with("RS"))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>Description of the event
</p>
<p>The description does not affect the derivations where the event is used. It
is intended for documentation only.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>event_joined</code>
</p>


<h3>See Also</h3>

<p><code>derive_extreme_event()</code>, <code>derive_vars_extreme_event()</code>, <code>event()</code>
</p>
<p>Source Objects: 
<code>basket_select()</code>,
<code>censor_source()</code>,
<code>death_event</code>,
<code>event()</code>,
<code>event_source()</code>,
<code>flag_event()</code>,
<code>query()</code>,
<code>records_source()</code>,
<code>tte_source()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(tibble)
library(dplyr)
library(lubridate)
# Derive confirmed best overall response (using event_joined())
# CR - complete response, PR - partial response, SD - stable disease
# NE - not evaluable, PD - progressive disease
adsl &lt;- tribble(
  ~USUBJID, ~TRTSDTC,
  "1",      "2020-01-01",
  "2",      "2019-12-12",
  "3",      "2019-11-11",
  "4",      "2019-12-30",
  "5",      "2020-01-01",
  "6",      "2020-02-02",
  "7",      "2020-02-02",
  "8",      "2020-02-01"
) %&gt;%
  mutate(TRTSDT = ymd(TRTSDTC))

adrs &lt;- tribble(
  ~USUBJID, ~ADTC,        ~AVALC,
  "1",      "2020-01-01", "PR",
  "1",      "2020-02-01", "CR",
  "1",      "2020-02-16", "NE",
  "1",      "2020-03-01", "CR",
  "1",      "2020-04-01", "SD",
  "2",      "2020-01-01", "SD",
  "2",      "2020-02-01", "PR",
  "2",      "2020-03-01", "SD",
  "2",      "2020-03-13", "CR",
  "4",      "2020-01-01", "PR",
  "4",      "2020-03-01", "NE",
  "4",      "2020-04-01", "NE",
  "4",      "2020-05-01", "PR",
  "5",      "2020-01-01", "PR",
  "5",      "2020-01-10", "PR",
  "5",      "2020-01-20", "PR",
  "6",      "2020-02-06", "PR",
  "6",      "2020-02-16", "CR",
  "6",      "2020-03-30", "PR",
  "7",      "2020-02-06", "PR",
  "7",      "2020-02-16", "CR",
  "7",      "2020-04-01", "NE",
  "8",      "2020-02-16", "PD"
) %&gt;%
  mutate(
    ADT = ymd(ADTC),
    PARAMCD = "OVR",
    PARAM = "Overall Response by Investigator"
  ) %&gt;%
  derive_vars_merged(
    dataset_add = adsl,
    by_vars = exprs(USUBJID),
    new_vars = exprs(TRTSDT)
  )

derive_extreme_event(
  adrs,
  by_vars = exprs(USUBJID),
  order = exprs(ADT),
  mode = "first",
  source_datasets = list(adsl = adsl),
  events = list(
    event_joined(
      description = paste(
        "CR needs to be confirmed by a second CR at least 28 days later",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join == "CR" &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "CR" &amp;
        all(AVALC.join %in% c("CR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "CR"
      )
    ),
    event_joined(
      description = paste(
        "PR needs to be confirmed by a second CR or PR at least 28 days later,",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join %in% c("CR", "PR") &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "PR" &amp;
        all(AVALC.join %in% c("CR", "PR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "PR"
      )
    ),
    event(
      description = paste(
        "CR, PR, or SD are considered as SD if occurring at least 28",
        "after treatment start"
      ),
      condition = AVALC %in% c("CR", "PR", "SD") &amp; ADT &gt;= TRTSDT + 28,
      set_values_to = exprs(
        AVALC = "SD"
      )
    ),
    event(
      condition = AVALC == "PD",
      set_values_to = exprs(
        AVALC = "PD"
      )
    ),
    event(
      condition = AVALC %in% c("CR", "PR", "SD", "NE"),
      set_values_to = exprs(
        AVALC = "NE"
      )
    ),
    event(
      description = "set response to MISSING for patients without records in ADRS",
      dataset_name = "adsl",
      condition = TRUE,
      set_values_to = exprs(
        AVALC = "MISSING"
      ),
      keep_source_vars = exprs(TRTSDT)
    )
  ),
  set_values_to = exprs(
    PARAMCD = "CBOR",
    PARAM = "Best Confirmed Overall Response by Investigator"
  )
) %&gt;%
  filter(PARAMCD == "CBOR")
</code></pre>


</div>