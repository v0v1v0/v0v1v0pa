<div class="container">

<table style="width: 100%;"><tr>
<td>glPca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Principal Component Analysis for genlight objects</h2>

<h3>Description</h3>

<p>These functions implement Principal Component Analysis (PCA) for
massive SNP datasets stored as genlight object. This
implementation has the advantage of never representing to complete data
matrix, therefore making huge economies in terms of rapid access
memory (RAM). When the <code>parallel</code> package is available,
<code>glPca</code> uses multiple-core ressources for more efficient
computations. <code>glPca</code> returns lists with the class <code>glPca</code>
(see 'value'). 
</p>
<p>Other functions are defined for objects of this class:
</p>
<p>- <code>print</code>: prints the content of a <code>glPca</code> object.
</p>
<p>- <code>scatter</code>: produces scatterplots of principal components,
with a screeplot of eigenvalues as inset.
</p>
<p>- <code>loadingplot</code>: plots the loadings of the analysis for one given
axis, using an adapted version of the generic function <code>loadingplot</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glPca(x, center = TRUE, scale = FALSE, nf = NULL, loadings = TRUE, 
    alleleAsUnit = FALSE, useC = TRUE, parallel = FALSE,
  n.cores = NULL, returnDotProd=FALSE, matDotProd=NULL)

## S3 method for class 'glPca'
print(x, ...)

## S3 method for class 'glPca'
scatter(x, xax = 1, yax = 2, posi = "bottomleft", bg = "white", 
    ratio = 0.3, label = rownames(x$scores), clabel = 1, xlim = NULL, 
    ylim = NULL, grid = TRUE, addaxes = TRUE, origin = c(0, 0), 
    include.origin = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, ...)

## S3 method for class 'glPca'
loadingplot(x, at=NULL, threshold=NULL, axis=1,
    fac=NULL, byfac=FALSE, lab=rownames(x$loadings), cex.lab=0.7, cex.fac=1,
    lab.jitter=0, main="Loading plot", xlab="SNP positions",
    ylab="Contributions", srt = 90, adj = c(0, 0.5), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for <code>glPca</code>, a genlight object; for
<code>print</code>, <code>scatter</code>, and <code>loadingplot</code>, a <code>glPca</code>
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>a logical indicating whether the numbers of alleles
should be centered; defaults to TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating whether the numbers of alleles
should be scaled; defaults to FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nf</code></td>
<td>
<p>an integer indicating the number of principal components to
be retained; if NULL, a screeplot of eigenvalues will be displayed
and the user will be asked for a number of retained axes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>a logical indicating whether loadings of the alleles
should be computed (TRUE, default), or not (FALSE). Vectors of
loadings are not always useful, and can take a large amount of
RAM when millions of SNPs are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alleleAsUnit</code></td>
<td>
<p>a logical indicating whether alleles are
considered as units (i.e., a diploid genotype equals two samples, a
triploid, three, etc.) or whether individuals are considered as
units of information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useC</code></td>
<td>
<p>a logical indicating whether compiled C code should be
used for faster computations; this option cannot be used alongside
parallel option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>a logical indicating whether multiple cores -if
available- should be used for the computations (TRUE), or
not (FALSE, default); requires the package <code>parallel</code> to be installed
(see details); this option cannot be used alongside useCoption.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>if <code>parallel</code> is TRUE, the number of cores to be
used in the computations; if NULL, then the maximum number of cores
available on the computer is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDotProd</code></td>
<td>
<p>a logical indicating whether the matrix of dot
products between individuals should be returned (TRUE) or not
(FALSE, default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matDotProd</code></td>
<td>
<p>an optional matrix of dot products between
individuals, NULL by default. This option is used internally to
speed up computation time when re-running the same PCA several
times. Leave this argument as NULL unless you really know what you
are doing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to other functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xax,yax</code></td>
<td>
<p><code>integers</code> specifying which principal components
should be shown in x and y axes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posi,bg,ratio</code></td>
<td>
<p>arguments used to customize the inset in scatterplots
of <code>glPca</code> results. See <code>add.scatter</code> documentation in the
ade4 package for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area</code></td>
<td>

<p>arguments passed to <code>s.class</code>; see <code>?s.label</code> for more information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>an optional numeric vector giving the abscissa at which
loadings are plotted. Useful when variates are SNPs with a known
position in an alignement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>a threshold value above which values of x are
identified. By default, this is the third quartile of x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axis</code></td>
<td>
<p>an integer indicating the column of x to be plotted; used
only if x is a matrix-like object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>a factor defining groups of SNPs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byfac</code></td>
<td>
<p>a logical stating whether loadings should be averaged by
groups of SNPs, as defined by <code>fac</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab</code></td>
<td>
<p>a character vector giving the labels used to annotate
values above the threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.lab</code></td>
<td>
<p>a numeric value indicating the size of annotations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.fac</code></td>
<td>
<p>a numeric value indicating the size of annotations for
groups of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.jitter</code></td>
<td>
<p>a numeric value indicating the factor of
randomisation for the position of annotations. Set to 0 (by default)
implies no randomisation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>the main title of the figure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>the title of the x axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>the title of the y axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srt</code></td>
<td>
<p>rotation of the labels; see ?text.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj</code></td>
<td>
<p>adjustment of the labels; see ?text.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>=== Using multiple cores ===
</p>
<p>Most recent machines have one or several processors with multiple
cores. R processes usually use one single core. The package
<code>parallel</code> allows for parallelizing some computations on
multiple cores, which can decrease drastically computational time.
</p>
<p>Lastly, note that using compiled C code (<code>useC=TRUE</code>)is an
alternative for speeding up computations, but cannot be used together
with the parallel option.
</p>


<h3>Value</h3>

<p>=== glPca objects ===
</p>
<p>The class <code>glPca</code> is a list with the following
components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eig</code></td>
<td>
<p>a numeric vector of eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>a matrix of principal components, containing the
coordinates of each individual (in row) on each principal axis (in column).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>(optional) a matrix of loadings, containing the loadings of each
SNP (in row) for each principal axis (in column).</p>
</td>
</tr>
</table>
<p>-
</p>
<p>=== other outputs ===
</p>
<p>Other functions have different outputs:<br>
- <code>scatter</code> return the matched call.<br>
- <code>loadingplot</code> returns information about the most contributing
SNPs (see <code>loadingplot.default</code>)
</p>


<h3>Author(s)</h3>

<p> Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a> </p>


<h3>See Also</h3>

<p>- <code>genlight</code>: class of object for storing massive binary
SNP data.
</p>
<p>- <code>glSim</code>: a simple simulator for genlight objects.
</p>
<p>- <code>glPlot</code>: plotting genlight objects.
</p>
<p>- <code>dapc</code>: Discriminant Analysis of Principal Components.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## simulate a toy dataset
x &lt;- glSim(50,4e3, 50, ploidy=2)
x
plot(x)

## perform PCA
pca1 &lt;- glPca(x, nf=2)

## plot eigenvalues
barplot(pca1$eig, main="eigenvalues", col=heat.colors(length(pca1$eig)))

## basic plot
scatter(pca1, ratio=.2)

## plot showing groups
s.class(pca1$scores, pop(x), col=colors()[c(131,134)])
add.scatter.eig(pca1$eig,2,1,2)

## End(Not run)
</code></pre>


</div>