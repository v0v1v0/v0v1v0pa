<div class="container">

<table style="width: 100%;"><tr>
<td>apc.fit.model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fits an age period cohort model</h2>

<h3>Description</h3>

<p><code>apc.fit.model</code> fits the age period cohort model as a Generalized Linear Model using <code>glm.fit</code>.
The model is parametrised in terms of the canonical parameter introduced by Kuang, Nielsen and Nielsen (2008),
see also the implementation in Martinez Miranda, Nielsen and Nielsen (2015).
This parametrisation has a number of advantages: it is freely varying, it is the canonical parameter of a
regular exponential family, and it is invariant to extentions of the data matrix.
Other parametrizations can be computed using <code>apc.identify</code>.
</p>
<p><code>apc.fit.model</code> can be be used for all three age period cohort factors, or for submodels with fewer of these factors. 
</p>
<p><code>apc.fit.model</code> can be used either for mortality rates through a dose-response model or for mortality counts through a pure response model without doses/exposures.  
</p>
<p>The GLM families include Poisson regressions (with log link) and Normal/Gaussian least squares regressions.  
</p>
<p>apc.fit.table produces a deviance table for 15 combinations of the three factors and linear trends:
"APC", "AP", "AC", "PC", "Ad", "Pd", "Cd", "A", "P", "C", "t", "tA", "tP", "tC", "1".
</p>


<h3>Usage</h3>

<pre><code class="language-R">	apc.fit.model(apc.data.list,model.family,model.design,apc.index=NULL,
			replicate.version.1.3.1=FALSE)
		apc.fit.table(apc.data.list,model.family,model.design.reference="APC",
			apc.index=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>apc.data.list</code></td>
<td>
<p>List. See <code>apc.data.list</code> for a description of the format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.family</code></td>
<td>
<p>Character.  The following options are implemented.	These are used internally when
calling <code>glm.fit</code>.		
</p>

<dl>
<dt>"poisson.response"</dt>
<dd>
<p>This sets family=poisson(link="log"). Only responses are used.
Inference is done in a multinomial model, conditioning on the overall level
as documented in Martinez Miranda, Nielsen and Nielsen (2015).</p>
</dd>
<dt>"od.poisson.response"</dt>
<dd>
<p>This sets family=quasipoisson(link="log") in the estimation step,
but then reverts to family=poisson(link="log") when computing standard errors, which are then corrected.
Only responses are used.
Inference is done in an over-dispersed Poisson model
as documented in Harnau and Nielsen (2016).
Note that limit distributions are t and F not normal and chi2.</p>
</dd>
<dt>"poisson.dose.response"</dt>
<dd>
<p>This sets family=poisson(link="log"). Doses are used as offset.</p>
</dd>
<dt>"binomial.dose.response"</dt>
<dd>
<p>This sets family=binomial(link="logit") and gives a logistic regression.</p>
</dd>
<dt>"gaussian.rates"</dt>
<dd>
<p>This sets family=gaussian(link="identity").
The dependent variable is the mortality rates, which are computed
as response/dose.</p>
</dd>
<dt>"gaussian.response"</dt>
<dd>
<p>This sets family=gaussian(link="identity").  Only responses are used.
The dependent variable is the responses.</p>
</dd>
<dt>"log.normal.rates"</dt>
<dd>
<p>Gaussian regression for log(rates) and with identity link (Least Squares).</p>
</dd>	
<dt>"log.normal.response"</dt>
<dd>
<p>Gaussian regression for log(response) and with identity link (Least Squares).</p>
</dd>	
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.design</code></td>
<td>
<p>Character.  This indicates the design choice.  The following options are possible.
</p>

<dl>
<dt>"APC"</dt>
<dd>
<p>Age-period-cohort model.</p>
</dd>
<dt>"AP" </dt>
<dd>
<p>Age-period model. Nested in "APC"</p>
</dd>
<dt>"AC" </dt>
<dd>
<p>Age-cohort model. Nested in "APC"</p>
</dd>
<dt>"PC" </dt>
<dd>
<p>Period-cohort model. Nested in "APC"</p>
</dd>
<dt>"Ad" </dt>
<dd>
<p>Age-trend model, including age effect and two linear trends. Nested in "AP", "AC".</p>
</dd>
<dt>"Pd" </dt>
<dd>
<p>Period-trend model, including period effect and two linear trends. Nested in "AP", "PC".</p>
</dd>
<dt>"Cd" </dt>
<dd>
<p>Cohort-trend model, including cohort effect and two linear trends. Nested in "AC", "PC".</p>
</dd>
<dt>"A"  </dt>
<dd>
<p>Age model. Nested in "Ad".</p>
</dd>      
<dt>"P"  </dt>
<dd>
<p>Period model. Nested in "Pd".</p>
</dd>
<dt>"C"  </dt>
<dd>
<p>Cohort model. Nested in "Cd".</p>
</dd>
<dt>"t"  </dt>
<dd>
<p>Trend model, with two linear trends. Nested in "Ad", "Pd", "Cd".</p>
</dd>
<dt>"tA" </dt>
<dd>
<p>Single trend model in age index. Nested in "A", "t".</p>
</dd>
<dt>"tP" </dt>
<dd>
<p>Single trend model in period index. Nested in "P", "t".</p>
</dd>
<dt>"tC" </dt>
<dd>
<p>Single trend model in cohort index. Nested in "C", "t".</p>
</dd>
<dt>"1"  </dt>
<dd>
<p>Constant model. Nested in "tA", "tP", "tC".</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.design.reference</code></td>
<td>
<p>Character.  This indicates the reference design choice for the deviance table. Choices are
"APC","AP","AC","PC","Ad","Pd","Cd","A","P","C","t". Default is "APC".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apc.index</code></td>
<td>
<p><em>Optional</em>. List. See <code>apc.get.index</code> for a description of the format.
If not provided this is computed internally.
If <code>apc.fit.model</code> is used in a simulation study computational effort can be saved when
using this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replicate.version.1.3.1</code></td>
<td>
<p><em>Optional</em>. Logical. Replicate error in covariance calculation for 
"poisson.response","od.poisson.response" in versions 1.2.3-1.3.1. Default=FALSE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><em>apc.fit.table</em>
produces a deviance table.  There are 15 rows corresponding to all possible design choices.
The columns are as follows.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>"-2logL"</code></td>
<td>
<p>-2 log Likelihood up to some constant.
If the model family is Poisson or binomial (logistic)
this is the same as the <code>glm</code> deviance: That is the difference in -2 log likelihood value between estimated
model and the saturated model.
If the model family is Gaussian it is different from the traditional
<code>glm</code> deviance.  Here the -2 log likelihood value is measured in a model with unknown variance,
which is the standard in regression analysis, whereas in the <code>glm</code> package the deviance
is the residual sum of squares, which can be interpreted as the 
-2 log likelihood value in a model with variance set to one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"df.residual"</code></td>
<td>
<p>Degrees of freedom of residual: nrow x ncol - dim(parameter).
If the model.family="poisson.response" the degrees of freedom is one lower.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"prob(&gt;chi_sq)"</code></td>
<td>
<p>p-value of the deviance, -2logL. Left out in Gaussian case which has no saturated model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"LR vs APC"</code></td>
<td>
<p>the likelihood ratio statistic against the "APC" model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"df"</code></td>
<td>
<p>Degrees of freedom against the "APC" model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"prob(&gt;chi_sq)"</code></td>
<td>
<p>p-value of log likelihood ratio statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"aic"</code></td>
<td>
<p>Akaike's "An Information Criterion", minus twice the maximized log-likelihood plus twice the
number of parameters upto a constant.  It is take directly from the
<code>glm</code> function.  
For the "poisson.dose.response" and "binomial.dose.response" model families
the dispersion is fixed at one and the number of parameters is the number of coefficients.
The "poisson.response" model is conditional on the level.  The number of parameters should therefore be
adjusted by subtracting 2 to take this into account to get the proper AIC. However, in practice this does not matter,
since we are only interested in relative effects. 
For the "gaussian.response" and "gaussian.dose.response" model families the dispersion is estimated from
the residual deviance. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"F"</code></td>
<td>
<p>Only for "od.poisson.response". F statistic: Ratio of deviance for submodel divided by degrees of freedom to deviance of apc model divided by degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>"prof(&gt;F)"</code></td>
<td>
<p>Only for "od.poisson.response". F statistic: with degrees of freedom given by differences between sub-model and apc model and between apc model and saturated model.</p>
</td>
</tr>
</table>
<p><em>apc.fit.model</em>
returns a list. The entries are as follows.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>List. Values from <code>glm.fit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apc.index</code></td>
<td>
<p>List. Values from <code>apc.get.index</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients.canonical</code></td>
<td>
<p>Matrix.  For each coordinate of the canonical parameters is reported coefficient, standard deviation, z-value, which is the ratio of those, and asymptotically normal p-values.
Note, for "od.poisson.response" the reported standard errors corrected by the deviance and p-values are asymptotically t distributed, see Harnau and Nielsen (2016).
Other parametrizations can be computed using <code>apc.identify</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariance.canonical	</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for canonical parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slopes				</code></td>
<td>
<p>Vector.  Length three.  The design matrix found by <code>apc.get.design.collinear</code> has age, period, and cohort linear trends. <code>slopes</code> indicates which of these are actually used in estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>difdif				</code></td>
<td>
<p>Vector.  Length three.  The design matrix found by <code>apc.get.design.collinear</code> has age, period, and cohort double differences. <code>slopes</code> indicates which of these are actually used in estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.age				</code></td>
<td>
<p>Vector.  Indices for age    double difference parameters within <code>coefficients.canonical</code>.  NULL if age    double differences are not estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.per				</code></td>
<td>
<p>Vector.  Indices for period double difference parameters within <code>coefficients.canonical</code>.  NULL if period double differences are not estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.coh				</code></td>
<td>
<p>Vector.  Indices for cohort double difference parameters within <code>coefficients.canonical</code>.  NULL if cohort double differences are not estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dates					</code></td>
<td>
<p>Vector.  Indicates the dates for the double difference parameters within <code>coefficients.canonical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.family			</code></td>
<td>
<p>Character. Argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.design			</code></td>
<td>
<p>Character. Argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RSS					</code></td>
<td>
<p>Numeric.  Residual sum of squares.  NULL for non-gaussian families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2				</code></td>
<td>
<p>Numeric.  Maximum likelihood estimator for variance: RSS/n.  NULL for non-gaussian families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2					</code></td>
<td>
<p>Numeric.  Least squares estimator for variance: RSS/df.  NULL for non-gaussian families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.decimal				</code></td>
<td>
<p>Numeric.  From <code>apc.data.list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictors			</code></td>
<td>
<p>Vector. Design*Estimates.                                          
Same as the <code>glm.fit</code> value <code>linear.predictors</code> when there is no offset.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For gaussian families <em>deviance</em> is defined differently in <code>apc</code> and <code>glm</code>.
Here it is -2 log likelihood.  In <code>glm</code> it is RSS.
</p>
<p>The values for <code>apc.fit.model</code> include the <code>apc.data.list</code> and the <code>apc.index</code> returned by
<code>apc.get.index</code>.
</p>
<p>For the <code>poisson.response</code> the inference is conditional on the level, see Martinez Miranda, Nielsen and Nielsen (2015).
The <code>coefficients.canonical</code> computed by <code>apc</code> are therefore different from the default <code>coefficients</code> computed by <code>glm</code>.
</p>
<p>For the <code>od.poisson.response</code> an asymptotic theory is used that mimics the conditioning for <code>poisson.response</code>.
The asymptotic distribution are, however, asymptotically t or F distributed, see Harnau and Nielsen (2017).
</p>
<p>For the <code>log.normal.response</code> standard normal theory applies for quantities on the log scale including estimators.
An asymptotic theory for quantities on the original scale is provided in Kuang and Nielsen (2018). 
</p>
<p>For <code>coefficients</code> the 3rd and 4th columns have headings <code>t value</code> and <code>Pr(&gt;|t|)</code> for <code>od.poisson.response</code>
to indicate an asymptotic t theory
and otherwise
<code>z value</code> and <code>Pr(&gt;|z|)</code> to indicate an asymptotic normal theory. The labels are inherited from <code>glm.fit</code>.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 15 Aug 2018 (27 Aug 2014)</p>


<h3>References</h3>

<p>Harnau, J. and Nielsen (2016) Over-dispersed age-period-cohort models. To appear in <em>Journal of the American Statistical Association</em>. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2017/HarnauNielsen2017apcDP.pdf">Nuffield DP</a>
</p>
<p>Kuang, D, Nielsen B (2018) Generalized log-normal chain-ladder. mimeo Nuffield Collge.
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>


<h3>See Also</h3>

<p>The fit is done using <code>glm.fit</code>.
</p>
<p>The examples below use Italian bladder cancer data, see <code>data.Italian.bladder.cancer</code>
and
Belgian lung cancer data, see <code>data.Belgian.lung.cancer</code>.
</p>
<p>In example 3 the design matrix is called is called using <code>apc.get.design</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#####################
#	EXAMPLE 1 with Italian bladder cancer data

data.list	&lt;- data.Italian.bladder.cancer()	#	function gives data list
apc.fit.table(data.list,"poisson.dose.response")

#	       -2logL df.residual prob(&gt;chi_sq) LR.vs.APC df.vs.APC prob(&gt;chi_sq)       aic
#	APC    33.179          27         0.191        NA        NA            NA   487.624
#	AP    512.514          40         0.000   479.335        13         0.000   940.958
#	AC     39.390          30         0.117     6.211         3         0.102   487.835
#	PC   1146.649          36         0.000  1113.470         9         0.000  1583.094
#	Ad    518.543          43         0.000   485.364        16         0.000   940.988
#	Pd   4041.373          49         0.000  4008.194        22         0.000  4451.818
#	Cd   1155.629          39         0.000  1122.450        12         0.000  1586.074
#	A    2223.800          44         0.000  2190.621        17         0.000  2644.245
#	P   84323.944          50         0.000 84290.765        23         0.000 84732.389
#	C   23794.205          40         0.000 23761.026        13         0.000 24222.650
#	t    4052.906          52         0.000  4019.727        25         0.000  4457.351
#	tA   5825.158          53         0.000  5791.979        26         0.000  6227.602
#	tP  84325.758          53         0.000 84292.579        26         0.000 84728.203
#	tC  33446.796          53         0.000 33413.617        26         0.000 33849.241
#	1   87313.678          54         0.000 87280.499        27         0.000 87714.123
#
#	Table suggests that "APC" and "AC" fit equally well.  Try both

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
fit.ac	&lt;- apc.fit.model(data.list,"poisson.dose.response","AC")

#	Compare the estimates: They are very similar

fit.apc$coefficients.canonical
fit.ac$coefficients.canonical

#####################
#	EXAMPLE 2 with Belgian lung cancer data
#	This example illustrates how to find the linear predictors 

data.list	&lt;- data.Belgian.lung.cancer()

#	Get an APC fit

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")

#	The linear predictor of the fit is a vector.
#	But, we would like it in the same format as the data.
#	Thus create matrix of same dimension as response data
#	This can be done in two ways

m.lp	&lt;- data.list$response	#	using original information	
m.lp	&lt;- fit.apc$response		# 	using information copied when fitting

#	the fit object index.data is used to fill linear predictor in
#	vector format into matrix format

m.lp[fit.apc$index.data]	&lt;-fit.apc$linear.predictors
exp(m.lp)

#####################
#	EXAMPLE 3 with Belgian lung cancer data
#	This example illustrates how apc.fit.model works.

data.list	&lt;- data.Belgian.lung.cancer()

#	Vectorise data
index		&lt;- apc.get.index(data.list)
v.response	&lt;- data.list$response[index$index.data]
v.dose		&lt;- data.list$dose[index$index.data]

#	Get design
m.design	&lt;- apc.get.design(index,"APC")$design

#	Fit using glm.fit from stats package
fit.apc.glm	&lt;- glm.fit(m.design,v.response,family=poisson(link="log"),offset=log(v.dose))

#	Get canonical coefficients
v.cc		&lt;- fit.apc.glm$coefficients

#	Find linear predictors and express in matrix form
m.fit		&lt;- data.list$response			#	create matrix
m.fit[index$index.data]		&lt;- m.design 
m.fit.offset		&lt;- m.fit + log(data.list$dose)	#	add offset
exp(m.fit.offset)

#	Compare with linear.predictors from glm.fit
#	difference should be zero
sum(abs(m.fit.offset[index$index.data]-fit.apc.glm$linear.predictors))

#####################
#	EXAMPLE 4 with Taylor-Ashe loss data
#	This example illustrates the over-dispersed poisson response model.

data &lt;- data.loss.TA()
fit.apc.od &lt;- apc.fit.model(data,"od.poisson.response","APC")
fit.apc.od$coefficients.canonical[1:5,]
fit.apc.no.od &lt;- apc.fit.model(data,"poisson.response","APC")
fit.apc.no.od$coefficients.canonical[1:5,]
</code></pre>


</div>