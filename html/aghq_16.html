<div class="container">

<table style="width: 100%;"><tr>
<td>default_control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Default control arguments for <code>aghq::aghq()</code>.</h2>

<h3>Description</h3>

<p>Run <code>default_control()</code> to print the list of valid control parameters
and their defaults, and run with named arguments to change the defaults.
</p>


<h3>Usage</h3>

<pre><code class="language-R">default_control(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>You can provide a named value for any control parameter and its
value will be set accordingly. See <code>?aghq</code> and examples here.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Valid options are:
</p>

<ul>
<li>
<p><code>method</code>: optimization method to use:
</p>

<ul>
<li>
<p>'BFGS' (default): <code>optim(...,method = "BFGS")</code>
</p>
</li>
<li>
<p>'sparse_trust': <code>trustOptim::trust.optim</code>
</p>
</li>
<li>
<p>'SR1': <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li>
<p>'sparse': <code>trust::trust</code>
</p>
</li>
</ul>
<p>Default is 'sparse_trust'.

</p>
</li>
<li> <p><code>negate</code>: default <code>FALSE</code>. Multiply the functions in <code>ff</code> by <code>-1</code>?
The reason for having this option is for full compatibility with <code>TMB</code>:
while of course <code>TMB</code> allows you to code up your log-posterior any way you like,
all of its excellent features including its automatic Laplace approximation and MCMC
sampling with <code>tmbstan</code> assume you have coded your template to return the
<strong>negated</strong> log-posterior. However, by default, <code>aghq</code> assumes you have
provided the log-posterior <strong>without negation</strong>. Set <code>negate = TRUE</code> if you
have provided a template which computes the <strong>negated</strong> log-posterior and its
derivatives.
</p>
</li>
<li> <p><code>ndConstruction</code>: construct a multivariate quadrature rule using a <code>"product"</code>
rule or a <code>"sparse"</code> grid? Default <code>"product"</code>. See <code>?mvQuad::createNIGrid()</code>.
</p>
</li>
<li> <p><code>interpolation</code>: how to interpolate the marginal posteriors. The <code>'auto'</code> option
(default) chooses for you and should always work well. The <code>'polynomial'</code>
option uses <code>polynom::poly.calc()</code> to construct a global polynomial interpolant
and has been observed to be unstable as the number of quadrature points gets larger, which
is obviously a bad thing. Try <code>'spline'</code> instead, which uses a cubic B-Spline
interpolant from <code>splines::interpSpline()</code>.
</p>
</li>
<li>
<p>numhessian: logical, default <code>FALSE</code>. Replace the <code>ff$he</code> with a numerically-differentiated
version, by calling <code>numDeriv::jacobian</code> on <code>ff$gr</code>. Used mainly for <code>TMB</code> with the automatic
Laplace approximation, which does not have an automatic Hessian.
</p>
</li>
<li>
<p>onlynormconst: logical, default <code>FALSE</code>. Skip everything after the calculation of the log integral,
and just return the numeric value of the log integral. Saves computation time, and most useful in cases
where <code>aghq</code> is being used as a step in a more complicated procedure.
</p>
</li>
<li>
<p>method_summaries: default <code>'reuse'</code>, method to use to compute moments and marginals. Choosing
<code>'correct'</code> corresponds to the approximations suggested in the <em>Stochastic Convergence...</em> paper,
which attain the same rate of convergence as the approximation to the marginal likelihood. See <code>?compute_moment</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
default_control()
default_control(method = "trust")
default_control(negate = TRUE)

</code></pre>


</div>