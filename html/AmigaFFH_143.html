<div class="container">

<table style="width: 100%;"><tr>
<td>WaveToIFF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert WaveMC objects into an Interchange File Format object</h2>

<h3>Description</h3>

<p>Convert <code>tuneR::WaveMC()</code> objects (or objects that can be coerced to
<code>WaveMC</code> objects) into an <code>IFFChunk-class()</code> object which
can be stored as a valid Iterchange File Format (<code>write.iff()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">WaveToIFF(
  x,
  loop.start = NA,
  octaves = 1,
  compress = c("sCmpNone", "sCmpFibDelta"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>tuneR::WaveMC()</code> object that needs to be converted into an <code>IFFChunk()</code> object. <code>x</code>
can also be any other class object that can be coerced into a <code>tuneR::WaveMC()</code> object. <code>tuneR::Wave()</code>
and <code>PTSample()</code> objects are therefore also allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loop.start</code></td>
<td>
<p>If the sample should be looped from a specific position to the
end of the sample, this argument specifies the starting position in samples (with
a base of 0) for looping. <code>loop.start</code> therefore should be a whole non-negative
number. When set to <code>NA</code> or negative values, the sample will not be looped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>octaves</code></td>
<td>
<p>A whole positive <code>numeric</code> value indicating the number of octaves
that should be stored in the resulting IFF chunk. The original wave will be resampled
for each value larger than 1. Each subsequent octave will contain precisely twice
as many samples as the previous octave.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress</code></td>
<td>
<p>A <code>character</code> string indicating whether compression should be applied to the waveform. "<code>sCmpNone</code>"
(default) applies no compression, "<code>sCmpFibDelta</code>" applies the lossy <code>deltaFibonacciCompress()</code>ion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tuneR::WaveMC()</code> objects can be read from contemporary file containers
with <code>tuneR::readWave()</code> or <code>tuneR::readMP3()</code>. With this
function such objects can be converted into an <code>IFFChunk-class()</code> object
which can be stored conform the Interchange File Format (<code>write.iff()</code>).
</p>
<p>When <code>x</code> is not a pcm formatted 8-bit sample, <code>x</code> will first be
normalised and scaled to a pcm-formatted 8-bit sample using
<code>tuneR::normalize()</code>. If you don't like the result you need to convert
the sample to 8-bit pcm yourself before calling this function.
</p>


<h3>Value</h3>

<p>Returns an <code>IFFChunk-class()</code> object with a FORM container that
contains an 8SVX waveform based on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/8SVX">https://en.wikipedia.org/wiki/8SVX</a>
</p>


<h3>See Also</h3>

<p>Other iff.operations: 
<code>IFFChunk-class</code>,
<code>as.raster.AmigaBasicShape()</code>,
<code>getIFFChunk()</code>,
<code>interpretIFFChunk()</code>,
<code>rasterToIFF()</code>,
<code>rawToIFFChunk()</code>,
<code>read.iff()</code>,
<code>write.iff()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## First get an audio sample from the ProTrackR package
snare.samp &lt;- ProTrackR::PTSample(ProTrackR::mod.intro, 2)

## The sample can easily be converted into an IFFChunk:
snare.iff &lt;- WaveToIFF(snare.samp)

## You could also first convert the sample into a Wave object:
snare.wav &lt;- as(snare.samp, "Wave")

## And then convert into an IFFChunk. The result is the same:
snare.iff &lt;- WaveToIFF(snare.wav)

## You could also use a sine wave as input (although you will get some warnings).
## This will work because the vector of numeric data can be coerced to
## a WaveMC object
sine.iff &lt;- WaveToIFF(sin((0:2000)/20))

## End(Not run)
</code></pre>


</div>