<div class="container">

<table style="width: 100%;"><tr>
<td>all.equal.phylo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Global Comparison of two Phylogenies</h2>

<h3>Description</h3>

<p>This function makes a global comparison of two phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'phylo'
all.equal(target, current, use.edge.length = TRUE,
                   use.tip.label = TRUE, index.return = FALSE,
                   tolerance = .Machine$double.eps ^ 0.5,
                   scale = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>current</code></td>
<td>
<p>an object of class <code>"phylo"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.edge.length</code></td>
<td>
<p>if <code>FALSE</code> only the topologies are
compared; the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.tip.label</code></td>
<td>
<p>if <code>FALSE</code> the unlabelled trees are
compared; the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index.return</code></td>
<td>
<p>if <code>TRUE</code> the function returns a two-column
matrix giving the correspondence between the nodes of both trees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>the numeric tolerance used to compare the branch
lengths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a positive number, comparison of branch lengths is made
after scaling (i.e., dividing) them by this number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is meant to be an adaptation of the generic function
<code>all.equal</code> for the comparison of phylogenetic trees.
</p>
<p>A single phylogenetic tree may have several representations in the Newick
format and in the <code>"phylo"</code> class of objects used in ‘ape’. One
aim of the present function is to be able to identify whether two
objects of class <code>"phylo"</code> represent the same phylogeny.
</p>


<h3>Value</h3>

<p>A logical value, or a two-column matrix.
</p>


<h3>Note</h3>

<p>The algorithm used here does not work correctly for the comparison of
topologies (i.e., ignoring tip labels) of unrooted trees. This also
affects <code>unique.multiPhylo</code> which calls the present function. See:
</p>
<p><a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg01445.html">https://www.mail-archive.com/r-sig-phylo@r-project.org/msg01445.html</a>.
</p>


<h3>Author(s)</h3>

<p>Benoît Durand <a href="mailto:b.durand@alfort.AFSSA.FR">b.durand@alfort.AFSSA.FR</a></p>


<h3>See Also</h3>

<p><code>all.equal</code> for the generic <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, <code>comparePhylo</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### maybe the simplest example of two representations
### for the same rooted tree...:
t1 &lt;- read.tree(text = "(a:1,b:1);")
t2 &lt;- read.tree(text = "(b:1,a:1);")
all.equal(t1, t2)
### ... compare with this:
identical(t1, t2)
### one just slightly more complicated...:
t3 &lt;- read.tree(text = "((a:1,b:1):1,c:2);")
t4 &lt;- read.tree(text = "(c:2,(a:1,b:1):1);")
all.equal(t3, t4) # == all.equal.phylo(t3, t4)
### ... here we force the comparison as lists:
all.equal.list(t3, t4)
</code></pre>


</div>