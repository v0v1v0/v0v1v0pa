<div class="container">

<table style="width: 100%;"><tr>
<td>aggregateDist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate Claim Amount Distribution</h2>

<h3>Description</h3>

<p>Compute the aggregate claim amount cumulative distribution function of
a portfolio over a period using one of five methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregateDist(method = c("recursive", "convolution", "normal",
                         "npower", "simulation"),
              model.freq = NULL, model.sev = NULL, p0 = NULL,
              x.scale = 1, convolve = 0, moments, nb.simul, ...,
              tol = 1e-06, maxit = 500, echo = FALSE)

## S3 method for class 'aggregateDist'
print(x, ...)

## S3 method for class 'aggregateDist'
plot(x, xlim, ylab = expression(F[S](x)),
     main = "Aggregate Claim Amount Distribution",
     sub = comment(x), ...)

## S3 method for class 'aggregateDist'
summary(object, ...)

## S3 method for class 'aggregateDist'
mean(x, ...)

## S3 method for class 'aggregateDist'
diff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.freq</code></td>
<td>
<p>for <code>"recursive"</code> method: a character string
giving the name of a distribution in the <code class="reqn">(a, b, 0)</code> or <code class="reqn">(a,
      b, 1)</code> families of distributions. For <code>"convolution"</code> method:
a vector of claim number probabilities. For <code>"simulation"</code>
method: a frequency simulation model (see <code>rcomphierarc</code> for
details) or <code>NULL</code>. Ignored with <code>normal</code> and
<code>npower</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.sev</code></td>
<td>
<p>for <code>"recursive"</code> and <code>"convolution"</code>
methods: a vector of claim amount probabilities. For
<code>"simulation"</code> method: a severity simulation model (see
<code>rcomphierarc</code> for details) or <code>NULL</code>. Ignored with
<code>normal</code> and <code>npower</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>arbitrary probability at zero for the frequency
distribution. Creates a zero-modified or zero-truncated
distribution if not <code>NULL</code>. Used only with <code>"recursive"</code>
method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.scale</code></td>
<td>
<p>value of an amount of 1 in the severity model (monetary
unit). Used only with <code>"recursive"</code> and <code>"convolution"</code>
methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convolve</code></td>
<td>
<p>number of times to convolve the resulting distribution
with itself. Used only with <code>"recursive"</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>moments</code></td>
<td>
<p>vector of the true moments of the aggregate claim
amount distribution; required only by the <code>"normal"</code> or
<code>"npower"</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.simul</code></td>
<td>
<p>number of simulations for the <code>"simulation"</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters of the frequency distribution for the
<code>"recursive"</code> method; further arguments to be passed to or
from other methods otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the resulting cumulative distribution in the
<code>"recursive"</code> method will get less than <code>tol</code> away from
1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of recursions in the <code>"recursive"</code>
method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>echo</code></td>
<td>
<p>logical; echo the recursions to screen in the
<code>"recursive"</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>an object of class <code>"aggregateDist"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>numeric of length 2; the <code class="reqn">x</code> limits of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>label of the y axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>main title.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub</code></td>
<td>
<p>subtitle, defaulting to the calculation method.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>aggregateDist</code> returns a function to compute the cumulative
distribution function (cdf) of the aggregate claim amount distribution
in any point.
</p>
<p>The <code>"recursive"</code> method computes the cdf using the Panjer
algorithm; the <code>"convolution"</code> method using convolutions; the
<code>"normal"</code> method using a normal approximation; the
<code>"npower"</code> method using the Normal Power 2 approximation; the
<code>"simulation"</code> method using simulations. More details follow.
</p>


<h3>Value</h3>

<p>A function of class <code>"aggregateDist"</code>, inheriting from the
<code>"function"</code> class when using normal and Normal Power
approximations and additionally inheriting from the <code>"ecdf"</code> and
<code>"stepfun"</code> classes when other methods are used.
</p>
<p>There are methods available to summarize (<code>summary</code>), represent
(<code>print</code>), plot (<code>plot</code>), compute quantiles
(<code>quantile</code>) and compute the mean (<code>mean</code>) of
<code>"aggregateDist"</code> objects.
</p>
<p>For the <code>diff</code> method: a numeric vector of probabilities
corresponding to the probability mass function evaluated
at the knots of the distribution.
</p>


<h3>Recursive method</h3>

<p>The frequency distribution must be a member of the <code class="reqn">(a, b, 0)</code> or
<code class="reqn">(a, b, 1)</code> families of discrete distributions.
</p>
<p>To use a distribution from the <code class="reqn">(a, b, 0)</code> family,
<code>model.freq</code> must be one of
<code>"binomial"</code>,
<code>"geometric"</code>,
<code>"negative binomial"</code> or
<code>"poisson"</code>,
and <code>p0</code> must be <code>NULL</code>.
</p>
<p>To use a zero-truncated distribution from the <code class="reqn">(a, b, 1)</code> family,
<code>model.freq</code> may be one of the strings above together with
<code>p0 = 0</code>. As a shortcut, <code>model.freq</code> may also be one of
<code>"zero-truncated binomial"</code>,
<code>"zero-truncated geometric"</code>,
<code>"zero-truncated negative binomial"</code>,
<code>"zero-truncated poisson"</code> or
<code>"logarithmic"</code>,
and <code>p0</code> is then ignored (with a warning if non <code>NULL</code>).
</p>
<p>(Note: since the logarithmic distribution is always zero-truncated.
<code>model.freq = "logarithmic"</code> may be used with either <code>p0 =
  NULL</code> or <code>p0 = 0</code>.)
</p>
<p>To use a zero-modified distribution from the <code class="reqn">(a, b, 1)</code> family,
<code>model.freq</code> may be one of standard frequency distributions
mentioned above with <code>p0</code> set to some probability that the
distribution takes the value <code class="reqn">0</code>. It is equivalent, but more
explicit, to set <code>model.freq</code> to one of
<code>"zero-modified binomial"</code>,
<code>"zero-modified geometric"</code>,
<code>"zero-modified negative binomial"</code>,
<code>"zero-modified poisson"</code> or
<code>"zero-modified logarithmic"</code>.
</p>
<p>The parameters of the frequency distribution must be specified using
names identical to the arguments of the appropriate function
<code>dbinom</code>, <code>dgeom</code>, <code>dnbinom</code>,
<code>dpois</code> or <code>dlogarithmic</code>. In the latter case,
do take note that the parametrization of <code>dlogarithmic</code> is
different from Appendix B of Klugman et al. (2012).
</p>
<p>If the length of <code>p0</code> is greater than one, only the first element
is used, with a warning.
</p>
<p><code>model.sev</code> is a vector of the (discretized) claim amount
distribution <code class="reqn">X</code>; the first element <strong>must</strong> be <code class="reqn">f_X(0) =
    \Pr[X = 0]</code>.
</p>
<p>The recursion will fail to start if the expected number of claims is
too large. One may divide the appropriate parameter of the frequency
distribution by <code class="reqn">2^n</code> and convolve the resulting distribution
<code class="reqn">n =</code> <code>convolve</code> times.
</p>
<p>Failure to obtain a cumulative distribution function less than
<code>tol</code> away from 1 within <code>maxit</code> iterations is often due
to too coarse a discretization of the severity distribution.
</p>


<h3>Convolution method</h3>

<p>The cumulative distribution function (cdf) <code class="reqn">F_S(x)</code> of the
aggregate claim amount of a portfolio in the collective risk model is
</p>
<p style="text-align: center;"><code class="reqn">F_S(x) = \sum_{n = 0}^{\infty} F_X^{*n}(x) p_n,</code>
</p>

<p>for <code class="reqn">x = 0, 1, \dots</code>; <code class="reqn">p_n = \Pr[N = n]</code> is
the frequency probability mass function and
<code class="reqn">F_X^{*n}(x)</code> is the cdf of the <code class="reqn">n</code>th convolution of
the (discrete) claim amount random variable.
</p>
<p><code>model.freq</code> is vector <code class="reqn">p_n</code> of the number of claims
probabilities; the first element <strong>must</strong> be <code class="reqn">\Pr[N =
  0]</code>.
</p>
<p><code>model.sev</code> is vector <code class="reqn">f_X(x)</code> of the (discretized)
claim amount distribution; the first element <strong>must</strong> be
<code class="reqn">f_X(0)</code>.
</p>


<h3>Normal and Normal Power 2 methods</h3>

<p>The Normal approximation of a cumulative distribution function (cdf)
<code class="reqn">F(x)</code> with mean <code class="reqn">\mu</code> and standard deviation
<code class="reqn">\sigma</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) \approx \Phi\left( \frac{x - \mu}{\sigma} \right).</code>
</p>

<p>The Normal Power 2 approximation of a cumulative distribution function (cdf)
<code class="reqn">F(x)</code> with mean <code class="reqn">\mu</code>, standard deviation <code class="reqn">\sigma</code>
and skewness <code class="reqn">\gamma</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) \approx \Phi \left(%
    -\frac{3}{\gamma} + \sqrt{\frac{9}{\gamma^2} + 1 %
      + \frac{6}{\gamma} \frac{x - \mu}{\sigma}} \right).</code>
</p>

<p>This formula is valid only for the right-hand tail of the distribution
and skewness should not exceed unity.
</p>


<h3>Simulation method</h3>

<p>This methods returns the empirical distribution function of a sample
of size <code>nb.simul</code> of the aggregate claim amount distribution
specified by <code>model.freq</code> and
<code>model.sev</code>. <code>rcomphierarc</code> is used for the simulation of
claim amounts, hence both the frequency and severity models can be
mixtures of distributions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Daykin, C.D., Pentik√§inen, T. and Pesonen, M.
(1994), <em>Practical Risk Theory for Actuaries</em>, Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code>discretize</code> to discretize a severity distribution;
<code>mean.aggregateDist</code> to compute the mean of the
distribution;
<code>quantile.aggregateDist</code> to compute the quantiles or the
Value-at-Risk;
<code>CTE.aggregateDist</code> to compute the Conditional Tail
Expectation (or Tail Value-at-Risk);
<code>rcomphierarc</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Convolution method (example 9.5 of Klugman et al. (2012))
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
pn &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.15, 0.06, 0.03, 0.01)
Fs &lt;- aggregateDist("convolution", model.freq = pn,
                    model.sev = fx, x.scale = 25)
summary(Fs)
c(Fs(0), diff(Fs(25 * 0:21))) # probability mass function
plot(Fs)

## Recursive method (example 9.10 of Klugman et al. (2012))
fx &lt;- c(0, crossprod(c(2, 1)/3,
                     matrix(c(0.6, 0.7, 0.4, 0, 0, 0.3), 2, 3)))
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 3)
plot(Fs)
Fs(knots(Fs))		      # cdf evaluated at its knots
diff(Fs)                      # probability mass function

## Recursive method (high frequency)
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
## Not run: Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 1000)
## End(Not run)
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 250, convolve = 2, maxit = 1500)
plot(Fs)

## Recursive method (zero-modified distribution; example 9.11 of
## Klugman et al. (2012))
Fn &lt;- aggregateDist("recursive", model.freq = "binomial",
                    model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
                    p0 = 0.4, size = 3, prob = 0.3)
diff(Fn)

## Equivalent but more explicit call
aggregateDist("recursive", model.freq = "zero-modified binomial",
              model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
              p0 = 0.4, size = 3, prob = 0.3)

## Recursive method (zero-truncated distribution). Using 'fx' above
## would mean that both Pr[N = 0] = 0 and Pr[X = 0] = 0, therefore
## Pr[S = 0] = 0 and recursions would not start.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "upper")
fx[1L] # non zero
aggregateDist("recursive", model.freq = "zero-truncated poisson",
              model.sev = fx, lambda = 3, x.scale = 25, echo=TRUE)

## Normal Power approximation
Fs &lt;- aggregateDist("npower", moments = c(200, 200, 0.5))
Fs(210)

## Simulation method
model.freq &lt;- expression(data = rpois(3))
model.sev &lt;- expression(data = rgamma(100, 2))
Fs &lt;- aggregateDist("simulation", nb.simul = 1000,
                    model.freq, model.sev)
mean(Fs)
plot(Fs)

## Evaluation of ruin probabilities using Beekman's formula with
## Exponential(1) claim severity, Poisson(1) frequency and premium rate
## c = 1.2.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "lower")
phi0 &lt;- 0.2/1.2
Fs &lt;- aggregateDist(method = "recursive", model.freq = "geometric",
                    model.sev = fx, prob = phi0)
1 - Fs(400)			# approximate ruin probability
u &lt;- 0:100
plot(u, 1 - Fs(u), type = "l", main = "Ruin probability")
</code></pre>


</div>