<div class="container">

<table style="width: 100%;"><tr>
<td>apcluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Affinity Propagation</h2>

<h3>Description</h3>

<p>Runs affinity propagation clustering
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'matrix,missing'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
    nonoise=FALSE, seed=NA)
## S4 method for signature 'dgTMatrix,missing'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=FALSE, details=FALSE,
    nonoise=FALSE, seed=NA)
## S4 method for signature 'sparseMatrix,missing'
apcluster(s, x, ...)
## S4 method for signature 'Matrix,missing'
apcluster(s, x, ...)
## S4 method for signature 'character,ANY'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
    nonoise=FALSE, seed=NA, ...)
## S4 method for signature 'function,ANY'
apcluster(s, x, p=NA, q=NA, maxits=1000,
    convits=100, lam=0.9, includeSim=TRUE, details=FALSE,
    nonoise=FALSE, seed=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>an <code class="reqn">l\times l</code> similarity matrix or a similarity
function either specified as the name of a package-provided
similarity function as character string or a user provided
function object. <code>s</code> may also be a sparse matrix according to
the <span class="pkg">Matrix</span> package. Internally, <code>apcluster</code> uses the
<code>dgTMatrix</code> class; all other sparse matrices are
cast to this class (if possible, otherwise the function quits with
an error). If <code>s</code> is any other object of class
<code>Matrix</code>, <code>s</code> is cast to a regular matrix
internally (if possible, otherwise the function quits with
an error).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input data to be clustered; if <code>x</code> is a matrix or data
frame, rows are interpreted as samples and columns are 
interpreted as features; apart from matrices or data frames, 
<code>x</code> may be any other structured data type that
contains multiple data items - provided that an appropriate
<code>length</code> function is available that
returns the number of items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>input preference; can be a vector that specifies
individual preferences for each data point. If scalar,
the same value is used for all data points. If <code>NA</code>,
exemplar preferences are initialized according to the
distribution of non-Inf values in <code>s</code>. How this
is done is controlled by the parameter <code>q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>if <code>p=NA</code>, exemplar preferences are initialized
according to the distribution of non-Inf values in <code>s</code>.
If <code>q=NA</code>, exemplar preferences are set to the median
of non-Inf values in <code>s</code>. If <code>q</code> is a value
between 0 and 1, the sample quantile with threshold
<code>q</code> is used, whereas <code>q=0.5</code> again results in
the median.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxits</code></td>
<td>
<p>maximal number of iterations that should be executed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convits</code></td>
<td>
<p>the algorithm terminates if the examplars have not
changed for <code>convits</code> iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam</code></td>
<td>
<p>damping factor; should be a value in the range [0.5, 1);
higher values correspond to heavy damping which may be
needed if oscillations occur</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includeSim</code></td>
<td>
<p>if <code>TRUE</code>, the similarity matrix (either computed
internally or passed via the <code>s</code> argument) is stored to the
slot <code>sim</code> of the returned
<code>APResult</code> object. The default is <code>FALSE</code>
if <code>apcluster</code> has been called for a similarity matrix,
otherwise the default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>details</code></td>
<td>
<p>if <code>TRUE</code>, more detailed information about the
algorithm's progress is stored in the output object
(see <code>APResult</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonoise</code></td>
<td>
<p><code>apcluster</code> adds a small amount of noise to
<code>s</code> to prevent degenerate cases; if <code>TRUE</code>,
this is disabled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>for reproducibility, the seed of the random number
generator can be set to a fixed value before
adding noise (see above), if <code>NA</code>, the seed remains
unchanged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for the methods with signatures <code>character,ANY</code> and
<code>function,ANY</code>, all other arguments are passed to the selected 
similarity function as they are; for the methods with signatures
<code>Matrix,missing</code> and <code>sparseMatrix,missing</code>, further
arguments are passed on to the <code>apcluster</code> methods with
signatures <code>Matrix,missing</code> and <code>dgTMatrix,missing</code>,
respectively.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Affinity Propagation clusters data using a set of
real-valued pairwise data point similarities as input. Each cluster
is represented by a cluster center data point (the so-called exemplar). 
The method is iterative and searches for clusters maximizing
an objective function called net similarity.
</p>
<p>When called with a similarity matrix as input (which may also be a
sparse matrix according to the <span class="pkg">Matrix</span> package), the function performs
AP clustering. When called with the name of a package-provided
similarity function or a user-provided similarity function object and 
input data, the function first computes the similarity matrix before
performing AP clustering. The similarity
matrix is returned for later use as part of the
<code>APResult</code>
object depending on whether <code>includeSim</code> was set to <code>TRUE</code> (see
argument description above).
</p>
<p>Apart from minor adaptations and optimizations, the AP
clustering functionality of the function <code>apcluster</code> is 
largely analogous to Frey's and Dueck's Matlab code
(see <a href="https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/">https://psi.toronto.edu/research/affinity-propagation-clustering-by-message-passing/</a>).
</p>
<p>The new argument <code>q</code> allows for better controlling the number of
clusters without knowing the distribution of similarity
values. A meaningful range for the parameter <code>p</code> can be determined
using the function <code>preferenceRange</code>. Alternatively, a
certain fixed number of clusters may be desirable. For this purpose,
the function <code>apclusterK</code> is available.
</p>


<h3>Value</h3>

<p>Upon successful completion, the function returns an
<code>APResult</code> object.
</p>


<h3>Author(s)</h3>

<p>Ulrich Bodenhofer, Andreas Kothmeier, Johannes Palme, and
Chrats Melkonian</p>


<h3>References</h3>

<p><a href="https://github.com/UBod/apcluster">https://github.com/UBod/apcluster</a>
</p>
<p>Frey, B. J. and Dueck, D. (2007) Clustering by passing messages
between data points. <em>Science</em> <b>315</b>, 972-976.
DOI: <a href="https://doi.org/10.1126/science.1136800">doi:10.1126/science.1136800</a>.
</p>
<p>Bodenhofer, U., Kothmeier, A., and Hochreiter, S. (2011)
APCluster: an R package for affinity propagation clustering.
<em>Bioinformatics</em> <b>27</b>, 2463-2464.
DOI: <a href="https://doi.org/10.1093/bioinformatics/btr406">doi:10.1093/bioinformatics/btr406</a>.
</p>


<h3>See Also</h3>

<p><code>APResult</code>, <code>show-methods</code>,
<code>plot-methods</code>, <code>labels-methods</code>,
<code>preferenceRange</code>, <code>apclusterL-methods</code>, 
<code>apclusterK</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## create two Gaussian clouds
cl1 &lt;- cbind(rnorm(100, 0.2, 0.05), rnorm(100, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(50, 0.7, 0.08), rnorm(50, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

## compute similarity matrix and run affinity propagation 
## (p defaults to median of similarity)
apres &lt;- apcluster(negDistMat(r=2), x, details=TRUE)

## show details of clustering results
show(apres)

## plot clustering result
plot(apres, x)

## plot heatmap
heatmap(apres)

## run affinity propagation with default preference of 10% quantile
## of similarities; this should lead to a smaller number of clusters
## reuse similarity matrix from previous run
apres &lt;- apcluster(s=apres@sim, q=0.1)
show(apres)
plot(apres, x)

## now try the same with RBF kernel
sim &lt;- expSimMat(x, r=2)
apres &lt;- apcluster(s=sim, q=0.2)
show(apres)
plot(apres, x)

## create sparse similarity matrix
cl1 &lt;- cbind(rnorm(20, 0.2, 0.05), rnorm(20, 0.8, 0.06))
cl2 &lt;- cbind(rnorm(20, 0.7, 0.08), rnorm(20, 0.3, 0.05))
x &lt;- rbind(cl1, cl2)

sim &lt;- negDistMat(x, r=2)
ssim &lt;- as.SparseSimilarityMatrix(sim, lower=-0.2)

## run apcluster() on the sparse similarity matrix
apres &lt;- apcluster(ssim, q=0)
apres
</code></pre>


</div>