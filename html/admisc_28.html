<div class="container">

<table style="width: 100%;"><tr>
<td>factorize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Factorize Boolean expressions</h2>

<h3>Description</h3>

<p>This function finds all combinations of common factors in a Boolean expression
written in SOP - sum of products. It makes use of the function
<b><code>simplify()</code></b>, which uses the function
<b><code>minimize()</code></b> from package <b><span class="pkg">QCA</span></b>). Users are
highly encouraged to install and load that package, despite not being present
in the Imports field (due to circular dependency issues).
</p>


<h3>Usage</h3>

<pre><code class="language-R">factorize(input, snames = "", noflevels = NULL, pos = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>A string representing a SOP expression, or a minimization
object of class <code>"qca"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>Logical, if possible factorize using product(s) of sums.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments (mainly for backwards compatibility).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Factorization is a process of finding common factors in a Boolean expression,
written in SOP - sum of products. Whenever possible, the factorization can also
be performed in a POS - product of sums form.
</p>
<p>Conjunctions should preferably be indicated with a star <code>*</code> sign, but this is not
necessary when conditions have single letters or when the expression is expressed in
multi-value notation.
</p>
<p>The argument <b><code>snames</code></b> is only needed when conjunctions are not indicated by
any sign, and the set names have more than one letter each (see function
<b><code>translate()</code></b> for more details).
</p>
<p>The number of levels in <b><code>noflevels</code></b> is needed only when negating multivalue
conditions, and it should complement the <b><code>snames</code></b> argument.
</p>
<p>If <b><code>input</code></b> is an object of class <code>"qca"</code> (the result of the
function <b><code>minimize()</code></b> from package <b><span class="pkg">QCA</span></b>), a
factorization is performed for each of the minimized solutions.
</p>


<h3>Value</h3>

<p>A named list, each component containing all possible factorizations of the input
expression(s), found in the name(s).
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, C.C. (1987) <em>The Comparative Method. Moving beyond qualitative
and quantitative strategies</em>, Berkeley: University of California Press
</p>


<h3>See Also</h3>

<p><code>translate</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# typical example with redundant conditions
factorize(a~b~cd + a~bc~d + a~bcd + abc~d)

# results presented in alphabetical order
factorize(~one*two*~four + ~one*three + three*~four)

# to preserve a certain order of the set names
factorize(~one*two*~four + ~one*three + three*~four,
          snames = c(one, two, three, four))

# using pos - products of sums
factorize(~a~c + ~ad + ~b~c + ~bd, pos = TRUE)

## Not run: 
# make sure the package QCA is loaded
library(QCA)

# using an object of class "qca" produced with function minimize()
# in package QCA

pCVF &lt;- minimize(CVF, outcome = "PROTEST", incl.cut = 0.8,
                 include = "?", use.letters = TRUE)

factorize(pCVF)

# using an object of class "deMorgan" produced with negate()
factorize(negate(pCVF))

## End(Not run)

</code></pre>


</div>