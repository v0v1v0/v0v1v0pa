<div class="container">

<table style="width: 100%;"><tr>
<td>importance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Importance Values of Variable
</h2>

<h3>Description</h3>

<p>This function calculates the relative importance of variables (w+) based
on the sum of Akaike weights (model probabilities) of the models that
include the variable.  Note that this measure of evidence is only
appropriate when the variable appears in the same number of models as
those that do not include the variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">importance(cand.set, parm, modnames = NULL, second.ord = TRUE,
           nobs = NULL, ...)

## S3 method for class 'AICaov.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICbetareg'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICsclm.clm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclmm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICclogit.coxph'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICcoxme'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICcoxph'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICglm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICglmerMod'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClmerModLmerTest'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICglmmTMB'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICgls'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClme'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AIClmekin'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICmaxlikeFit.list'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICmer'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICmultinom.nnet'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICnegbin.glm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICnlmerMod'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICpolr'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICrlm.lm'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICsurvreg'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccu'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitMMO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICunmarkedFitDSO'
importance(cand.set, parm, modnames = NULL,
           second.ord = TRUE, nobs = NULL, c.hat = 1, parm.type = NULL,
       ...)

## S3 method for class 'AICvglm'
importance(cand.set, parm, modnames = NULL, 
           second.ord = TRUE, nobs = NULL, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
importance(cand.set, parm, modnames = NULL, 
           second.ord = TRUE, nobs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>

<p>the parameter of interest for which a measure of relative importance is
required. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models.  If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical. If <code>TRUE</code>, the function returns the second-order Akaike 
information criterion (i.e., AICc). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.  In
such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>importance</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the variable of interest will be extracted and is only relevant for
models of <code>unmarkedFit</code> classes.  The character strings supported
vary with the type of model fitted.  For <code>unmarkedFitOccu</code> and
<code>unmarkedFitOccuMulti</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is on
occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>, 
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.  For
<code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code> are
supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detection
probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>importance</code> returns an object of class <code>importance</code>
consisting of the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>the parameter for which an importance value is required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.plus</code></td>
<td>
<p>the sum of Akaike weights for the models that include the
parameter of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.minus</code></td>
<td>
<p>the sum of Akaike weights for the models that exclude the
parameter of interest.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Burnham, K. P., and Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>, 
108–115.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>c_hat</code>,
<code>confset</code>, <code>evidence</code>, <code>modavg</code>, 
<code>modavgShrink</code>, <code>modavgPred</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">##example on Orthodont data set in nlme
## Not run: 
require(nlme)

##set up candidate model list
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method = "ML")
##random is ~ age | Subject
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont, random = ~ 1,
                        method = "ML") 
Cand.models[[4]] &lt;- lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                        method = "ML") 

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

importance(cand.set = Cand.models, parm = "age", modnames = Modnames,
           second.ord = TRUE, nobs = NULL)
##round to 4 digits after decimal point
print(importance(cand.set = Cand.models, parm = "age", modnames = Modnames,
                 second.ord = TRUE, nobs = NULL), digits = 4)
detach(package:nlme)

## End(Not run)


##single-season occupancy model example modified from ?occu
## Not run: 
require(unmarked)
##single season
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)),
                                sitevar2 = rnorm(numSites(pferUMF))) 
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) *
                                 obsNum(pferUMF))) 

##set up candidate model set
fm1 &lt;- occu(~ obsvar1 ~ sitevar1, pferUMF)
fm2 &lt;- occu(~ 1 ~ sitevar1, pferUMF)
fm3 &lt;- occu(~ obsvar1 ~ sitevar2, pferUMF)
fm4 &lt;- occu(~ 1 ~ sitevar2, pferUMF)
Cand.mods &lt;- list(fm1, fm2, fm3, fm4)
Modnames &lt;- c("fm1", "fm2", "fm3", "fm4")

##compute importance value for 'sitevar1' on occupancy
importance(cand.set = Cand.mods, modnames = Modnames, parm = "sitevar1",
           parm.type = "psi")
##compute importance value for 'obsvar1' on detectability
importance(cand.set = Cand.mods, modnames = Modnames, parm = "obsvar1",
           parm.type = "detect")


##example with multispecies occupancy modify from ?occuMulti
##Simulate 3 species data
N &lt;- 80
nspecies &lt;- 3
J &lt;- 4
     
occ_covs &lt;- as.data.frame(matrix(rnorm(N * 10),ncol=10))
names(occ_covs) &lt;- paste('par',1:10,sep='')

det_covs &lt;- list()
for (i in 1:nspecies){
    det_covs[[i]] &lt;- matrix(rnorm(N*J),nrow=N)
}
names(det_covs) &lt;- paste('par',1:nspecies,sep='')

##True vals
beta &lt;- c(0.5,0.2,0.4,0.5,-0.1,-0.3,0.2,0.1,-1,0.1)
f1 &lt;- beta[1] + beta[2]*occ_covs$par1
f2 &lt;- beta[3] + beta[4]*occ_covs$par2
f3 &lt;- beta[5] + beta[6]*occ_covs$par3
f4 &lt;- beta[7]
f5 &lt;- beta[8]
f6 &lt;- beta[9]
f7 &lt;- beta[10]
f &lt;- cbind(f1,f2,f3,f4,f5,f6,f7)
z &lt;- expand.grid(rep(list(1:0),nspecies))[,nspecies:1]
colnames(z) &lt;- paste('sp',1:nspecies,sep='')
dm &lt;- model.matrix(as.formula(paste0("~.^",nspecies,"-1")),z)

psi &lt;- exp(f 
psi &lt;- psi/rowSums(psi)

##True state
ztruth &lt;- matrix(NA,nrow=N,ncol=nspecies)
for (i in 1:N){
    ztruth[i,] &lt;- as.matrix(z[sample(8,1,prob=psi[i,]),])
}
     
p_true &lt;- c(0.6,0.7,0.5)

## fake y data
y &lt;- list()
     
for (i in 1:nspecies){
    y[[i]] &lt;- matrix(NA,N,J)
    for (j in 1:N){
        for (k in 1:J){
            y[[i]][j,k] &lt;- rbinom(1,1,ztruth[j,i]*p_true[i])
        }
    }
}
names(y) &lt;- c('coyote','tiger','bear')
     
##Create the unmarked data object
data &lt;- unmarkedFrameOccuMulti(y=y,siteCovs=occ_covs,obsCovs=det_covs)

## Formulas for state and detection processes
## Length should match number/order of columns in fDesign
occFormulas &lt;- c('~par1 + par2','~par2','~par3','~1','~1','~1','~1')
occFormulas2 &lt;- c('~par1 + par3','~par1 + par2','~par1 + par2 + par3',
                  "~ 1", "~1", "~ 1", "~1")

##Length should match number/order of species in data@ylist
detFormulas &lt;- c('~1','~1','~1')
     
fit &lt;- occuMulti(detFormulas,occFormulas,data)
fit2 &lt;- occuMulti(detFormulas,occFormulas2,data)

##importance
importance(cand.set = list(fit, fit2), parm = "[coyote] par2",
           parm.type = "psi")


detach(package:unmarked)

## End(Not run)
</code></pre>


</div>