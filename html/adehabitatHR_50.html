<div class="container">

<table style="width: 100%;"><tr>
<td>kernelUD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of Kernel Home-Range</h2>

<h3>Description</h3>

<p>The function <code>kernelUD</code> estimates the UD of one or several
animals.
</p>
<p><code>plotLSCV</code> allows to explore the results of the least-square
cross-validation algorithm used to find the best smoothing value.
</p>
<p><code>image</code> allows a graphical display of the estimates.
</p>
<p><code>getvolumeUD</code> and <code>kernel.area</code> provide utilities
for home range and home-range size estimation.
</p>
<p><code>getverticeshr</code> stores the home range contour as an object of
class <code>SpatialPolygonsDataFrame</code> (package sp), with one row per
animal.
</p>
<p><code>estUDm2spixdf</code> can be used to convert the result into an object
of class <code>SpatialPixelsDataFrame</code>
</p>
<p><code>as.data.frame.estUD</code> can be used to convert an object of class
<code>estUD</code> as a data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
kernelUD(xy, h = "href", grid = 60,
         same4all = FALSE, hlim = c(0.1, 1.5),
         kern = c("bivnorm", "epa"), extent = 1,
         boundary = NULL)

## S3 method for class 'estUDm'
print(x, ...)

## S3 method for class 'estUD'
image(x, ...)

## S3 method for class 'estUDm'
image(x, ...)

## S3 method for class 'estUD'
as.data.frame(x, row.names, optional, ...)

plotLSCV(x)

getvolumeUD(x, standardize = FALSE)

kernel.area(x, percent = seq(20, 95, by = 5),
            unin = c("m", "km"),
            unout = c("ha", "km2", "m2"), standardize = FALSE)

estUDm2spixdf(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xy</code></td>
<td>
<p>An object inheriting the class <code>SpatialPoints</code>
containing the x and y relocations of the animal.  If <code>xy</code>
inherits the class <code>SpatialPointsDataFrame</code>, it should contain
only one column (factor) corresponding to the identity of the
animals for each relocation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>a character string or a number.  If <code>h</code> is set to
<code>"href"</code>, the ad hoc method is used for the smoothing parameter
(see details).  If <code>h</code> is set to 
<code>"LSCV"</code>, the least-square cross validation method is
used. Note that <code>"LSCV"</code> is not available if <code>kern = "epa"</code>. 
Alternatively, <code>h</code> may be set to any given numeric value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a number giving the size of the grid on
which the UD should be estimated.  Alternatively, this parameter may
be an object inheriting the class <code>SpatialPixels</code>, that will be
used for all animals.  For the function <code>kernelUD</code>, it may in
addition be a list of objects of class <code>SpatialPixels</code>, with
named elements corresponding to each level of the factor id.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hlim</code></td>
<td>
<p>a numeric vector of length two.  If <code>h = "LSCV"</code>,
the function minimizes the cross-validation criterion for values of
h ranging from <code>hlim[1]*href</code> to <code>hlim[2]*href</code>, where
<code>href</code> is the smoothing parameter computed with the ad hoc
method (see below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kern</code></td>
<td>
<p>a character string.  If <code>"bivnorm"</code>, a bivariate
normal kernel is used.  If <code>"epa"</code>, an Epanechnikov kernel is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extent</code></td>
<td>
<p>a value controlling the extent of the grid used for the
estimation (the extent of the grid on the abscissa is equal to
<code>(min(abscissa.relocations) + extent *
      diff(range(abscissa.relocations)))</code>, and similarly for the ordinate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same4all</code></td>
<td>
<p>logical. If <code>TRUE</code>, the same grid
is used for all animals.  If <code>FALSE</code>, one grid per
animal is used.  Note that when <code>same4all = TRUE</code>, the grid
used for the estimation is calculated by the function (so that the
parameter <code>grid</code> cannot be a <code>SpatialPixels</code> object).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>If, not <code>NULL</code>, an object inheriting the class
<code>SpatialLines</code> defining a barrier that cannot be crossed by the
animals.  There are constraints on the shape of the barrier that
depend on the smoothing parameter <code>h</code> (***see details***)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>estUD</code> (UD for one animal) or
<code>estUDm</code> (UD for several animals).  For the 
function <code>estUDm2spixdf</code>, an object of class <code>estUDm</code>
only.  For the function <code>as.data.frame.estUD</code>, an object of
class <code>estUD</code> only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percent</code></td>
<td>
<p>for <code>kernel.area</code>, a vector of percentage levels
for home-range size estimation.  For <code>getverticeshr</code>, a single
value giving the percentage level for home-range estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>a logical value indicating whether the UD should be
standardized over the area of interest, so that the volume under the
UD and *over the area* is equal to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unin</code></td>
<td>
<p>the units of the relocations coordinates.  Either <code>"m"</code> for
meters (default) or <code>"km"</code> for kilometers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unout</code></td>
<td>
<p>the units of the output areas.  Either <code>"m2"</code> for
square meters, <code>"km2"</code> for square kilometers or <code>"ha"</code> for
hectares (default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p>unused argument here</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>unused argument here</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additionnal parameters to be passed to the generic
functions <code>print</code> and <code>image</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Utilization Distribution (UD) is the bivariate function giving the
probability density that an animal is found at a point according to
its geographical coordinates.  Using this model, one can define 
the home range as the minimum area in which an animal has some
specified probability of being located. The
functions used here correspond to the approach described in Worton
(1995).
</p>
<p>The kernel method has been recommended by many authors for the
estimation of the utilization distribution (e.g. Worton, 1989, 1995).
The default method for the estimation of the
smoothing parameter is the <em>ad hoc</em> method, i.e. for a bivariate
normal kernel
</p>
<p style="text-align: center;"><code class="reqn">h = \sigma n^{- \frac{1}{6}}</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\sigma^2 = 0.5 (var(x)+var(y))</code>
</p>
<p> which supposes that the UD is
bivariate normal.  If an Epanechnikov kernel is used, this value is
multiplied by 1.77 (Silverman, 1986, p. 86).
Alternatively, the smoothing parameter h may be
computed by Least Square Cross Validation (LSCV).  The estimated value
then minimizes the Mean Integrated Square Error (MISE), i.e. the
difference in volume between the true UD and the estimated UD.  Note
that the cross-validation criterion cannot be minimized in some
cases.  According to Seaman and Powell (1998) <em>"This is a
difficult problem that has not been worked out by statistical
theoreticians, so no definitive response is available at this
time"</em> (see Seaman and Powell, 1998 for further details and tricky
solutions).  <code>plotLSCV</code> allows to have a diagnostic of the
success of minimization of the cross validation criterion (i.e. to
know whether the minimum of the CV criterion occurs within the scanned
range).  Finally, the UD is then estimated over a grid.
</p>
<p>The default kernel is the bivariate normal kernel, but the
Epanechnikov kernel, which requires less computer time is also
available for the estimation of the UD.
</p>
<p>The function <code>getvolumeUD</code> modifies the UD component of the
object passed as argument: that the pixel values of the resulting
object are equal to the percentage of the smallest home range
containing this pixel.  This function is used in the function
<code>kernel.area</code>, to compute the home-range size.  Note, that the
function <code>plot.hrsize</code> (see the help page of this  function) can
be used to display the home-range size estimated at various levels.
</p>
<p>The parameter <code>boundary</code> allows to define a barrier that cannot
be crossed by the animals.  When this parameter is
set, the method described by Benhamou and Cornelis (2010) for
correcting boundary biases is used.  The boundary can possibly be
defined by several nonconnected lines, each one being built by several
connected segments. Note that there are constraints on these segments
(not all kinds of boundary can be defined): (i) each segment length
should at least be equal to <code>3*h</code> (the size of "internal lane"
according to the terminology of Benhamou and Cornelis), (ii) the angle
between two line segments should be greater that <code>pi/2</code> or lower
that <code>-pi/2</code>.  The UD of all the pixels located within a
band defined by the boundary and with a width equal to <code>6*h</code>
("external lane") is set to zero.
</p>


<h3>Value</h3>

<p>The function <code>kernelUD</code> returns either: (i) an object belonging
to the S4 class <code>estUD</code> (see <code>?estUD-class</code>) when the object
<code>xy</code> passed as argument contains the relocations of only one
animal (i.e., belong to the class <code>SpatialPoints</code>), or (ii) a
list of elements of class <code>estUD</code> when the object
<code>xy</code> passed as argument contains the relocations of several
animals (i.e., belong to the class <code>SpatialPointsDataFrame</code>).
</p>
<p>The function <code>getvolumeUD</code> returns an object of the same class as
the object passed as argument (<code>estUD</code> or <code>estUDm</code>). 
</p>
<p><code>kernel.area</code> returns a data frame of subclass <code>hrsize</code>,
with one column per animal and one row per level of
estimation of the home range.
</p>
<p><code>getverticeshr</code> returns an object of class
<code>SpatialPolygonsDataFrame</code>.
</p>
<p><code>estUDm2spixdf</code> returns an object of class
<code>SpatialPixelsDataFrame</code>.
</p>


<h3>Author(s)</h3>

<p> Clement Calenge <a href="mailto:clement.calenge@ofb.gouv.fr">clement.calenge@ofb.gouv.fr</a> </p>


<h3>References</h3>

<p>Silverman, B.W. (1986)
<em>Density estimation for statistics and data
analysis</em>. London: Chapman and Hall.
</p>
<p>Worton, B.J. (1989) Kernel methods for estimating the utilization
distribution in home-range studies. <em>Ecology</em>, <b>70</b>, 164–168.
</p>
<p>Worton, B.J. (1995) Using Monte Carlo simulation to evaluate
kernel-based home range estimators. <em>Journal of Wildlife Management</em>,
<b>59</b>,794–800.
</p>
<p>Seaman, D.E. and Powell, R.A. (1998) <em>Kernel home range estimation
program (kernelhr)</em>. Documentation of the
program.
</p>
<p>Benhamou, S. and Cornelis, D. (2010) Incorporating Movement Behavior
and Barriers to Improve Biological Relevance of Kernel Home Range
Space Use Estimates. <em>Journal of Wildlife Management</em>, <b>74</b>,
1353–1360.
</p>


<h3>See Also</h3>

<p><code>mcp</code> for help on the function <code>plot.hrsize</code>. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Load the data
data(puechabonsp)
loc &lt;- puechabonsp$relocs

## have a look at the data
head(as.data.frame(loc))
## the first column of this data frame is the ID


## Estimation of UD for the four animals
(ud &lt;- kernelUD(loc[,1]))

## The UD of the four animals
image(ud)

## Calculation of the 95 percent home range
ver &lt;- getverticeshr(ud, 95)

## and display on an elevation map:
elev &lt;- puechabonsp$map
image(elev, 1)
plot(ver, add=TRUE, col=rainbow(4))
legend(699000, 3165000, legend = names(ud), fill = rainbow(4))

## Example of estimation using LSCV
udbis &lt;- kernelUD(loc[,1], h = "LSCV")
image(udbis)


## Compare the estimation with ad hoc and LSCV method
## for the smoothing parameter
(cuicui1 &lt;- kernel.area(ud)) ## ad hoc
plot(cuicui1)
(cuicui2 &lt;- kernel.area(udbis)) ## LSCV
plot(cuicui2)

## Diagnostic of the cross-validation
plotLSCV(udbis)



## Use of the same4all argument: the same grid
## is used for all animals
## BTW, we indicate a grid with a fine resolution:
udbis &lt;- kernelUD(loc[,1], same4all = TRUE, grid = 100)
image(udbis)


## Estimation of the UD on a map
## (e.g. for subsequent analyses on habitat selection)
## Measures the UD in each pixel of the map
udbis &lt;- kernelUD(loc[,1], grid = elev)
image(udbis)


##########################################
##
## Estimating the UD with the presence of a barrier
## The boars are located on the plateau of Puechabon (near
## Montpellier, France), and their movements are limited by the
## Herault river.

## We first map the elevation:
image(elev)

## Then, we used the function locator() to identify the limits of the
## segments of this barrier. BEWARE! The boundary should satisfy the two
## constraints: (i) segment length &gt; 3*h, (ii) no angle lower than pi/2
## between successive segments. We choose a smoothing parameter of 100
## m, so that no segment length should be less than 300 m.
## Because the resolution of the map is 100 m, this means that no
## segment should cover less than 3 pixels. We have used the function
## locator() to digitize this barrier and then the function dput to
## have the following limits:

bound &lt;- structure(list(x = c(701751.385381925, 701019.24105475,
                        700739.303517889,
                        700071.760160759, 699522.651915378,
                        698887.40904327, 698510.570051342,
                        698262.932999504, 697843.026694212,
                        698058.363261028),
                        y = c(3161824.03387414,
                        3161824.03387414, 3161446.96718494,
                        3161770.16720425, 3161479.28718687,
                        3161231.50050539, 3161037.5804938,
                        3160294.22044937, 3159389.26039528,
                        3157482.3802813)), .Names = c("x", "y"))

lines(bound, lwd=3)

## We convert bound to SpatialLines:
bound &lt;- do.call("cbind",bound)
Slo1 &lt;- Line(bound)
Sli1 &lt;- Lines(list(Slo1), ID="frontier1")
barrier &lt;- SpatialLines(list(Sli1))

## estimation of the UD
kud &lt;- kernelUD(loc[,1], h=100, grid=100, boundary=barrier)

## Result:
image(kud)

## Have a closer look to Calou:
kud2 &lt;- kud[[2]]
image(kud2, col=grey(seq(1,0,length=15)))
title(main="Home range of Calou")
points(loc[slot(loc,"data")[,1]=="Calou",], pch=3, col="blue")
plot(getverticeshr(kud2, 95), add=TRUE, lwd=2)
lines(barrier, col="red", lwd=3)



</code></pre>


</div>