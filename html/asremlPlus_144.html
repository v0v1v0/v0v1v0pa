<div class="container">

<table style="width: 100%;"><tr>
<td>renewClassify.alldiffs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Renews the components in an <code>alldiffs.object</code> according to a new classify.</h2>

<h3>Description</h3>

<p>The <code>classify</code> is an attribute of an <code>alldiffs.object</code> and determines 
the order within the components of an unsorted <code>alldiffs.object</code>. 
This function resets the <code>classify</code> attribute and re-orders the components of 
<code>alldiffs.object</code> to be in standard order for the variables in a 
<code>newclassify</code>, using <code>allDifferences.data.frame</code>. The <code>newclassify</code> 
may be just a re-ordering of the variable names in the previous <code>classify</code>, or be 
based on a new set of variable names. The latter is particularly useful when 
<code>linTransform.alldiffs</code> has been used with a <code>matrix</code> and it 
is desired to replace the resulting <code>Combination</code> <code>classify</code> with a 
<code>newclassify</code> comprised of a more meaningful set of variables; first replace 
<code>Combination</code> in the <code>predictions</code> component with the new set of variables 
and then call <code>renewClassify</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'alldiffs'
renewClassify(alldiffs.obj, newclassify, 
              sortFactor = NULL, sortParallelToCombo = NULL, 
              sortNestingFactor = NULL, sortOrder = NULL, decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alldiffs.obj</code></td>
<td>
<p>An <code>alldiffs.object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newclassify</code></td>
<td>
<p>A <code>character</code> string giving the variables that 
define the margins of the multiway table that was predicted, 
but ordered so that the predictions are in the desired order when they are 
arranged in standard order for the <code>newclassify</code>. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator. The number of combined values of the 
set of variable name(s) must equal the number of rows in the <code>predictions</code> 
component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortFactor</code></td>
<td>
<p>A <code>character</code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortParallelToCombo</code></td>
<td>
<p>A <code>list</code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code>list</code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortNestingFactor</code></td>
<td>
<p>A <code>character</code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortOrder</code></td>
<td>
<p>A <code>character</code> vector whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code>alldiffs.object</code>. It specifies the desired order of the 
levels in the reordered components of the <code>alldiffs.object</code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order is for increasing or decreasing magnitude of the predicted 
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to <code>allDifferences.data.frame</code>; 
attributes <code>tranform.power</code>, <code>offset</code> and <code>scale</code> cannot be passed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First, the components of the <code>alldiffs.object</code> is arranged in standard order for
the <code>newclassify</code>. Then predictions are reordered according to the settings of 
<code>sortFactor</code>, <code>sortParallelToCombo</code>, <code>sortOrder</code> and <code>decreasing</code> (see 
<code>sort.alldiffs</code> for details).</p>


<h3>Value</h3>

<p>The <code>alldiffs.object</code> supplied with the following components, 
if present, sorted: <code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code> and <code>sed</code>. Also, the <code>sortFactor</code> and <code>sortOrder</code> 
attributes are set.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>as.alldiffs</code>, <code>allDifferences.data.frame</code>, 
<code>print.alldiffs</code>, <code>sort.alldiffs</code>, <br><code>redoErrorIntervals.alldiffs</code>, <code>recalcLSD.alldiffs</code>,  <br><code>predictPlus.asreml</code>, <code>predictPresent.asreml</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
#Analyse pH  
m1.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(m1.asr, NULL, NULL)
current.asrt &lt;- as.asrtests(m1.asr)
current.asrt &lt;- rmboundary(current.asrt)
m1.asr &lt;- current.asrt$asreml.obj

#Get predictions and associated statistics  
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = m1.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  #Analyse pH
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, 
                               classify = "Sources:Type", 
                               vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

#Re-order predictions from asreml or lmerTest so all Sources for the same Type are together 
#for each combination of A and B
if (exists("TS.diffs"))
{
  TS.diffs.reord &lt;- renewClassify(TS.diffs, newclassify = "Type:Sources")
  validAlldiffs(TS.diffs.reord)
}
</code></pre>


</div>