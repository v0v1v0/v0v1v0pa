<div class="container">

<table style="width: 100%;"><tr>
<td>modavg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model-averaged Parameter Estimate (Multimodel Inference)
</h2>

<h3>Description</h3>

<p>This function model-averages the estimate of a parameter of interest
among a set of candidate models, computes the unconditional standard
error and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002).  This model-averaged estimate
is also referred to as a natural average of the estimate by Burnham and
Anderson (2002, p. 152).
</p>


<h3>Usage</h3>

<pre><code class="language-R">modavg(cand.set, parm, modnames = NULL, second.ord = TRUE, nobs = NULL, 
       uncond.se = "revised", conf.level = 0.95, exclude = NULL, warn =
       TRUE, ...) 

## S3 method for class 'AICaov.lm'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICbetareg'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICsclm.clm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICclm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICclmm'
modavg(cand.set, parm, modnames = NULL, second.ord 
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICcoxme'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICcoxph'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICglm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        gamdisp = NULL, ...)

## S3 method for class 'AICglmmTMB'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICgls'
modavg(cand.set, parm, modnames = NULL, second.ord =
           TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
           exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIChurdle'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClm'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClme'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmekin'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICmaxlikeFit.list'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICmer'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmerMod'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AIClmerModLmerTest'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICglmerMod'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICmultinom.nnet'
modavg(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        ...)

## S3 method for class 'AICnegbin.glm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICpolr'
modavg(cand.set, parm, modnames = NULL, second.ord
        = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICrlm.lm'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICsurvreg'
modavg(cand.set, parm, modnames = NULL, second.ord =
        TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
        exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICvglm'
modavg(cand.set, parm, modnames = NULL, second.ord
         = TRUE, nobs = NULL, uncond.se = "revised", conf.level = 0.95,
         exclude = NULL, warn = TRUE, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
modavg(cand.set, parm, modnames = NULL,
         second.ord = TRUE, nobs = NULL, uncond.se = "revised",
         conf.level = 0.95, exclude = NULL, warn = TRUE, ...)

## S3 method for class 'AICunmarkedFitOccu'
modavg(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavg(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavg(cand.set, parm, modnames =
       NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
       conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
       parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavg(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, exclude = NULL, warn = TRUE, c.hat = 1,
        parm.type = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>

<p>the parameter of interest, enclosed between quotes, for which a
model-averaged estimate is required.  For a categorical variable, 
the label of the estimate must be included as it appears in the output
(see 'Details' below). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of 
observations).  This is relevant only for mixed models or various models
of <code>unmarkedFit</code> classes where sample size is not straightforward.
In such cases, one might use total number of observations or number of
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>

<p>this argument excludes models based on the terms specified for the 
computation of a model-averaged estimate of <code>parm</code>.  The
<code>exclude</code> argument is set to <code>NULL</code> by default and does not
exclude any models other than those without the <code>parm</code>.  When
<code>parm</code> is a main effect but is also involved in
interactions/polynomial terms in some models, one should specify the
interaction/polynomial terms as a list to exclude models with these
terms from the computation of model-averaged estimate of the main effect
(e.g., <code>exclude = list("sex:mass", "mass2")</code>).  See 'Details' 
and 'Examples' below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>

<p>logical.  If <code>TRUE</code>, <code>modavg</code> performs a check and isssues a
warning when the value in <code>parm</code> occurs more than once in any given
model.  This is a check for potential interaction/polynomial terms in
the model when such terms are constructed with the usual operators
(e.g., <code>I( )</code> for polynomial terms, <code>:</code> for interaction
terms).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>modavg</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the model-averaged estimate of a predictor will be computed and is
only relevant for models of <code>unmarkedFit</code> classes.  The character
strings supported vary with the type of model fitted.  For
<code>unmarkedFitOccu</code> and <code>unmarkedFitOccuMulti</code> objects, either
<code>psi</code> or <code>detect</code> can be supplied to indicate whether the
parameter is on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.  For
<code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code> are
supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detection
probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter for which a model-averaged estimate is requested must be
specified with the <code>parm</code> argument and must be identical to its
label in the model output (e.g., from <code>summary</code>).  For factors, one
must specify the name of the variable and the level of interest.
<code>modavg</code> includes checks to find variations of interaction terms
specified in the <code>parm</code> and <code>exclude</code> arguments.  However, to
avoid problems, one should specify interaction terms consistently for
all models: e.g., either <code>a:b</code> or <code>b:a</code> for all models, but
not a mixture of both. 
</p>
<p>You must exercise caution when some models include interaction or
polynomial terms, because main effect terms do not have the same
interpretation when they also appear in an interaction/polynomial term
in the same model.  In such cases, one should exclude models containing 
interaction terms where the main effect is involved with the
<code>exclude</code> argument of <code>modavg</code>.  Note that <code>modavg</code>
checks for potential cases of multiple instances of a variable appearing
more than once in a given model (presumably in an interaction) and
issues a warning.  To correctly compute the model-averaged estimate of a
main effect involved in interaction/polynomial terms, specify the
interaction terms(s) that should not appear in the same model with the
<code>exclude</code> argument.  This will effectively exclude models from the
computation of the model-averaged estimate.  
</p>
<p>When <code>warn = TRUE</code>, <code>modavg</code> looks for matches among the
labels of the estimates with <code>identical</code>.  It then compares the
results to partial matches with <code>regexpr</code>, and issues a warning
whenever they are different.  As a result, <code>modavg</code> may issue a
warning when some variables or levels of categorical variables have
nested names (e.g., <code>treat</code>, <code>treat10</code>; <code>L</code>, <code>TL</code>).
When this warning is only due to the presence of similarly named
variables in the models (and NOT due to interaction terms), you can
suppress this warning by setting <code>warn = FALSE</code>.
</p>
<p>The model-averaging estimator implemented in <code>modavg</code> is known to
be biased away from 0 when there is substantial model selection
uncertainty (Cade 2015).  In such instances, it is recommended to use
the model-averaging shrinkage estimator (i.e., <code>modavgShrink</code>) for
inference on beta estimates or to focus on model-averaged effect sizes
(<code>modavgEffect</code>) and model-averaged predictions
(<code>modavgPred</code>).
</p>
<p><code>modavg</code> is implemented for a list containing objects of
<code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>clmm</code>, <code>clogit</code>,
<code>coxme</code>, <code>coxph</code>, <code>glm</code>, <code>glmmTMB</code>, <code>gls</code>,
<code>hurdle</code>, <code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>,
<code>mer</code>, <code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>,
<code>multinom</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>,
<code>zeroinfl</code> classes as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Value</h3>

<p><code>modavg</code> creates an object of class <code>modavg</code> with the following
components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Parameter</code></td>
<td>
<p>the parameter for which a model-averaged estimate was
obtained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.table</code></td>
<td>
<p>the reduced model selection table based on models
including the parameter of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.beta</code></td>
<td>
<p>the model-averaged estimate based on all models
including the parameter of interest (see 'Details' above regarding the
exclusion of models where parameter of interest is involved in an
interaction).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate (as opposed to the conditional SE based on a single model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603–618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261–304.
</p>
<p>Cade, B. S. (2015) Model averaging and muddled multimodel
inferences. <em>Ecology</em> <b>96</b>, 2370–2382. 
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67–118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169–180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>c_hat</code>,
<code>confset</code>, <code>evidence</code>, <code>importance</code>,
<code>modavgCustom</code>, <code>modavgEffect</code>,
<code>modavgShrink</code>, <code>modavgPred</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">##anuran larvae example modified from Mazerolle (2006)
##these are different models than in the paper
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter +
                     Type:log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort),
                     data = min.trap)
##interactive model
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + log.Perimeter +
                     Type:log.Perimeter, family = poisson, 
                     offset = log(Effort), data = min.trap)
##additive model
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type + log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap)
##Predator model
Cand.mod[[4]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df
##note the very low overdispersion: in this case, the analysis could be
##conducted without correcting for c-hat as its value is reasonably close
##to 1  

##assign names to each model
Modnames &lt;- c("global model", "interactive model",
              "additive model", "invertpred model") 

##model selection
aictab(Cand.mod, Modnames)

##compute model-averaged estimates for parameters appearing in top
##models
modavg(parm = "Num_ranatra", cand.set = Cand.mod, modnames = Modnames)
##round to 4 digits after decimal point
print(modavg(parm = "Num_ranatra", cand.set = Cand.mod,
             modnames = Modnames), digits = 4)

##model-averaging a variable involved in an interaction
##the following produces an error - because the variable is involved
##in an interaction in some candidate models
## Not run: modavg(parm = "TypeBOG", cand.set = Cand.mod,
         modnames = Modnames)
## End(Not run)


##exclude models where the variable is involved in an interaction
##to get model-averaged estimate of main effect
modavg(parm = "TypeBOG", cand.set = Cand.mod, modnames = Modnames,
       exclude = list("Type:log.Perimeter"))

##to get model-averaged estimate of interaction
modavg(parm = "TypeBOG:log.Perimeter", cand.set = Cand.mod,
       modnames = Modnames)



##beware of variables that have similar names
set.seed(seed = 4)
resp &lt;- rnorm(n = 40, mean = 3, sd = 1)
size &lt;- rep(c("small", "medsmall", "high", "medhigh"), times = 10)
set.seed(seed = 4)
mass &lt;- rnorm(n = 40, mean = 2, sd = 0.1)
mass2 &lt;- mass^2
age &lt;- rpois(n = 40, lambda = 3.2)
agecorr &lt;- rpois(n = 40, lambda = 2) 
sizecat &lt;- rep(c("a", "ab"), times = 20)
data1 &lt;- data.frame(resp = resp, size = size, sizecat = sizecat,
                    mass = mass, mass2 = mass2, age = age,
                    agecorr = agecorr)

##set up models in list
Cand &lt;- list( )
Cand[[1]] &lt;- lm(resp ~ size + agecorr, data = data1)
Cand[[2]] &lt;- lm(resp ~ size + mass + agecorr, data = data1)
Cand[[3]] &lt;- lm(resp ~ age + mass, data = data1)
Cand[[4]] &lt;- lm(resp ~ age + mass + mass2, data = data1)
Cand[[5]] &lt;- lm(resp ~ mass + mass2 + size, data = data1)
Cand[[6]] &lt;- lm(resp ~ mass + mass2 + sizecat, data = data1)
Cand[[7]] &lt;- lm(resp ~ sizecat, data = data1)
Cand[[8]] &lt;- lm(resp ~ sizecat + mass + sizecat:mass, data = data1)
Cand[[9]] &lt;- lm(resp ~ agecorr + sizecat + mass + sizecat:mass,
                 data = data1) 

##create vector of model names
Modnames &lt;- paste("mod", 1:length(Cand), sep = "")

aictab(cand.set = Cand, modnames = Modnames, sort = TRUE) #correct

##as expected, issues warning as mass occurs sometimes with "mass2" or
##"sizecatab:mass" in some of the models
## Not run: modavg(cand.set = Cand, parm = "mass", modnames = Modnames)

##no warning issued, because "age" and "agecorr" never appear in same model
modavg(cand.set = Cand, parm = "age", modnames = Modnames)

##as expected, issues warning because warn=FALSE, but it is a very bad
##idea in this example since "mass" occurs with "mass2" and "sizecat:mass"
##in some of the models - results are INCORRECT
## Not run: modavg(cand.set = Cand, parm = "mass", modnames = Modnames,
                warn = FALSE)
## End(Not run)

##correctly excludes models with quadratic term and interaction term
##results are CORRECT
modavg(cand.set = Cand, parm = "mass", modnames = Modnames,
       exclude = list("mass2", "sizecat:mass")) 

##correctly computes model-averaged estimate because no other parameter
##occurs simultaneously in any of the models
modavg(cand.set = Cand, parm = "sizesmall", modnames = Modnames) #correct

##as expected, issues a warning because "sizecatab" occurs sometimes in
##an interaction in some models
## Not run: modavg(cand.set = Cand, parm = "sizecatab",
                modnames = Modnames) 
## End(Not run)

##exclude models with "sizecat:mass" interaction - results are CORRECT
modavg(cand.set = Cand, parm = "sizecatab", modnames = Modnames,
       exclude = list("sizecat:mass"))



##example with multiple-season occupancy model modified from ?colext
##this is a bit longer
## Not run: 
require(unmarked)
data(frogs)
umf &lt;- formatMult(masspcru)
obsCovs(umf) &lt;- scale(obsCovs(umf))
siteCovs(umf) &lt;- rnorm(numSites(umf))
yearlySiteCovs(umf) &lt;- data.frame(year = factor(rep(1:7,
                                    numSites(umf))))

##set up model with constant transition rates
fm &lt;- colext(psiformula = ~ 1, gammaformula = ~ 1, epsilonformula = ~ 1,
             pformula = ~ JulianDate + I(JulianDate^2), data = umf,
             control = list(trace=1, maxit=1e4))

##model with with year-dependent transition rates
fm.yearly &lt;- colext(psiformula = ~ 1, gammaformula = ~ year,
                    epsilonformula = ~ year,
                    pformula = ~ JulianDate + I(JulianDate^2),
                    data = umf)

##store in list and assign model names
Cand.mods &lt;- list(fm, fm.yearly)
Modnames &lt;- c("psi1(.)gam(.)eps(.)p(Date + Date2)",
              "psi1(.)gam(Year)eps(Year)p(Date + Date2)")

##compute model-averaged estimate of occupancy in the first year
modavg(cand.set = Cand.mods, modnames = Modnames, parm = "(Intercept)",
       parm.type = "psi")

##compute model-averaged estimate of Julian Day squared on detectability
modavg(cand.set = Cand.mods, modnames = Modnames,
       parm = "I(JulianDate^2)", parm.type = "detect")

## End(Not run)


##example of model-averaged estimate of area from distance model
##this is a bit longer
## Not run: 
data(linetran) #example modified from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line", unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and detection.
fm2 &lt;- distsamp(~ area + habitat ~ area + habitat, ltUMF)

## Hazard function. Covariates affecting both density and detection.
fm3 &lt;- distsamp(~ habitat ~ area + habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)
Modnames &lt;- paste("mod", 1:length(Cands), sep = "")

##model-average estimate of area on abundance
modavg(cand.set = Cands, modnames = Modnames, parm = "area", parm.type = "lambda")
detach(package:unmarked)

## End(Not run)
</code></pre>


</div>