<div class="container">

<table style="width: 100%;"><tr>
<td>rRegMatch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Regular matching with minimum-cost spanning subgraphs
</h2>

<h3>Description</h3>

<p>This function matches each observation in X to r others so as to minimize the 
total distance across all matches. Optionally it computes the cross-count
statistic – the number of matches associated with two observations from 
different classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rRegMatch(X, r, y = NULL, dister = "daisy", dist.args = list(), keep.X = nrow(X) &lt; 100, 
    keep.D = (dister == "treeClust.dist"), relax = (N &gt;= 100), thresh = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Matrix or data frame of data, or inter-point distances represented in an object inheriting from "dist"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>Integer number of matches. The matching is "regular" in that every observation is matched to exactly
r others (or, if relax=TRUE, every observation is matched to others with weights in [0, 1] that add up to r).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Vector of class membership indices. This is used to compute the cross-count statistic. Optional.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dister</code></td>
<td>

<p>Function to compute inter-point distances. This must take as its first argument
a matrix of data argument name <code>x</code>. Default: <code>daisy</code>. 
If all the columns are numeric,
this produces unweighted Euclidean distance by default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.args</code></td>
<td>

<p>List of argument to the <code>dister</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.X</code></td>
<td>

<p>If TRUE, and X was supplied, keep the X matrix in the output object. Default: 
TRUE if X was supplied and also nrow (X) &lt; 100.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.D</code></td>
<td>

<p>If TRUE, keep the distance object in the output. Default: TRUE if the 
<code>treeClust.dist</code> function is being
used to compute the distances (since in that case the distances are random).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax</code></td>
<td>

<p>If FALSE, solve the exact problem where each observation gets exactly r 
non-zero pairings, each with weight 1. If TRUE, solve the relaxed problem, 
where each observation has at least r non-zero pairings, 
each with its own weight between 0 and 1, the weights adding up to r. The
exact problem gets very slow with large samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>

<p>Weights smaller than this are considered to be exactly zero. Default: 1e-6.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function solves an optimization problem to extract the set of pairings which make the total weight
(distance) associated with all pairings a minimum, subject to the constraint that every observation is paired
to r others (or to enough others to have a total pair-weight of r).
</p>


<h3>Value</h3>

<p>A list of class AcrossTic, with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>matches </code></td>
<td>
<p>A two-column matrix, each row gving the indices of one matched pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total.dist </code></td>
<td>
<p>total distance across all matches – the optimal value from the optimization problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status </code></td>
<td>
<p>Status of result – if the optimum was found, a vector of length 1 with 
name "TM_OPTIMAL_SOLUTION_FOUND" and value 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.required </code></td>
<td>
<p>Time taken to run the optimization, as reported by <code>system.time()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call </code></td>
<td>
<p>The call made to the function, from <code>match.call</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r </code></td>
<td>
<p>The value of r, as supplied at the time of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dister </code></td>
<td>
<p>The value of dister, as supplied at the time of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.args </code></td>
<td>
<p>The value of dist.args, as supplied at the time of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.supplied </code></td>
<td>
<p>Logical indicating whether X was supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p>X matrix, if it was available and asked to be kept</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y </code></td>
<td>
<p>y vector, as supplied</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.weights</code></td>
<td>
<p>vector, of length <code>nrow(matches)</code>, giving the distances for each match. For the exact problem (<code>relax = FALSE</code>), each value is
equal to 0 or 1. For the relaxed problem (<code>relax = TRUE</code>), each value is
between 0 and 1, with values summing to <code>(r * nrow(X) / 2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross.sum </code></td>
<td>
<p>Sum of matcher.costs across all matches</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross.count </code></td>
<td>
<p>Number of matches between two observations of different classes, possibly weighted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow.X, ncol.X </code></td>
<td>
<p>dimension of X matrix</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>David Ruth and Sam Buttrey
</p>


<h3>References</h3>

<p>David Ruth, "A new multivariate two-sample test using regular minimum-weight spanning subgraphs,"
J. Stat. Distributions and Applications (2014)
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed (123)
X &lt;- matrix (rnorm (100), 50, 2) # Create data...
y &lt;- rep (c (1, 2), each=25) # ...and class membership
rRegMatch (X, r = 3, y = y)
## Not run: plot (rRegMatch (X, r = 3, y = y)) # to see picture</code></pre>


</div>