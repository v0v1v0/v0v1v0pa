<div class="container">

<table style="width: 100%;"><tr>
<td>mrqap.custom.null</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
MRQAP function with custom permutation networks
</h2>

<h3>Description</h3>

<p>Calculate MRQAP with random networks provides (i.e. generated by a custom model of user's choice)
</p>


<h3>Usage</h3>

<pre><code class="language-R">mrqap.custom.null(formula, random.y, intercept = TRUE, directed = "undirected",
	diagonal = FALSE, test.statistic = "t-value", 
	tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>input formula (e.g. y ~ x1 + x2), where y and each x are NxN matrices
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.y</code></td>
<td>

<p>a k x N x N matrix containing a set of random networks generated by some permutation method
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>calculate intercept (TRUE or FALSE value)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>

<p>whether the network is directed or undirected (enter either "directed" or "undirected")
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagonal</code></td>
<td>

<p>whether to include self-loop values (TRUE or FALSE)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.statistic</code></td>
<td>

<p>what to calculate P-value, either t-statistic ("t-value") or regression coefficient ("beta")
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>tolerance value for the qr function
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculate the regression coefficient for each input matrix using MRQAP but where the random networks are provided. This is in contrast to mrqap.dsp which has a built-in node permutation (which I have shown has higher rates of type II errors - see Farine &amp; Whitehead 2015 and Farine in prep.). This method can easily be interfaced with the network_permutation method. Note however that this method tests whether y is related to x1 and x2 together because the different fixed effects are not permuted independently (as suggested by Dekker et al 2007). Whilst the potential to avoid type II errors may warrant this approach, further theoretical testing is needed to confirm this approach is appropriate.
</p>


<h3>Value</h3>

<p>Returns a mrqap.dsp object containing the regression coefficient and P-values for each indendent matrix (x) and associated statistics
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Dekker, D., Krackhard, D., Snijders, T.A.B (2007) Sensitivity of MRQAP tests to collinearity and autocorellation conditions. <em>Psychometrika</em> 72(4): 563-581.
Farine, D. R., &amp; Whitehead, H. (2015) Constructing, conducting, and interpreting animal social network analysis. Journal of Animal Ecology, 84(5), 1144-1163.
Farine, D. R. (in prep) Why and how to use null models in animal social network analysis.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(asnipe)
data("individuals")
data("group_by_individual")

# Generate network
network &lt;- get_network(gbi)

# Create a species similarity matrix
species &lt;- array(0,dim(network))

# Create a sex similarity matrix
sex &lt;- array(0,dim(network))

# Fill each matrix with 1 (same) or 0 (different)
for (i in 1:nrow(network)) {
	species[i,-i] &lt;- as.numeric(inds$SPECIES[i] == inds$SPECIES[-i])
	sex[i,-i] &lt;- as.numeric(inds$SEX[i] == inds$SEX[-i])
}

# Perform network randomisation
# Note randomisations are limited to 10 to reduce runtime
networks_rand &lt;- network_permutation(gbi, association_matrix=network, permutations=10)

# Run mrqap.custom.null
# Note randomisations are limited to 10 to reduce runtime
reg &lt;- mrqap.custom.null(network ~ species + sex, random.y=networks_rand)

# Look at results
reg

</code></pre>


</div>