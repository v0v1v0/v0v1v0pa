<div class="container">

<table style="width: 100%;"><tr>
<td>addreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Additive Regression for Discrete Data
</h2>

<h3>Description</h3>

<p><code>addreg</code> fits additive (identity-link) Poisson, negative binomial
and binomial regression models using a stable combinatorial EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">addreg(formula, mono = NULL, family, data, standard, subset, na.action,
       start = NULL, offset, control = list(...), model = TRUE, 
       method = c("cem", "em"),
       accelerate = c("em", "squarem", "pem", "qn"), 
       control.method = list(), warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>an object of class <code>"formula"</code>
(or one that can be coerced into that class): a symbolic
description of the model to be fitted. The details of
model specification are given under "Details".  Note that
the model must contain an intercept, and 2nd-order terms
(such as interactions) or above are currently not supported
— see "Note".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mono</code></td>
<td>

<p>a vector indicating which terms in
<code>formula</code> should be restricted to have a
monotonically non-decreasing relationship with the
outcome. May be specified as names or indices of the
terms.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>a description of the error distribution to
be used in the model. This can be a character string
naming a family function, a family function or the result
of a call to a family function (see
<code>family</code> for details of family
functions), but here it is restricted to be <code>poisson</code>,
<code>negbin1</code> or <code>binomial</code> family with <code>identity</code> link.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional data frame, list or environment
(or object coercible by <code>as.data.frame</code> to a
data frame) containing the variables in the model. If not
found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment
from which <code>addreg</code> is called.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard</code></td>
<td>

<p>a numeric vector of length equal to the
number of cases, where each element is a positive
constant that (multiplicatively) standardises the fitted
value of the corresponding element of the response
vector. Ignored for binomial family (two-column
specification of response should be used instead).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>an optional vector specifying a subset of
observations to be used in the fitting process.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set be the <code>na.action</code>
setting of <code>options</code>, and is <code>na.fail</code>
if that is unset. The ‘factory-fresh’ default is <code>na.omit</code>.
Another possible value is <code>NULL</code>, no action. Value
<code>na.exclude</code> can be useful.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>

<p>starting values for the parameters in the
linear predictor, also with the starting value for
the <code>scale</code> as the last element when
<code>family = negbin1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>this can be used to specify an <em>a
priori</em> known component to be included in the linear
predictor during fitting. This should be <code>NULL</code> or a
<em>non-negative</em> numeric vector of length equal to the number of cases.
One or more <code>offset</code> terms can be included in
the formula instead or as well, and if more than one is
specified their sum is used. See
<code>model.offset</code>.
</p>
<p>Ignored for binomial family; not yet implemented for negative binomial models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>list of parameters for controlling the
fitting process, passed to
<code>addreg.control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>a logical value indicating whether the <em>model frame</em> 
(and, for binomial models, the equivalent Poisson model)
should be included as a component of the returned value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>a character string that determines which algorithm to use to
find the MLE: <code>"cem"</code> for the combinatorial EM algorithm,
which cycles through a sequence of constrained parameter spaces,
or <code>"em"</code> for a single EM algorithm based on an
overparameterised model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accelerate</code></td>
<td>

<p>a character string that determines the acceleration
algorithm to be used, (partially) matching one of <code>"em"</code> (no acceleration — the default), 
<code>"squarem"</code>, <code>"pem"</code> or <code>"qn"</code>. See <code>turboem</code>
for further details. Note that <code>"decme"</code> is not permitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.method</code></td>
<td>

<p>a list of control parameters for the acceleration algorithm, which are passed to 
the <code>control.method</code> argument of <code>turboem</code>.
</p>
<p>If any items are not specified, the defaults are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>

<p>a logical indicating whether or not warnings should be
provided for non-convergence or boundary values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>arguments to be used to form the default
<code>control</code> argument if it is not supplied directly.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>addreg</code> fits a generalised linear model (GLM) with a
Poisson or binomial error distribution and identity link
function, as well as additive NegBin I models (which are not 
GLMs). Predictors are assumed to be continuous, unless
they are of class <code>factor</code>, or are character or
logical (in which case they are converted to
<code>factor</code>s). Specifying a predictor as monotonic using
the <code>mono</code> argument means that for continuous terms,
the associated coefficient will be restricted to be
non-negative, and for categorical terms, the coefficients
will be non-decreasing in the order of the factor
<code>levels</code>. This allows semi-parametric monotonic regression
functions, in the form of unsmoothed step-functions. For 
smooth regression functions see <code>addreg.smooth</code>.
</p>
<p>As well as allowing monotonicity constraints, the function 
is useful when a standard GLM routine, such as
<code>glm</code>, fails to converge with an identity-link Poisson
or binomial model. If <code>glm</code> does achieve successful convergence,
and <code>addreg</code> converges to an interior point, then the two
results will be identical. However, <code>glm</code> may still experience convergence 
problems even when <code>addreg</code> converges to an interior point. 
Note that if <code>addreg</code> converges to a boundary point, then it 
may differ slightly from <code>glm</code> even if <code>glm</code> successfully 
converges, because of differences in the definition of the parameter 
space. <code>addreg</code> produces valid fitted values for covariate 
values within the Cartesian product of the observed range of covariate 
values, whereas <code>glm</code> produces valid fitted values just 
for the observed covariate combinations (assuming it successfully 
converges). This issue is only relevant when <code>addreg</code> 
converges to a boundary point.
</p>
<p>The computational method is a combinatorial EM algorithm
(Marschner, 2014), which accommodates the parameter
contraints in the model and is more stable than iteratively
reweighted least squares. A collection of restricted
parameter spaces is defined which covers the full parameter
space, and the EM algorithm is applied within each
restricted parameter space in order to find a collection of
restricted maxima of the log-likelihood function, from
which can be obtained the global maximum over the full
parameter space. See Marschner (2010), Donoghoe and 
Marschner (2014) and Donoghoe and Marschner (2016) for further details.
</p>
<p>Acceleration of the EM algorithm can be achieved through the
methods of the <span class="pkg">turboEM</span> package, specified
through the <code>accelerate</code> argument. However, note that these
methods do not have the guaranteed convergence of the standard
EM algorithm, particularly when the MLE is on the boundary of
its (possibly constrained) parameter space.
</p>


<h3>Value</h3>

<p><code>addreg</code> returns an object of class <code>"addreg"</code>,
which inherits from classes <code>"glm"</code> and <code>"lm"</code>.
The function <code>summary.addreg</code> can be used 
to obtain or print a summary of the results.
</p>
<p>The generic accessor functions <code>coefficients</code>,
<code>fitted.values</code> and <code>residuals</code> can be used to
extract various useful features of the value returned by
<code>addreg</code>. Note that <code>effects</code> will not work.
</p>
<p>An object of class <code>"addreg"</code> is a list containing the
same components as an object of class <code>"glm"</code> (see the
"Value" section of <code>glm</code>), but without
<code>contrasts</code>, <code>qr</code>, <code>R</code> or <code>effects</code>
components. It also includes: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>the maximised log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic.c</code></td>
<td>
<p>a small-sample corrected
version of Akaike's <em>An Information Criterion</em>
(Hurvich, Simonoff and Tsai, 1998). This is used by
<code>addreg.smooth</code> to choose the optimal number of
knots for smooth terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xminmax</code></td>
<td>
<p>the minimum and maximum observed values
for each of the continuous covariates, to help define
the covariate space of the model.</p>
</td>
</tr>
</table>
<p>As well as, for Poisson and negative binomial models:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nn.coefficients</code></td>
<td>
<p>estimated coefficients associated
with the non-negative parameterisation corresponding to the
MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.x</code></td>
<td>
<p>non-negative model matrix associated with
<code>nn.coefficients</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standard</code></td>
<td>
<p>the <code>standard</code> argument.</p>
</td>
</tr>
</table>
<p>Or, for binomial models:
</p>
<table><tr style="vertical-align: top;">
<td><code>model.addpois</code></td>
<td>
<p>if requested, the <code>addreg</code> object for the associated identity-link
Poisson model.</p>
</td>
</tr></table>
<p>The <code>scale</code> component of the result is fixed at <code class="reqn">1</code> for
Poisson and binomial models, and is the constant overdispersion parameter
for negative binomial models (that is, <code>scale</code> = <code class="reqn">1+\phi</code>) where 
<code class="reqn">Var(\mu) = (1+\phi)\mu</code>).
</p>


<h3>Note</h3>

<p>Due to the way the covariate space is defined in the CEM algorithm,
specifying interactions in the formula is not currently supported 
by <code>addreg</code>. 2-way interactions between factors can be
included by calculating a new factor term that has levels
corresponding to all possible combinations of the factor
levels. See the Example.
</p>


<h3>Author(s)</h3>

<p>Mark W. Donoghoe <a href="mailto:markdonoghoe@gmail.com">markdonoghoe@gmail.com</a>
</p>


<h3>References</h3>

<p>Donoghoe, M. W. and I. C. Marschner (2014). Stable computational methods
for additive binomial models with application to adjusted risk differences. 
<em>Computational Statistics and Data Analysis</em> 80: 184–196.
</p>
<p>Donoghoe, M. W. and I. C. Marschner (2016). Estimation of adjusted rate
differences using additive negative binomial regression. <em>Statistics
in Medicine</em> 35(18): 3166–3178.
</p>
<p>Hurvich, C. M., J. S. Simonoff and C.-L. Tsai (1998). Smoothing parameter 
selection in nonparametric regression using an improved Akaike 
information criterion.
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 60(2): 271–293.
</p>
<p>Marschner, I. C. (2010). Stable computation of maximum likelihood estimates
in identity link Poisson regression. <em>Journal of Computational and 
Graphical Statistics</em> 19(3): 666–683.
</p>
<p>Marschner, I. C. (2014). Combinatorial EM algorithms.
<em>Statistics and Computing</em> 24(6): 921–940.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(glm2)
data(crabs)

#============================================================================
#  identity-link Poisson model with periodic non-convergence when glm is used
#============================================================================

crabs.boot &lt;- crabs[crabs$Rep1,-c(5:6)]
crabs.boot$width.shifted &lt;- crabs.boot$Width - min(crabs$Width)

fit.glm &lt;- glm(Satellites ~ width.shifted + factor(Dark) + factor(GoodSpine),
  family = poisson(identity), data = crabs.boot, start = rep(1,4), 
  control = glm.control(trace = TRUE))
  
fit.addreg &lt;- addreg(formula(fit.glm), family = poisson, data = crabs.boot,
  trace = 1)

# Speed up convergence by using single EM algorithm
fit.addreg.em &lt;- update(fit.addreg, method = "em")

# Speed up convergence by using acceleration methods
fit.addreg.acc &lt;- update(fit.addreg, accelerate = "squarem")
fit.addreg.em.acc &lt;- update(fit.addreg.em, accelerate = "squarem")
  
# Usual S3 methods work on addreg objects
summary(fit.addreg)
vcov(fit.addreg)
confint(fit.addreg)
summary(predict(fit.addreg), type = "response")

fit.addreg2 &lt;- addreg(update(formula(fit.glm), ~ . - factor(GoodSpine)),
  family = poisson, data = crabs.boot, trace = 1)
anova(fit.addreg2, fit.addreg, test = "LRT")

# Account for overdispersion (use start to speed it up a little)
fit.addreg.od &lt;- addreg(Satellites ~ factor(Dark) + factor(GoodSpine),
  family = negbin1, data = crabs.boot, trace = 1,
  start = c(4.3423675,-2.4059273,-0.4531984,5.969648))
summary(fit.addreg.od)
</code></pre>


</div>