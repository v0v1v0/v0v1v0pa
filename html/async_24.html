<div class="container">

<table style="width: 100%;"><tr>
<td>run</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Execute a generator expression immediately, collecting yielded values.</h2>

<h3>Description</h3>

<p><code>run(expr)</code> with an expression directly writen, will parse that
expression as a coroutine, but then run it without pausing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">run(
  expr,
  type = list(),
  ...,
  split_pipes = FALSE,
  debugR = FALSE,
  debugInternal = FALSE,
  trace = getOption("async.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A generator expression, same as you would write in
gen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A value whose mode will determine the output vector mode (as
in vapply.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Undocumented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_pipes</code></td>
<td>
<p>See async; defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debugR</code></td>
<td>
<p>Will open a browser at the first and subsequent R
evaluations allowing single-stepping through user code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debugInternal</code></td>
<td>
<p>Will set a breakpoint at the implementation
level, allowing single-stepping through <code>async</code> package code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>a tracing function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the expression contains any calls to <code>yield()</code>, <code>run()</code> will
collect all the values passed to yield() and return a list. If the
expression contains a <code>yield()</code> but it is never called, <code>run()</code>
returns an empty list. If the expression does not contain a <code>yield</code>
at all, <code>run</code> returns the expression's final return value.
</p>
<p><code>run(expr)</code> is similar to <code>as.list(gen(expr))</code>, except <code>run(expr)</code>
evaluates its expression directly in the calling environment, while
<code>gen</code> creates a new enclosed environment to run in.
</p>
<p><code>run</code> is useful if you want to take advantage of coroutine language
extensions, such as using <code>for</code> loops over iterators, or using
<code>goto()</code> in <code>switch</code> statements, in otherwise synchronous code. If
you want to collect a variable-length sequence of values but don't
need those features, using collect directly will have better
performance.
</p>


<h3>Value</h3>

<p>If <code>expr</code> contains any <code>yield</code> calls, a vector of the
same mode as <code>type</code>; otherwise the return value of <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
run(type=0, {
  for (i in iterors::iseq(2, Inf, by=5)) {
    if (i %% 37 == 0) break
    else yield(i)
  }
})

</code></pre>


</div>