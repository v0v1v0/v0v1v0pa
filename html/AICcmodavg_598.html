<div class="container">

<table style="width: 100%;"><tr>
<td>modavgShrink</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model-averaged Parameter Estimate with Shrinkage (Multimodel Inference)
</h2>

<h3>Description</h3>

<p>This function computes an alternative version of model-averaging
parameter estimates that consists in shrinking estimates toward 0 to
reduce model selection bias as in Burnham and Anderson (2002, p. 152),
Anderson (2008, pp. 130-132) and Lukacs et al. (2010).  Specifically,
models without the parameter of interest have an estimate and variance
of 0.  <code>modavgShrink</code> also returns unconditional standard errors
and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">modavgShrink(cand.set, parm, modnames = NULL, second.ord = TRUE,
              nobs = NULL, uncond.se = "revised", conf.level = 0.95,
              ...)
## S3 method for class 'AICaov.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICbetareg'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsclm.clm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICclm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICclmm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICcoxme'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICcoxph'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglm.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, gamdisp = NULL, ...)

## S3 method for class 'AICgls'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglmmTMB'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AIChurdle'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClme'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmekin'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmer'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglmerMod'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerMod'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmaxlikeFit.list'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICmultinom.nnet'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgShrink(cand.set, parm, modnames = NULL, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICpolr'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICrlm.lm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsurvreg'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICvglm'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
modavgShrink(cand.set, parm, modnames = NULL,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICunmarkedFitOccu'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgShrink(cand.set, parm, modnames
           = NULL, second.ord = TRUE, nobs = NULL, uncond.se =
           "revised", conf.level = 0.95, c.hat = 1, parm.type = NULL,
           ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgShrink(cand.set, parm, modnames
        = NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgShrink(cand.set, parm, modnames =
        NULL, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, c.hat = 1, parm.type = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>

<p>the parameter of interest, enclosed between quotes, for which a
model-averaged estimate is required.  For a categorical variable, 
the label of the estimate must be included as it appears in the output
(see 'Details' below). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the AICc (i.e., <code>nobs</code> defaults to total
number of observations).  This is relevant only for mixed models or
various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
    "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax), with Poisson GLM's, 
single-season occupancy models (MacKenzie et al. 2002), dynamic
occupancy models (MacKenzie et al. 2003), or <em>N</em>-mixture models
(Royle 2004, Dail and Madsen 2011).  If <code>c.hat</code> &gt; 1,
<code>modavgShrink</code> will return the quasi-likelihood analogue of the
information criteria requested and multiply the variance-covariance
matrix of the estimates by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  This option is not supported for generalized
linear mixed models of the <code>mer</code> or <code>merMod</code> classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>

<p>this argument specifies the parameter type on which the
model-averaged estimate of a predictor will be computed and is only
relevant for models of <code>unmarkedFit</code> classes.  The character
strings supported vary with the type of model fitted.  For
<code>unmarkedFitOccu</code> objects, either <code>psi</code> or <code>detect</code>
can be supplied to indicate whether the parameter is on occupancy or
detectability, respectively.  For <code>unmarkedFitColExt</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and detectability, respectively.  For
<code>unmarkedFitOccuTTD</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
time-to-dection (lambda rate parameter), respectively.  For
<code>unmarkedFitOccuFP</code> objects, one can specify <code>psi</code>,
<code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for occupancy,
detectability, probability of assigning false-positives, and
probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code>
denote parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter for which a model-averaged estimate is requested must be
specified with the <code>parm</code> argument and must be identical to its
label in the model output (e.g., from <code>summary</code>).  For factors, one
must specify the name of the variable and the level of interest.  The
shrinkage version of model averaging is only appropriate for cases where
each parameter is given an equal weighting in the model (i.e., each
parameter must appear the same number of times in the models) and has
the same interpretation across all models.  As a result, models with
interaction terms or polynomial terms are not supported by
<code>modavgShrink</code>. 
</p>
<p><code>modavgShrink</code> is implemented for a list containing objects of
<code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>clmm</code>, <code>clogit</code>,
<code>coxme</code>, <code>coxph</code>, <code>glm</code>, <code>glmmTMB</code>, <code>gls</code>,
<code>hurdle</code>, <code>lm</code>, <code>lme</code>, <code>lmekin</code>, <code>maxlikeFit</code>,
<code>mer</code>, <code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>,
<code>multinom</code>, <code>polr</code>, <code>rlm</code>, <code>survreg</code>, <code>vglm</code>,
<code>zeroinfl</code> classes as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Value</h3>

<p><code>modavgShrink</code> creates an object of class <code>modavgShrink</code>
with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Parameter</code></td>
<td>
<p>the parameter for which a model-averaged estimate with
shrinkage was obtained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.table</code></td>
<td>
<p>the model selection table based on models including
the parameter of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.beta</code></td>
<td>
<p>the model-averaged estimate based on all models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate (as opposed to the conditional SE based on a single model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603–618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261–304.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587. 
</p>
<p>Lukacs, P. M., Burnham, K. P., Anderson, D. R. (2010) Model selection
bias and Freedman's paradox. <em>Annals of the Institute of
Statistical Mathematics</em> <b>62</b>, 117–125. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169–180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>c_hat</code>,
<code>importance</code>, <code>confset</code>, <code>evidence</code>,
<code>modavg</code>, <code>modavgCustom</code>,
<code>modavgPred</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##cement example in Burnham and Anderson 2002
data(cement)
##setup same model set as in Table 3.2, p. 102         
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(y ~ x1 + x2, data = cement)
Cand.models[[2]] &lt;- lm(y ~ x1 + x2 + x4, data = cement)          
Cand.models[[3]] &lt;- lm(y ~ x1 + x2 + x3, data = cement)
Cand.models[[4]] &lt;- lm(y ~ x1 + x4, data = cement)
Cand.models[[5]] &lt;- lm(y ~ x1 + x3 + x4, data = cement)
Cand.models[[6]] &lt;- lm(y ~ x2 + x3 + x4, data = cement)
Cand.models[[7]] &lt;- lm(y ~ x1 + x2 + x3 + x4, data = cement)
Cand.models[[8]] &lt;- lm(y ~ x3 + x4, data = cement)
Cand.models[[9]] &lt;- lm(y ~ x2 + x3, data = cement)
Cand.models[[10]] &lt;- lm(y ~ x4, data = cement)
Cand.models[[11]] &lt;- lm(y ~ x2, data = cement)
Cand.models[[12]] &lt;- lm(y ~ x2 + x4, data = cement)
Cand.models[[13]] &lt;- lm(y ~ x1, data = cement)
Cand.models[[14]] &lt;- lm(y ~ x1 + x3, data = cement)
Cand.models[[15]] &lt;- lm(y ~ x3, data = cement)

##vector of model names
Modnames &lt;- paste("mod", 1:15, sep="")

##AICc          
aictab(cand.set = Cand.models, modnames = Modnames)

##compute model-averaged estimate with shrinkage - each parameter
##appears 8 times in the models 
modavgShrink(cand.set = Cand.models, modnames = Modnames, parm = "x1")

##compare against classic model-averaging
modavg(cand.set = Cand.models, modnames = Modnames, parm = "x1")
##note that model-averaged estimate with shrinkage is closer to 0 than
##with the classic version

##remove a few models from the set and run again
Cand.unbalanced &lt;- Cand.models[-c(3, 14, 15)]

##set up model names
Modnames &lt;- paste("mod", 1:length(Cand.unbalanced), sep="")

##issues an error because some parameters appear more often than others
## Not run: modavgShrink(cand.set = Cand.unbalanced,
                       modnames = Modnames, parm = "x1")
## End(Not run)



##example on Orthodont data set in nlme
## Not run: 
require(nlme)

##set up candidate model list
##age and sex parameters appear in the same number of models
##same number of models with and without these parameters
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method = "ML") 
##random is ~ age | Subject as it is a grouped data frame
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method = "ML")
Cand.models[[3]] &lt;- lme(distance ~ 1, data = Orthodont, random = ~ 1, 
                        method = "ML") 
Cand.models[[4]] &lt;- lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                        method = "ML")  

##create a vector of model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute importance values for age
imp.age &lt;- importance(cand.set = Cand.models, parm = "age",
                      modnames = Modnames, second.ord = TRUE,
                      nobs = NULL)

##compute shrinkage version of model averaging on age
mod.avg.age.shrink &lt;- modavgShrink(cand.set = Cand.models,
                                    parm = "age", modnames = Modnames,
                                    second.ord = TRUE, nobs = NULL)

##compute classic version of model averaging on age
mod.avg.age.classic &lt;- modavg(cand.set = Cand.models, parm = "age",
                              modnames = Modnames, second.ord = TRUE,
                              nobs = NULL)

##correspondence between shrinkage version and classic version of
##model averaging 
mod.avg.age.shrink$Mod.avg.beta/imp.age$w.plus
mod.avg.age.classic$Mod.avg.beta
detach(package:nlme)

## End(Not run)


##example of N-mixture model modified from ?pcount
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)

##model list and names
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three)
Modnames &lt;- c("length + forest", "elev + forest", "length + elev")

##compute model-averaged estimate with shrinkage for elev on abundance
modavgShrink(cand.set = Cands, modnames = Modnames, parm = "elev",
              parm.type = "lambda")
detach(package:unmarked)

## End(Not run)
</code></pre>


</div>