<div class="container">

<table style="width: 100%;"><tr>
<td>Simulation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class Create and represent a Simulation object</h2>

<h3>Description</h3>

<p>The Simulation class inherits the Population class. So a simulation
manages agents and their contact. Thus, the class also inherits the
Agent class. So a simulation can have its own state, and events attached
(scheduled) to it. In addition, it also manages all the transitions, using
its <code>addTransition</code> method. ASt last, it maintains loggers, which
record (or count) the state changes, and report their values at specified
times.
</p>


<h3>Super classes</h3>

<p><code>ABM::R6Agent</code> -&gt; <code>ABM::R6Population</code> -&gt; <code>R6Simulation</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R6Simulation-new"><code>Simulation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-run"><code>Simulation$run()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-resume"><code>Simulation$resume()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-addLogger"><code>Simulation$addLogger()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-addTransition"><code>Simulation$addTransition()</code></a>
</p>
</li>
<li> <p><a href="#method-R6Simulation-clone"><code>Simulation$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="leave"><a href="../../ABM/html/R6Agent.html#method-R6Agent-leave"><code>ABM::R6Agent$leave()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="match"><a href="../../ABM/html/R6Agent.html#method-R6Agent-match"><code>ABM::R6Agent$match()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="schedule"><a href="../../ABM/html/R6Agent.html#method-R6Agent-schedule"><code>ABM::R6Agent$schedule()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="setDeathTime"><a href="../../ABM/html/R6Agent.html#method-R6Agent-setDeathTime"><code>ABM::R6Agent$setDeathTime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Agent" data-id="unschedule"><a href="../../ABM/html/R6Agent.html#method-R6Agent-unschedule"><code>ABM::R6Agent$unschedule()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="addAgent"><a href="../../ABM/html/R6Population.html#method-R6Population-addAgent"><code>ABM::R6Population$addAgent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="addContact"><a href="../../ABM/html/R6Population.html#method-R6Population-addContact"><code>ABM::R6Population$addContact()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="agent"><a href="../../ABM/html/R6Population.html#method-R6Population-agent"><code>ABM::R6Population$agent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="removeAgent"><a href="../../ABM/html/R6Population.html#method-R6Population-removeAgent"><code>ABM::R6Population$removeAgent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="setState"><a href="../../ABM/html/R6Population.html#method-R6Population-setState"><code>ABM::R6Population$setState()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ABM" data-topic="R6Population" data-id="setStates"><a href="../../ABM/html/R6Population.html#method-R6Population-setStates"><code>ABM::R6Population$setStates()</code></a></span></li>
</ul></details><hr>
<a id="method-R6Simulation-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$new(simulation = 0, initializer = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>simulation</code></dt>
<dd>
<p>can be either an external pointer pointing to
a population object returned from newSimulation, or an integer
specifying the population size, or a list</p>
</dd>
<dt><code>initializer</code></dt>
<dd>
<p>a function or NULL</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>If simulation is a number (the population size), then initializer
can be a function that take the index of an agent and return its initial
state. If it is a list, the length is the population size, and each element
corresponds to the initial state of an agent (with the same index).
Run the simulation
</p>


<hr>
<a id="method-R6Simulation-run"></a>



<h4>Method <code>run()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$run(time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt>
<dd>
<p>the time points to return the logger values.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>the returned list can be coerced into a data.frame object
which first column is time, and other columns are logger results,
each row corresponds to a time point.
</p>
<p>The Simulation object first collect and log the states from all
agents in the simulation, then set the current time to the time of
the first event, then call the resume method to actually run it.
</p>
<p>Continue running the simulation
</p>



<h5>Returns</h5>

<p>a list of numeric vectors, with time and values reported
by all logger.
</p>


<hr>
<a id="method-R6Simulation-resume"></a>



<h4>Method <code>resume()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$resume(time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>time</code></dt>
<dd>
<p>the time points to return the logger values.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>the returned list can be coerced into a data.frame object
which first column is time, and other columns are logger results,
each row corresponds to a time point.
</p>
<p>The Simulation object repetitively handle the events until the the
last time point in "time" is reached. ASt each time point, the
logger states are collected in put in a list to return.
Add a logger to the simulation
</p>



<h5>Returns</h5>

<p>a list of numeric vectors, with time and values reported
by all logger.
</p>


<hr>
<a id="method-R6Simulation-addLogger"></a>



<h4>Method <code>addLogger()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$addLogger(logger)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>logger, </code></dt>
<dd>
<p>an external pointer returned by functions like
newCounter or newStateLogger.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>without adding a logger, there will be no useful simulation
results returned.
Add a transition to the simulation
</p>



<h5>Returns</h5>

<p>the simulation object itself (invisible)
</p>


<hr>
<a id="method-R6Simulation-addTransition"></a>



<h4>Method <code>addTransition()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>Simulation$addTransition(
  rule,
  waiting.time,
  to_change_callback = NULL,
  changed_callback = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rule</code></dt>
<dd>
<p>is a formula that gives the transition rule</p>
</dd>
<dt><code>waiting.time</code></dt>
<dd>
<p>either an external pointer to a WaitingTime object
such as one returned by newExpWaitingTime or newGammaWaitingTime, or
a function (see the details section)</p>
</dd>
<dt><code>to_change_callback</code></dt>
<dd>
<p>the R callback function to determine if
the change should occur. See the details section.</p>
</dd>
<dt><code>changed_callback</code></dt>
<dd>
<p>the R callback function after the change
happened. See the details section.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>If waiting.time is a function then it should take exactly one
argument time, which is a numeric value holding the current value, and
return a single numeric value for the waiting time (i.e., should not add
time).
</p>
<p>Formula can be used to specify either a spontaneous
transition change, or a transition caused by a contact.
</p>
<p>A spontaneous transition has the form from -&gt; to, where from and
to are state specifications. It is either a variable name holding
a state (R list) or the list itself. The list can also be specified
by state(...) instead of list(...)
</p>
<p>For a spontaneous transition, the callback functions take the
following two arguments
</p>

<ol>
<li>
<p> time: the current time in the simulation
</p>
</li>
<li>
<p> agent: the agent who initiate the contact, an external pointer
</p>
</li>
</ol>
<p>A transition caused by contact, the formula needs to specify the
states of both the agent who initiate the contact and the contact
agent. The two states are connected by a + sign, the one before the
</p>

<ul><li>
<p> sign is the initiator, and the one after the sign is the contact.
The transition must be associated with a Contact object, using
a ~ operator. The Contact object must be specified by a variable name
that hold the external pointer to the object (created by e.g.,
the newRandomMixing function) For example, suppose S=list("S"),
I=list("I"), and m=newRandomMixing(sim), then a possible rule
specifying an infectious agent contacting a susceptible agent causing
it to become exposed can be
specified by
</p>
</li></ul>
<p>I + S -&gt; I + list("E") ~ m
</p>
<p>For a transition caused by a contact, the callback functions take
the third argument:
3. contact: the contact agent, an external pointer
</p>



<h5>Returns</h5>

<p>the simulation object itself (invisible)
</p>


<hr>
<a id="method-R6Simulation-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Simulation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>