<div class="container">

<table style="width: 100%;"><tr>
<td>makeTPPSplineMats.data.frame</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make the spline basis matrices and data needed to fit Tensor Product P-splines.</h2>

<h3>Description</h3>

<p>Prepares the fixed and random P-spline basis matrices, and associated 
information, that are needed for fitting of Tensor Product P-splines (TPPS) 
as described by Rodriguez-Alvarez et al. (2018). This function is called 
internally by <code>addSpatialModelOnIC.asrtests</code>, 
<code>addSpatialModelOnIC.asrtests</code> and 
<code>chooseSpatialModelOnIC.asrtests</code> when fitting <code>TPPS</code> models 
for local spatial variation. There are two methods available, controlled by 
<code>asreml.option</code> for creating and storing the basis functions. 
This function is most likely to be called directly when <code>mbf</code> has been used 
in creating an <code>asreml.object</code> and it is desired to use the object in a 
session subsequent to the session in which the object was created.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'data.frame'
makeTPPSplineMats(data, sections = NULL, 
                  row.covar, col.covar, 
                  nsegs = NULL, nestorder = c(1,1), 
                  degree = c(3,3), difforder = c(2,2),
                  rotateX = FALSE, theta = c(0,0), 
                  asreml.option = "grp", mbf.env = sys.frame(), 
                  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An <code>data.frame</code> that holds the spline bases for a section. 
It is indexed by columns named <code>col</code> and <code>row</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sections</code></td>
<td>
<p>A single <code>character</code> string that species the name of the column 
in the <code>data.frame</code> that contains the <code>factor</code> 
that identifies different sections of the data 
to which separate spatial models are to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code>numeric</code> 
column in the <code>data.frame</code> that contains the values of a 
covariate indexing the rows of the grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code>numeric</code> 
column in the <code>data.frame</code> that contains the values of a 
covariate indexing the columns of the grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsegs</code></td>
<td>
<p>A pair of <code>numeric</code> values giving the number of segments into
which the column and row ranges are to be split, respectively, for fitting 
a P-spline model (<code>TPPS</code>) (each value specifies the number of internal 
knots + 1). If not specified, then (number of unique values - 1) is used 
in each dimension; for a grid layout with equal spacing, this gives a knot 
at each data value. If <code>sections</code> is not <code>NULL</code> and the grid 
differs between the <code>sections</code>, then <code>nsegs</code> will differ between 
the <code>sections</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nestorder</code></td>
<td>
<p>A <code>numeric</code> of length 2. The order of nesting for column 
and row dimensions, respectively, in fitting a P-spline model (<code>TPPS</code>). 
A value of 1 specifies no nesting, a value of 2 generates a spline with 
half the number of segments in that 
dimension, etc. The number of segments in each direction must be a 
multiple of the order of nesting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>A <code>numeric</code>  of length 2. The degree of polynomial spline to 
be used for column and row dimensions respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>difforder</code></td>
<td>
<p>A <code>numeric</code> of length 2. The order of differencing for 
column and row dimensions, respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotateX</code></td>
<td>
<p>A <code>logical</code> indicating whether to rotate the eigenvectors of the 
penalty matrix, as described by Piepho, Boer and Williams (2022), when 
fitting a P-spline (<code>TPPS</code>). Setting <code>rotateX</code> to <code>TRUE</code> 
results in a search for an optimized rotation under a model that omits 
the random spline interaction terms. If <code>ngridangles</code> is set to 
<code>NULL</code>, the optimal rotation us found using an optimizer 
(<code>nloptr::bobyqa</code>). Otherwise, the optimal rotation is found by 
exploring the fit over a  two-dimensional grid of rotation angle pairs. 
The optimization seeks to optimize the criterion nominated in 
<code>which.rotacriterion</code>. Rotation of the eigenvectors is only relevant 
for <code>difforder</code> values greater than 1 and has only been implemented 
for <code>difforder</code> equal to 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>A <code>numeric</code> of length 2. The angle (in degrees) to be used in 
rotating the eignevectors of the penalty matrix of a P-spline (<code>TPPS</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asreml.option</code></td>
<td>
<p>A single <code>character</code> string specifying whether the <code>grp</code> or 
<code>mbf</code> methods are to be used to supply externally formed covariate 
matrices to <code>asreml</code> when fitting a P-spline (<code>TPPS</code>). Compared 
to the <code>mbf</code> method, the <code>grp</code> method is somewhat faster, but 
creates large <code>asrtests.object</code>s for which the time it takes 
to save them can exceed any gains in execution speed. The <code>grp</code> 
method adds columns to the <code>data.frame</code> containing the <code>data</code>. 
On the other hand, the <code>mbf</code> method adds only the fixed covariates 
to <code>data</code> and stores the random covariates in the environment of the 
internal function that calls the spline-fitting function; there are three smaller 
<code>data.frames</code> for each <code>section</code> that are not stored in the 
<code>asreml.object</code> resulting from the fitted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mbf.env</code></td>
<td>
<p>A <code>environment</code> specifying the environment to which the 
<code>data.frames</code> containing the spline bases are to be assigned. 
If <code>mbf.env</code> is <code>NULL</code>, the data.frames will not be assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>tpsmmb</code> from package <code>TPSbits</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The objects are formed using the function <code>tpsmmb</code> from the <code>R</code> package <code>TPSbits</code> 
authored by Sue Welham (2022). This function has been extended to allow for <code>sections</code> (see below) 
and to allow rotation of the penalty matrix for the linear component of the interaction terms in 
<code>TPPCS</code> models (for more information about rotation see Piepho, Boer and Williams, 2022).
</p>
<p>Each combination of a <code>row.covar</code> and a <code>col.covar</code> does not have to specify a 
single observation; for example, to fit a local spatial variation model to the main units 
of a split-unit design, each combination would correspond to a main unit and all subunits 
of the main unit would have the same combination.
</p>
<p>The data for experiment can be divided <code>sections</code> and the spline bases and associated 
data will be produced for each section. If there is more than one <code>sections</code>, then a 
<code>list</code> is returned that has a component for each section. The component for 
a section contains:
</p>


<h3>Value</h3>

<p>A <code>list</code> of length equal to the number of sections is produced. Each of 
these components is a <code>list</code> with 8 or 9 components. The component 
named <code>data.plus</code>, being the input <code>data.frame</code> to which has been added 
the columns required to fit the <code>TPPS</code> model (the <code>data.frame</code> stored 
in the <code>data</code> component holds only the covariates from <code>data</code>).
</p>
<p>List of length 8 or 9 (according to the <code>asreml.option</code>).
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required 
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:diff.c = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:diff.r = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:(diff.c*diff.r) = interaction between the
two X parts for use in fixed model. The first variate is 
a constant term which should be omitted from the model when the constant 
(1) is present. If all elements are included in the model then the 
constant term should be omitted,eg. 
<code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li>
<p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis 
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li>
</ul>
</li>
<li> <p><code>mbflist</code> = list that can be used in call to asreml (so long as Z 
matrix data frames extracted with right names, eg BcZ&lt;stub&gt;.df)
</p>
</li>
<li> <p><code>BcZ.df</code> = mbf data frame mapping onto smooth part of column
spline, last column (labelled <code>TP.col</code>) gives column index
</p>
</li>
<li> <p><code>BrZ.df</code> = mbf data frame mapping onto smooth part of row spline,
last column (labelled <code>TP.row</code>) gives row index
</p>
</li>
<li> <p><code>BcrZ.df</code> = mbf data frame mapping onto smooth x smooth term, last
column (labelled <code>TP.CxR</code>) maps onto col x row combined index
</p>
</li>
<li> <p><code>dim</code> = list structure, holding dimension values relating to the
model:
</p>

<ol>
<li> <p><code>"diff.c"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbc"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbcn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
<li> <p><code>"diff.r"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbr"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbrn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
</ol>
</li>
<li> <p><code>trace</code> = list of trace values for ZGZ' for the random TPspline
terms, where Z is the design matrix and G is the known diagonal variance
matrix derived from eigenvalues. This can  be used to rescale the spline 
design matrix (or equivalently variance components).
</p>
</li>
<li> <p><code>grp</code> = list structure, only added for setting <code>asreml="grp"</code>. 
For <code>asreml="grp"</code>, provides column indexes for each of the 5 
random components of the 2D splines in <code>data.plus</code>. Dimensions of 
the components can be derived from the values in the <code>dim</code> item.  
</p>
</li>
<li> <p><code>data.plus</code> = the input <code>data.frame</code> to which has been  
added the columns required to fit tensor product splines in <code>asreml-R</code>. 
This <code>data.frame</code> can be used to fit the TPS model.  
FOr multiple <code>sections</code>, this <code>data.frame</code> will occur 
in the component for each section. If <code>asreml.option</code> is set to 
<code>mbf</code>, then this component will have the <code>attribute</code> <code>mbf.env</code> 
that specifies the environment to which the <code>data.frames</code> 
containing the spline bases have been assigned. 
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H-P, Boer, M. P. &amp; Williams, E. R. (2022) Two-dimensional P-spline smoothing for spatial analysis of plant breeding trials. <em>Biometrical Journal</em>, <b>64</b>, 835-857.)
</p>
<p>Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., &amp; Eilers, P. H. C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. <em>Spatial Statistics</em>, <b>23</b>, 52-71. 
</p>
<p>Welham, S. J. (2022) <code>TPSbits</code>: <em>Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R.</em> Version 1.0.0 <a href="https://mmade.org/tpsbits/">https://mmade.org/tpsbits/</a></p>


<h3>See Also</h3>

<p><code>addSpatialModel.asrtests</code>, <code>addSpatialModelOnIC.asrtests</code>, <br><code>chooseSpatialModelOnIC.asrtests</code>, <code>tpsmmb</code> from <code>TPSbits</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

data(Wheat.dat)

#Add row and column covariates
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn  - mean(unique(cColumn))
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                    })

#Set up the matrices
tps.XZmat &lt;- makeTPPSplineMats(wheat.dat, 
                                row.covar = "cRow", col.covar = "cColumn")

## End(Not run)</code></pre>


</div>