<div class="container">

<table style="width: 100%;"><tr>
<td>bestfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Best-fitting of Arps decline curves</h2>

<h3>Description</h3>

<p>Perform best-fits of Arps decline curves to rate or cumulative data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">best.exponential(q, t,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10) # = 0.99995 / [time] effective
  )

best.hyperbolic(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2)  # b &lt;= 2.0
  )

best.hyp2exp(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2,  # b &lt;= 2.0
    0.35) # Df &lt;= 0.35
  )

best.exponential.curtailed(q, t,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0, # D &gt; 0
    0  # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    t[length(t)])
  )

best.hyperbolic.curtailed(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0,  # b &gt; 0
    0   # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2,  # b &lt;= 2.0
    t[length(t)])
  )

best.hyp2exp.curtailed(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0,  # Df &gt; 0
    0   # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2,  # b &lt;= 2.0
    0.35, # Df &lt;= 0.35
    t[length(t)])
  )

best.fit(q, t)

best.curtailed.fit(q, t)

best.exponential.from.Np(Np, t,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10) # = 0.99995 / [time] effective)
  )

best.exponential.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10) # = 0.99995 / [time] effective)
  )

best.hyperbolic.from.Np(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    2)  # b &lt;= 2.0
  )

best.hyperbolic.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    2)  # b &lt;= 2.0
  )

best.hyp2exp.from.Np(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35) # Df &lt;= 0.35
  )

best.hyp2exp.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35) # Df &lt;= 0.35
  )

best.exponential.curtailed.from.Np(Np, t,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0, # D &gt; 0
    0  # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    t[length(t)])
  )

best.exponential.curtailed.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0, # D &gt; 0
    0  # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    t[length(t)])
  )

best.hyperbolic.curtailed.from.Np(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0,  # b &gt; 0
    0   # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    t[length(t)])
  )

best.hyperbolic.curtailed.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0,  # b &gt; 0
    0   # t.curtail &gt; 0
  ),
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    t[length(t)])
  )

best.hyp2exp.curtailed.from.Np(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0,  # Df &gt; 0
    0
  ),
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35, # Df &lt;= 0.35
    t[length(t)])
  )

best.hyp2exp.curtailed.from.interval(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0,  # Df &gt; 0
    0
  ),
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35, # Df &lt;= 0.35
    t[length(t)])
  )

best.fit.from.Np(Np, t)

best.fit.from.interval(volume, t, t.begin=0.0)

best.curtailed.fit.from.Np(Np, t)

best.curtailed.fit.from.interval(volume, t, t.begin=0.0)

best.exponential.with.buildup(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10),        # = 0.99995 / [time] effective
  initial.rate=q[1], time.to.peak=t[which.max(q)])

best.hyperbolic.with.buildup(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2), # b &lt;= 2.0
  initial.rate=q[1], time.to.peak=t[which.max(q)])

best.hyp2exp.with.buildup(q, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(q) * 5, # qi &lt; qmax * 5
    10, # = 0.99995 / [time] effective
    2,  # b &lt;= 2.0
    0.35), # Df &lt;= 0.35
  initial.rate=q[1], time.to.peak=t[which.max(q)])

best.fit.with.buildup(q, t)

best.exponential.from.Np.with.buildup(Np, t,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10), # = 0.99995 / [time] effective
  initial.rate=Np[1] / t[1],
  time.to.peak=(t[which.max(diff(Np))] + t[which.max(diff(Np)) + 1]) / 2.0)

best.exponential.from.interval.with.buildup(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0, # qi &gt; 0
    0), # D &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10), # = 0.99995 / [time] effective
  initial.rate=volume[1] / (t[1] - t.begin),
  time.to.peak=(t - diff(c(t.begin, t)) / 2)[which.max(volume)])

best.hyperbolic.from.Np.with.buildup(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    2), # b &lt;= 2.0
  initial.rate=Np[1] / t[1],
  time.to.peak=(t[which.max(diff(Np))] + t[which.max(diff(Np)) + 1]) / 2.0)

best.hyperbolic.from.interval.with.buildup(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0,  # Di &gt; 0
    0), # b &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    2), # b &lt;= 2.0
  initial.rate=volume[1] / (t[1] - t.begin),
  time.to.peak=(t - diff(c(t.begin, t)) / 2)[which.max(volume)])

best.hyp2exp.from.Np.with.buildup(Np, t,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(c(Np[1], diff(Np)) / diff(c(0, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35), # Df &lt;= 0.35
  initial.rate=Np[1] / t[1],
  time.to.peak=(t[which.max(diff(Np))] + t[which.max(diff(Np)) + 1]) / 2.0)

best.hyp2exp.from.interval.with.buildup(volume, t, t.begin=0.0,
  lower=c( # lower bounds
    0,  # qi &gt; 0
    0.35,  # Di &gt; 0
    0,  # b &gt; 0
    0), # Df &gt; 0
  upper=c( # upper bounds
    max(volume / diff(c(t.begin, t))) * 5, # qi &lt; max(rate) * 5
    10, # = 0.99995 / [time] effective
    5,  # b &lt;= 2.0
    0.35), # Df &lt;= 0.35
  initial.rate=volume[1] / (t[1] - t.begin),
  time.to.peak=(t - diff(c(t.begin, t)) / 2)[which.max(volume)])

best.fit.from.Np.with.buildup(Np, t)

best.fit.from.interval.with.buildup(volume, t, t.begin=0.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>vector of rate data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Np</code></td>
<td>
<p>vector of cumulative production data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>volume</code></td>
<td>
<p>vector of interval volume data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>vector of times at which <code>q</code>, <code>Np</code>, or <code>volume</code> is measured.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.begin</code></td>
<td>
<p>initial time for interval volume data, if non-zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>lower bounds for decline parameters (sane defaults are provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>upper bounds for decline parameters (sane defaults are provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.rate</code></td>
<td>
<p>initial rate, for declines with buildup.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.to.peak</code></td>
<td>
<p>time to peak rate, for declines with buildup.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Best-fitting is carried out by minimizing the sum of squared error in the
rate or cumulative forecast, using <code>nlminb</code> as the optimizer.
</p>
<p>Appropriate bounds are applied to decline-curve parameters by default, but
may be altered using the <code>lower</code> and <code>upper</code> arguments to each
specific function.
</p>


<h3>Value</h3>

<p><code>best.exponential</code>, <code>best.hyperbolic</code>, and <code>best.hyp2exp</code>
return objects of the appropriate class (as from <code>arps.decline</code>)
representing best fits of the appropriate type against <code>q</code> and
<code>t</code>, in the same units as <code>q</code> and <code>t</code>.
</p>
<p><code>best.fit</code> returns the best overall fit, considering results from each
function above.
</p>
<p><code>best.exponential.from.Np</code>, <code>best.hyperbolic.from.Np</code>, and
<code>best.hyp2exp.from.Np</code> return objects of the appropriate class (as
from <code>arps.decline</code>) representing best fits of the appropriate type
against <code>Np</code> and <code>t</code>, in the same units as <code>Np</code> and <code>t</code>.
</p>
<p><code>best.fit.from.Np</code> returns the best overall fit, considering results
from each function above.
</p>
<p><code>best.exponential.from.interval</code>, <code>best.hyperbolic.from.interval</code>,
and <code>best.hyp2exp.from.interval</code> return objects of the appropriate
class (as from <code>arps.decline</code>) representing best fits of the
appropriate type against <code>volume</code> and <code>t</code>, in the same units as
<code>volume</code> and <code>t</code>.
</p>
<p>For these functions, <code>t</code> is taken to represent the time at the end of
each producing interval; the beginning time for the first interval may be
specified as <code>t.begin</code> if it is non-zero.
</p>
<p><code>best.fit.from.interval</code> returns the best overall fit, considering
results from each function above.
</p>
<p><code>best.exponential.curtailed</code>, <code>best.hyperbolic.curtailed</code>,
<code>best.hyp2exp.curtailed</code>, <code>best.curtailed.fit</code>,
<code>best.exponential.curtailed.from.Np</code>,
<code>best.hyperbolic.curtailed.from.Np</code>,
<code>best.hyp2exp.curtailed.from.Np</code>, <code>best.curtailed.fit.from.Np</code>,
<code>best.exponential.curtailed.from.interval</code>,
<code>best.hyperbolic.curtailed.from.interval</code>,
<code>best.hyp2exp.curtailed.from.interval</code>, and
<code>best.curtailed.fit.from.interval</code> work as the corresponding functions
above, but may return curtailed declines (as from <code>curtail</code>).
</p>
<p><code>best.exponential.with.buildup</code>, <code>best.hyperbolic.with.buildup</code>,
<code>best.hyp2exp.with.buildup</code>, <code>best.fit.with.buildup</code>,
<code>best.exponential.from.Np.with.buildup</code>,
<code>best.hyperbolic.from.Np.with.buildup</code>,
<code>best.hyp2exp.from.Np.with.buildup</code>,
<code>best.fit.from.Np.with.buildup</code>,
<code>best.exponential.from.interval.with.buildup</code>,
<code>best.hyperbolic.from.interval.with.buildup</code>,
<code>best.hyp2exp.from.interval.with.buildup</code>, and
<code>best.fit.from.interval.with.buildup</code> work as the corresponding
functions above, but will return a fit including a linear buildup
portion (as from <code>arps.with.buildup</code>).
</p>


<h3>See Also</h3>

<p><code>arps</code>, <code>curtailed</code>, <code>arps.with.buildup</code>,
<code>nlminb</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">fitme.hyp2exp.t &lt;- seq(0, 5, 1 / 12) # 5 years
fitme.hyp2exp.q &lt;- hyp2exp.q(
    1000, # Bbl/d
    as.nominal(0.70), # / year
    1.9,
    as.nominal(0.15), # / year
    fitme.hyp2exp.t
) * rnorm(n=length(fitme.hyp2exp.t), mean=1, sd=0.1) # perturb

hyp2exp.fit &lt;- best.hyp2exp(fitme.hyp2exp.q, fitme.hyp2exp.t)
cat(paste("SSE:", hyp2exp.fit$sse))
dev.new()
plot(fitme.hyp2exp.q ~ fitme.hyp2exp.t, main="Hyperbolic-to-Exponential Fit",
     col="blue", log="y", xlab="Time", ylab="Rate")
lines(arps.q(hyp2exp.fit$decline, fitme.hyp2exp.t) ~ fitme.hyp2exp.t,
      col="red")
legend("topright", pch=c(1, NA), lty=c(NA, 1), col=c("blue", "red"), legend=c("Actual", "Fit"))
</code></pre>


</div>