<div class="container">

<table style="width: 100%;"><tr>
<td>aggregateColor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summarize Soil Colors</h2>

<h3>Description</h3>

<p>Summarize soil color data, weighted by occurrence and horizon thickness.
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregateColor(
  x,
  groups = "genhz",
  col = "soil_color",
  colorSpace = "CIE2000",
  k = NULL,
  profile_wt = NULL,
  mixingMethod = c("estimate", "exact")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>the name of a horizon or site attribute used to group horizons, see examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>the name of a horizon-level attribute with soil color specified in hexadecimal (i.e. "#rrggbb")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorSpace</code></td>
<td>
<p>(now deprecated, removed in aqp 2.1) 'CIE2000' used for all cases</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>single integer specifying the number of colors discretized via PAM (<code>cluster::pam()</code>), see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profile_wt</code></td>
<td>
<p>the name of a site-level attribute used to modify weighting, e.g. area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mixingMethod</code></td>
<td>
<p>method used to estimate "aggregate" soil colors, see <code>mixMunsell()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Weights are computed by:
<code>w_i = sqrt(sum(thickness_i)) * n_i</code>
where <code>w_i</code> is the weight associated with color <code>i</code>, <code>thickness_i</code> is the total thickness of all horizons associated with the color <code>i</code>, and <code>n_i</code> is the number of horizons associated with color <code>i</code>. Weights are computed within groups specified by <code>groups</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>scaled.data</code></td>
<td>
<p>a <code>list</code> of colors and associated weights, one item for each generalized horizon label with at least one color specified in the source data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate.data</code></td>
<td>
<p>a <code>data.frame</code> of weighted-mean colors, one row for each generalized horizon label with at least one color specified in the source data</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code>generalize.hz()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# load some example data
data(sp1, package='aqp')

# upgrade to SoilProfileCollection and convert Munsell colors
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# generalize horizon names
n &lt;- c('O', 'A', 'B', 'C')
p &lt;- c('O', 'A', 'B', 'C')
sp1$genhz &lt;- generalize.hz(sp1$name, n, p)

# aggregate colors over horizon-level attribute: 'genhz'
a &lt;- aggregateColor(sp1, groups = 'genhz', col = 'soil_color')

# check results
str(a)

## Not run: 
# aggregate colors over site-level attribute: 'group'
a &lt;- aggregateColor(sp1, groups = 'group', col = 'soil_color')

# aggregate colors over site-level attribute: 'group'
# discretize colors to 4 per group
a &lt;- aggregateColor(sp1, groups = 'group', col = 'soil_color', k = 4)

# aggregate colors over depth-slices
s &lt;- dice(sp1, c(5, 10, 15, 25, 50, 100, 150) ~ soil_color)
s$slice &lt;- paste0(s$top, ' cm')
s$slice &lt;- factor(s$slice, levels=guessGenHzLevels(s, 'slice')$levels)
a &lt;- aggregateColor(s, groups = 'slice', col = 'soil_color')

  # optionally plot with helper function
  if(require(sharpshootR))
    aggregateColorPlot(a)

# a more interesting example
  data(loafercreek, package = 'soilDB')
  
  # generalize horizon names using REGEX rules
  n &lt;- c('Oi', 'A', 'BA','Bt1','Bt2','Bt3','Cr','R')
  p &lt;- c('O', '^A$|Ad|Ap|AB','BA$|Bw', 
         'Bt1$|^B$','^Bt$|^Bt2$','^Bt3|^Bt4|CBt$|BCt$|2Bt|2CB$|^C$','Cr','R')
  loafercreek$genhz &lt;- generalize.hz(loafercreek$hzname, n, p)
  
  # remove non-matching generalized horizon names
  loafercreek$genhz[loafercreek$genhz == 'not-used'] &lt;- NA
  loafercreek$genhz &lt;- factor(loafercreek$genhz)
  
  a &lt;- aggregateColor(loafercreek, 'genhz')
  
  # plot results with helper function
  par(mar=c(1,4,4,1))
  aggregateColorPlot(a, print.n.hz = TRUE)
  
  # inspect aggregate data
  a$aggregate.data

## End(Not run)

</code></pre>


</div>