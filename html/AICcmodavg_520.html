<div class="container">

<table style="width: 100%;"><tr>
<td>modavgEffect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model-averaged Effect Sizes (Multimodel Inference on Group Differences)
</h2>

<h3>Description</h3>

<p>This function model-averages the effect size between two groups
defined by a categorical variable based on the entire model set and
computes the unconditional standard error and unconditional confidence
intervals as described in Buckland et al. (1997) and Burnham and
Anderson (2002).  This can be particularly useful when dealing with
data from an experiment (e.g., ANOVA) and when the focus is to
determine the effect of a given factor.  This is an
information-theoretic alternative to multiple comparisons (e.g.,
Burnham et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">modavgEffect(cand.set, modnames = NULL, newdata, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised", conf.level = 0.95,
             ...)

## S3 method for class 'AICaov.lm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICglm.lm'
modavgEffect(cand.set, modnames = NULL, newdata, 
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, gamdisp = NULL,
        ...)

## S3 method for class 'AICgls'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClme'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICmer'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICglmerMod'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AIClmerMod'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICrlm.lm'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICsurvreg'
modavgEffect(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICunmarkedFitOccu'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuRN'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCO'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGDS'
modavgEffect(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgEffect(cand.set, modnames =
       NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
       "revised", conf.level = 0.95, type = "response",
       c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgEffect(cand.set, modnames =
        NULL, newdata, second.ord = TRUE, nobs = NULL, uncond.se =
        "revised", conf.level = 0.95, type = "response",
        c.hat = 1, parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>a data frame with two rows and where the columns correspond to the
explanatory variables specified in the candidate models. Note that this
data set must have the same structure as that of the original data frame
for which we want to make predictions, specifically, the same variable
type and names that appear in the original data set.  Each row of the
data set defines one of the two groups compared.  The first row in
<code>newdata</code> defines the first group, whereas the second row defines
the second group.  The effect size is computed as the prediction in the
first row minus the prediction in the second row (first row - second 
row). Only the column relating to the grouping variable can change value
and all others must be held constant for the comparison (see 'Details').
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order Akaike
information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows the specification of a numeric value other than
total sample size to compute the AICc (i.e., <code>nobs</code> defaults to
total number of observations).  This is relevant only for mixed models
or various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.  Note that versions of package AICcmodavg &lt; 1.04 used the old
method to compute unconditional standard errors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of 
unconditional confidence intervals.  To obtain confidence intervals
corrected for multiple comparisons between pairs of treatments, it is
possible to adjust the <code class="reqn">\alpha</code> level according to various
strategies such as the Bonferroni correction (Dunn 1961).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>the scale of prediction requested, one of <code>"response"</code> or
<code>"link"</code> (only relevant for <code>glm</code>, <code>mer</code>, and
<code>unmarkedFit</code> classes).  Note that the value <code>"terms"</code> is not
defined for <code>modavgEffect</code>).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such  
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), or <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011).  If <code>c.hat &gt; 1</code>, <code>modavgEffect</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).  This option is not
supported for generalized linear mixed models of the <code>mer</code> class.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamdisp</code></td>
<td>

<p>if gamma GLM is used, the dispersion parameter should be specified here
to apply the same value to each model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>

<p>this argument specifies the parameter type on which the effect size 
will be computed and is only relevant for models of <code>unmarkedFit</code>
classes.  The character strings supported vary with the type of model
fitted.  For <code>unmarkedFitOccu</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is on
occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code> denote
parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.  For
<code>unmarkedFitOccuMS</code> objects, <code>psi</code>, <code>phi</code>, and
<code>detect</code> denote occupancy, transition, and detection probability,
respectively.  For <code>unmarkedFitOccuMulti</code> objects, <code>psi</code> and
<code>detect</code> denote occupancy and detection probability,
respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The strategy used here to compute effect sizes is to work from the
<code>newdata</code> object to create two predictions from a given model and
compute the differences and standard errors between both values.  This 
step is executed for each model in the candidate model set, to obtain a
model-averaged estimate of the effect size and unconditional standard
error.  As a result, the <code>newdata</code> argument is restricted to two
rows, each for a given prediction.  To specify each group, the values
entered in the column for each explanatory variable can be identical,
except for the grouping variable.  In such a case, the function will
identify the variable and the assign group names based on the values of 
the variable.  If more than a single variable has different values in
its respective column, the function will print generic names in the
output to identify the two groups.  A sensible choice of value for the 
explanatory variables to be held constant is the average of the
variable.
</p>
<p>Model-averaging effect sizes is most useful in true experiments (e.g.,
ANOVA-type designs), where one wants to obtain the best estimate of
effect size given the support of each candidate model. This can be
considered as a information-theoretic analog of traditional multiple
comparisons, except that the information contained in the entire model
set is used instead of being restricted to a single model.  See
'Examples' below for applications.
</p>
<p><code>modavgEffect</code> calls the appropriate method depending on the class
of objects in the list.  The current classes supported include
<code>aov</code>, <code>glm</code>, <code>gls</code>, <code>lm</code>, <code>lme</code>, <code>mer</code>,
<code>glmerMod</code>, <code>lmerMod</code>, <code>lmerModLmerTest</code>, <code>rlm</code>,
<code>survreg</code>, as well as models of <code>unmarkedFitOccu</code>,
<code>unmarkedFitColExt</code>, <code>unmarkedFitOccuFP</code>,
<code>unmarkedFitOccuRN</code>, <code>unmarkedFitOccuTTD</code>,
<code>unmarkedFitPCount</code>, <code>unmarkedFitPCO</code>, <code>unmarkedFitDS</code>,
<code>unmarkedFitDSO</code>, <code>unmarkedFitGDS</code>, <code>unmarkedFitMPois</code>,
<code>unmarkedFitGMM</code>, <code>unmarkedFitMMO</code>, <code>unmarkedFitGPC</code>,
<code>unmarkedFitOccuMS</code>, and <code>unmarkedFitOccuMulti</code>.
classes.
</p>


<h3>Value</h3>

<p>The result is an object of class <code>modavgEffect</code> with the following
components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Group.variable</code></td>
<td>
<p>the grouping variable defining the two groups
compared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Group1</code></td>
<td>
<p>the first group considered in the comparison.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Group2</code></td>
<td>
<p>the second group considered in the comparison.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Type</code></td>
<td>
<p>the scale on which the model-averaged effect size was
computed (e.g., response or link).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.table</code></td>
<td>
<p>the full model selection table including the
entire set of candidate models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.eff</code></td>
<td>
<p>the model-averaged effect size based on the entire
candidate model set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
effect size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Matrix.output</code></td>
<td>
<p>a matrix containing the model-averaged effect size,
the unconditional standard error, and the lower and upper confidence
limits.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603–618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological
Methods and Research</em> <b>33</b>, 261–304.
</p>
<p>Burnham, K. P., Anderson, D. R., Huyvaert, K. P. (2011) AIC model
selection and multimodel inference in behaviorial ecology: some
background, observations and comparisons. <em>Behavioral Ecology and 
Sociobiology</em> <b>65</b>, 23–25. 
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587.
</p>
<p>Dunn, O. J. (1961) Multiple comparisons among means. <em>Journal of the
American Statistical Association</em> <b>56</b>, 52–64.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169–180. 
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>c_hat</code>,
<code>confset</code>, <code>evidence</code>, <code>importance</code>,
<code>modavgShrink</code>, <code>modavgPred</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##heights (cm) of plants grown under two fertilizers, Ex. 9.5 from
##Zar (1984): Biostatistical Analysis. Prentice Hall: New Jersey.
heights &lt;- data.frame(Height = c(48.2, 54.6, 58.3, 47.8, 51.4, 52.0,
                        55.2, 49.1, 49.9, 52.6, 52.3, 57.4, 55.6, 53.2,
                        61.3, 58.0, 59.8, 54.8),
                      Fertilizer = c(rep("old", 10), rep("new", 8)))

##run linear model hypothesizing an effect of fertilizer
m1 &lt;- lm(Height ~ Fertilizer, data = heights)

##run null model (no effect of fertilizer)
m0 &lt;- lm(Height ~ 1, data = heights)

##assemble models in list
Cands &lt;- list(m1, m0)
Modnames &lt;- c("Fert", "null")

##compute model selection table to compare
##both hypotheses
aictab(cand.set = Cands, modnames = Modnames)
##note that model with fertilizer effect is much better supported
##than the null

##compute model-averaged effect sizes: one model hypothesizes a
##difference of 0, whereas the other assumes a difference

##prepare newdata object from which differences between groups
##will be computed
##the first row of the newdata data.frame relates to the first group,
##whereas the second row corresponds to the second group
pred.data &lt;- data.frame(Fertilizer = c("new", "old"))

##compute best estimate of effect size accounting for model selection
##uncertainty
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = pred.data)


##classical one-way ANOVA type-design
## Not run: 
##generate data for two groups and control
set.seed(seed = 15)
y &lt;- round(c(rnorm(n = 15, mean = 10, sd = 5),
       rnorm(n = 15, mean = 15, sd = 5),
       rnorm(n = 15, mean = 12, sd = 5)), digits = 2)
##groups
group &lt;- c(rep("cont", 15), rep("trt1", 15), rep("trt2", 15))

##combine in data set
aov.data &lt;- data.frame(Y = y, Group = group)
rm(y, group)

##run model with group effect
lm.eff &lt;- lm(Y ~ Group, data = aov.data)
##null model
lm.0 &lt;- lm(Y ~ 1, data = aov.data)

##compare both models
Cands &lt;- list(lm.eff, lm.0)
Mods &lt;- c("group effect", "no group effect")
aictab(cand.set = Cands, modnames = Mods)
##model with group effect has most of the weight

##compute model-averaged effect sizes
##trt1 - control
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = data.frame(Group = c("trt1", "cont")))
##trt1 differs from cont

##trt2 - control
modavgEffect(cand.set = Cands, modnames = Modnames,
              newdata = data.frame(Group = c("trt2", "cont")))
##trt2 does not differ from cont

## End(Not run)


##two-way ANOVA type design, Ex. 13.1 (Zar 1984) of plasma calcium
##concentration (mg/100 ml) in birds as a function of sex and hormone
##treatment
## Not run: 
birds &lt;- data.frame(Ca = c(16.87, 16.18, 17.12, 16.83, 17.19, 15.86,
                      14.92, 15.63, 15.24, 14.8, 19.07, 18.77, 17.63,
                      16.99, 18.04, 17.2, 17.64, 17.89, 16.78, 16.92,
                      32.45, 28.71, 34.65, 28.79, 24.46, 30.54, 32.41,
                      28.97, 28.46, 29.65),
                    Sex = c("M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F", "M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F", "M", "M", "M", "M", "M", "F", "F", "F", "F",
                      "F"),
                    Hormone = as.factor(c(1, 1, 1, 1, 1, 1, 1, 1, 1,
                      1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                      3, 3, 3, 3, 3)))

##candidate models
##interactive effects
m.inter &lt;- lm(Ca ~ Sex + Hormone + Sex:Hormone, data = birds)

##additive effects
m.add &lt;- lm(Ca ~ Sex + Hormone, data = birds)

##Sex only
m.sex &lt;- lm(Ca ~ Sex, data = birds)

##Hormone only
m.horm &lt;- lm(Ca ~ Hormone, data = birds)

##null
m.0 &lt;- lm(Ca ~ 1, data = birds)

##model selection
Cands &lt;- list(m.inter, m.add, m.sex, m.horm, m.0)
Mods &lt;- c("interaction", "additive", "sex only", "horm only", "null")
aictab(Cands, Mods)
##there is some support for a hormone only treatment, but also for
##additive effects

##compute model-averaged effects of sex, and set the other variable
##to a constant value
##M - F
sex.data &lt;- data.frame(Sex = c("M", "F"), Hormone = c("1", "1"))
modavgEffect(Cands, Mods, newdata = sex.data)
##no support for a sex main effect

##hormone 1 - 3, but set Sex to a constant value
horm1.data &lt;- data.frame(Sex = c("M", "M"), Hormone = c("1", "3"))
modavgEffect(Cands, Mods, newdata = horm1.data)

##hormone 2 - 3, but set Sex to a constant value
horm2.data &lt;- data.frame(Sex = c("M", "M"), Hormone = c("2", "3"))
modavgEffect(Cands, Mods, newdata = horm2.data)

## End(Not run)


##Poisson regression with anuran larvae example from Mazerolle (2006)
## Not run: 
data(min.trap)
##assign "UPLAND" as the reference level as in Mazerolle (2006)          
min.trap$Type &lt;- relevel(min.trap$Type, ref = "UPLAND") 

##set up candidate models          
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ log.Perimeter, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ Type, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[4]] &lt;- glm(Num_anura ~ 1, family = poisson,
                     offset = log(Effort), data = min.trap) 
          
##check c-hat for global model
vif.hat &lt;- c_hat(Cand.mod[[1]]) #uses Pearson's chi-square/df

##assign names to each model
Modnames &lt;- c("type + logperim", "type", "logperim", "intercept only") 

##compute model-averaged estimate of difference between abundance at bog
##pond and upland pond
##create newdata object to make predictions
pred.data &lt;- data.frame(Type = c("BOG", "UPLAND"),
                        log.Perimeter = mean(min.trap$log.Perimeter),
                        Effort = mean(min.trap$Effort))
modavgEffect(Cand.mod, Modnames, newdata = pred.data, c.hat = vif.hat,
             type = "response")
##little suport for a pond type effect

## End(Not run)


##mixed linear model example from ?nlme
## Not run: 
library(nlme)
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lme(distance ~ age, data = Orthodont, method="ML")
Cand.models[[2]] &lt;- lme(distance ~ age + Sex, data = Orthodont,
                        random = ~ 1, method="ML")
Cand.models[[3]] &lt;-lme(distance ~ 1, data = Orthodont, random = ~ 1,
                       method="ML")
Cand.models[[4]] &lt;-lme(distance ~ Sex, data = Orthodont, random = ~ 1,
                       method="ML")

Modnames &lt;- c("age", "age + sex", "null", "sex")

data.other &lt;- data.frame(age = mean(Orthodont$age),
                         Sex = factor(c("Male", "Female"))) 
modavgEffect(cand.set = Cand.models, modnames = Modnames,
             newdata = data.other, conf.level = 0.95, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised")
detach(package:nlme)

## End(Not run)


##site occupancy analysis example
## Not run: 
library(unmarked)
##single season model
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
##create a bogus site group
site.group &lt;- c(rep(1, times = nrow(pfer.bin)/2), rep(0, nrow(pfer.bin)/2))

## add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(site.group, sitevar1 =
                                rnorm(numSites(pferUMF)),
                                sitevar2 = runif(numSites(pferUMF)))
     
## observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 =
                               rnorm(numSites(pferUMF) * obsNum(pferUMF)))
     
fm1 &lt;- occu(~ obsvar1 ~ site.group, pferUMF)
fm2 &lt;- occu(~ obsvar1 ~ 1, pferUMF)

Cand.mods &lt;- list(fm1, fm2)
Modnames &lt;- c("fm1", "fm2")

##model selection table
aictab(cand.set = Cand.mods, modnames = Modnames, second.ord = TRUE)

##model-averaged effect sizes comparing site.group 1 - site.group 0
newer.dat &lt;- data.frame(site.group = c(0, 1))

modavgEffect(cand.set = Cand.mods, modnames = Modnames, type = "response",
              second.ord = TRUE, newdata = newer.dat, parm.type = "psi")
##no support for an effect of site group

## End(Not run)


##single season N-mixture models
## Not run: 
data(mallard)
##this variable was created to illustrate the use of modavgEffect
##with detection variables
mallard.site$site.group &lt;- c(rep(1, 119), rep(0, 120))
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
siteCovs(mallardUMF)
tmp.covs &lt;- obsCovs(mallardUMF)
obsCovs(mallardUMF)$date2 &lt;- tmp.covs$date^2
(fm.mall &lt;- pcount(~ site.group ~ length + elev + forest, mallardUMF, K=30))
(fm.mallb &lt;- pcount(~ 1 ~ length + elev + forest, mallardUMF, K=30))
     
Cands &lt;- list(fm.mall, fm.mallb)
Modnames &lt;- c("one", "null")

##model averaged effect size of site.group 1 - site.group 0 on response
##scale (point estimate)
modavgEffect(Cands, Modnames, newdata = data.frame(site.group = c(0, 1)),
              parm.type = "detect", type = "response")

##model averaged effect size of site.group 1 - site.group 0 on link
##scale (here, logit link)
modavgEffect(Cands, Modnames, newdata = data.frame(site.group = c(0, 1)),
              parm.type = "detect", type = "link")

detach(package:unmarked)

## End(Not run)
</code></pre>


</div>