<div class="container">

<table style="width: 100%;"><tr>
<td>modular</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modular Functions for Mixed Model Fits</h2>

<h3>Description</h3>

<p>Modular functions for mixed model fits
</p>


<h3>Usage</h3>

<pre><code class="language-R">  glFormula(formula, data = NULL, family = gaussian,
            subset, weights, na.action, offset, contrasts = NULL,
            start, mustart, etastart, control = glmerControl(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided linear formula object
describing both the fixed-effects and random-effects parts
of the model, with the response on the left of a <code>~</code>
operator and the terms, separated by <code>+</code> operators,
on the right.  Random-effects terms are distinguished by
vertical bars (<code>"|"</code>) separating expressions for
design matrices from grouping factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the
variables named in <code>formula</code>.  By default the
variables are taken from the environment from which
<code>lmer</code> is called. While <code>data</code> is optional, the
package authors <em>strongly</em> recommend its use,
especially when later applying methods such as
<code>update</code> and <code>drop1</code> to the fitted model
(<em>such methods are not guaranteed to work properly
if <code>data</code> is omitted</em>). If <code>data</code> is omitted,
variables will be taken from the environment of
<code>formula</code> (if specified as a formula) or from the
parent frame (if specified as a character vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional expression indicating the
subset of the rows of <code>data</code> that should be used in
the fit. This can be a logical vector, or a numeric
vector indicating which observation numbers are to be
included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of ‘prior weights’ to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function that indicates what should
happen when the data contain <code>NA</code>s.  The default
action (<code>na.omit</code>, inherited from the 'factory
fresh' value of <code>getOption("na.action")</code>) strips any
observations with any missing values in any variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting.  This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code>offset</code>
terms can be included in the formula instead or as well, and if
more than one is specified their sum is used.  See
<code>model.offset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional <code>list</code>.  See the
<code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list giving
</p>

<dl>
<dt>for <code>[g]lFormula</code>:</dt>
<dd>
<p>all
options for running the model, see <code>lmerControl</code>;</p>
</dd>
<dt>for <code>mkLmerDevfun,mkGlmerDevfun</code>:</dt>
<dd>
<p>options
for the inner optimization step;</p>
</dd>
<dt>for <code>optimizeLmer</code> and <code>optimizeGlmer</code>:</dt>
<dd>
<p>control
parameters for nonlinear optimizer (typically inherited from the
... argument to <code>lmerControl</code>).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values (see <code>lmer</code>;
for <code>glFormula</code>, should be just a numeric vector of
fixed-effect coefficients)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a GLM family; see <code>glm</code>
and <code>family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>optional starting values on the scale of
the conditional mean; see <code>glm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>optional starting values on the scale of
the unbounded predictor; see <code>glm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other potential arguments; for <code>optimizeLmer</code> and
<code>optimizeGlmer</code>, these are passed to internal function
<code>optwrap</code>, which has relevant parameters <code>calc.derivs</code>
and <code>use.last.params</code> (see <code>lmerControl</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions make up the internal components of an [gn]lmer fit.
</p>

<ul>
<li> <p><code>[g]lFormula</code> takes the arguments that would normally be
passed to <code>[g]lmer</code>, checking for errors and processing the
formula and data input to create a list of objects required to fit a
mixed model.
</p>
</li>
<li> <p><code>mk(Gl|L)merDevfun</code> takes the output of the previous
step (minus the <code>formula</code> component) and creates a
deviance function
</p>
</li>
<li> <p><code>optimize(Gl|L)mer</code> takes a
deviance function and optimizes over <code>theta</code> (or
over <code>theta</code> and <code>beta</code>, if <code>stage</code> is set
to 2 for <code>optimizeGlmer</code>
</p>
</li>
<li> <p><code>updateGlmerDevfun</code> takes the first stage of a GLMM
optimization (with <code>nAGQ=0</code>, optimizing over <code>theta</code> only)
and produces a second-stage deviance function
</p>
</li>
<li> <p><code>mkMerMod</code> takes the <em>environment</em> of a
deviance function, the results of an optimization, a list of
random-effect terms, a model frame, and a model all and produces a
<code>[g]lmerMod</code> object.
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>lFormula</code> and <code>glFormula</code> return a list containing
components:
</p>

<dl>
<dt>fr</dt>
<dd>
<p>model frame</p>
</dd>
<dt>X</dt>
<dd>
<p>fixed-effect design matrix</p>
</dd>
<dt>reTrms</dt>
<dd>
<p>list containing information on random effects structure:
result of <code>mkReTrms</code></p>
</dd>
</dl>
<p><code>mkLmerDevfun</code> and <code>mkGlmerDevfun</code> return a function to
calculate deviance (or restricted deviance) as a function of the
theta (random-effect) parameters.  <code>updateGlmerDevfun</code>
returns a function to calculate the deviance as a function of a
concatenation of theta and beta (fixed-effect) parameters. These
deviance functions have an environment containing objects required
for their evaluation. CAUTION: The <code>environment</code> of
functions returned by <code>mk(Gl|L)merDevfun</code> contains reference
class objects (see <code>ReferenceClasses</code>,
<code>merPredD-class</code>, <code>lmResp-class</code>), which
behave in ways that may surprise many users. For example, if the
output of <code>mk(Gl|L)merDevfun</code> is naively copied, then
modifications to the original will also appear in the copy (and
vice versa). To avoid this behavior one must make a deep copy (see
<code>ReferenceClasses</code> for details).
</p>
<p><code>optimizeLmer</code> and <code>optimizeGlmer</code> return the results of an
optimization.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
  library(lme4)
  ### Fitting a linear mixed model in 4 modularized steps

  ## 1.  Parse the data and formula:
  lmod &lt;- lFormula(Reaction ~ Days + (Days|Subject), sleepstudy)
  names(lmod)
  ## 2.  Create the deviance function to be optimized:
  (devfun &lt;- do.call(mkLmerDevfun, lmod))
  ls(environment(devfun)) # the environment of 'devfun' contains objects
  # required for its evaluation
  ## 3.  Optimize the deviance function:
  opt &lt;- optimizeLmer(devfun)
  opt[1:3]
  ## 4.  Package up the results:
  mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr)


  ### Same model in one line
  lmer(Reaction ~ Days + (Days|Subject), sleepstudy)


  ### Fitting a generalized linear mixed model in six modularized steps

  ## 1.  Parse the data and formula:
  glmod &lt;- glFormula(cbind(incidence, size - incidence) ~ period + (1 | herd),
                     data = cbpp, family = binomial)
  #.... see what've got :
  str(glmod, max=1, give.attr=FALSE)
  ## 2.  Create the deviance function for optimizing over theta:
  (devfun &lt;- do.call(mkGlmerDevfun, glmod))
  ls(environment(devfun)) # the environment of devfun contains lots of info
  ## 3.  Optimize over theta using a rough approximation (i.e. nAGQ = 0):
  (opt &lt;- optimizeGlmer(devfun))
  ## 4.  Update the deviance function for optimizing over theta and beta:
  (devfun &lt;- updateGlmerDevfun(devfun, glmod$reTrms))
  ## 5.  Optimize over theta and beta:
  opt &lt;- optimizeGlmer(devfun, stage=2)
  str(opt, max=1) # seeing what we'got
  ## 6.  Package up the results:
  (fMod &lt;- mkMerMod(environment(devfun), opt, glmod$reTrms, fr = glmod$fr))

  ### Same model in one line
  fM &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial)
  all.equal(fMod, fM, check.attributes=FALSE, tolerance = 1e-12)
  # ----  --  even tolerance = 0  may work
  
</code></pre>


</div>