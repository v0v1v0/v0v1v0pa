<div class="container">

<table style="width: 100%;"><tr>
<td>newpickle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Penalized Quasi-Likelihood for Aster Models</h2>

<h3>Description</h3>

<p>Evaluates the objective function for approximate maximum likelihood for
an aster model with random effects.  Uses Laplace approximation to
integrate out the random effects analytically.
The “quasi” in the title is a misnomer in the context of aster
models but the acronym PQL for this procedure is well-established in
the generalized linear mixed models literature.
</p>


<h3>Usage</h3>

<pre><code class="language-R">newpickle(alphaceesigma, fixed, random, obj, y, origin, zwz, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alphaceesigma</code></td>
<td>
<p>the parameter value where the function is evaluated,
a numeric vector, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>the model matrix for fixed effects.  The number of rows
is <code>nrow(obj$data)</code>.  The number of columns is the number of fixed
effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>the model matrix or matrices for random effects.
The number of rows is <code>nrow(obj$data)</code>.  The number of columns
is the number of random effects in a group.  Either a matrix or a list
each element of which is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>aster model object, the result of a call to <code>aster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector.  May be omitted, in which case <code>obj$x</code>
is used.  If supplied, must be a matrix of the same dimensions as
<code>obj$x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p>origin of aster model.  May be omitted, in which case
default origin (see <code>aster</code>) is used.  If supplied, must be
a matrix of the same dimensions <code>obj$x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zwz</code></td>
<td>
<p>A possible value of <code class="reqn">Z^T W Z</code>, where <code class="reqn">Z</code> is the
model matrix for all random effects and <code class="reqn">W</code> is the variance matrix of
the response.  May be missing, in which case it is calculated from
<code>alphaceesigma</code>.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv</code></td>
<td>
<p>Number of derivatives wanted, either zero or one.
Must be zero if <code>zwz</code> is missing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">p(\alpha, c, \sigma) = m(a + M \alpha + Z A c) + c^T c / 2 + \log \det[A Z^T W(a + M \alpha + Z A c) Z A + I]</code>
</p>

<p>where <code class="reqn">m</code> is minus the log likelihood function of a saturated aster model,
where <code class="reqn">W</code> is the Hessian matrix of <code class="reqn">m</code>,
where <code class="reqn">a</code> is a known vector (the <em>offset vector</em> in the terminology
of <code>glm</code> but the <em>origin</em> in the terminology
of <code>aster</code>), where <code class="reqn">M</code> is a known matrix, the model matrix for
fixed effects (the argument <code>fixed</code> of this function),
<code class="reqn">Z</code> is a known matrix, the model matrix for random effects
(either the argument <code>random</code> of this functions if it is a matrix or
<code>Reduce(cbind, random)</code> if <code>random</code> is a list of matrices),
where <code class="reqn">A</code> is a diagonal matrix whose diagonal is the vector
<code>rep(sigma, times = nrand)</code>
where <code>nrand</code> is <code>sapply(random, ncol)</code>
when <code>random</code> is a list of
matrices and <code>ncol(random)</code> when <code>random</code> is a matrix,
and where <code class="reqn">I</code> is the identity matrix.
This function evaluates <code class="reqn">p(\alpha, c, \sigma)</code>
when <code>zwz</code> is missing.
Otherwise it evaluates the same thing except that
</p>
<p style="text-align: center;"><code class="reqn">Z^T W(a + M \alpha + Z A c) Z</code>
</p>

<p>is replaced by <code>zwz</code>.
Note that <code class="reqn">A</code> is a function of <code class="reqn">\sigma</code> although the
notation does not explicitly indicate this.
</p>


<h3>Value</h3>

<p>a list with components <code>value</code> and <code>gradient</code>,
the latter missing if <code>deriv == 0</code>.
</p>


<h3>Note</h3>

<p>Not intended for use by naive users.  Use <code>reaster</code>.
Actually no longer used by other functions in this package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(radish)

pred &lt;- c(0,1,2)
fam &lt;- c(1,3,2)

### need object of type aster to supply to penmlogl and pickle

aout &lt;- aster(resp ~ varb + fit : (Site * Region + Block + Pop),
    pred, fam, varb, id, root, data = radish)

### model matrices for fixed and random effects

modmat.fix &lt;- model.matrix(resp ~ varb + fit : (Site * Region),
    data = radish)
modmat.blk &lt;- model.matrix(resp ~ 0 + fit:Block, data = radish)
modmat.pop &lt;- model.matrix(resp ~ 0 + fit:Pop, data = radish)

rownames(modmat.fix) &lt;- NULL
rownames(modmat.blk) &lt;- NULL
rownames(modmat.pop) &lt;- NULL

idrop &lt;- match(aout$dropped, colnames(modmat.fix))
idrop &lt;- idrop[! is.na(idrop)]
modmat.fix &lt;- modmat.fix[ , - idrop]

nfix &lt;- ncol(modmat.fix)
nblk &lt;- ncol(modmat.blk)
npop &lt;- ncol(modmat.pop)

alpha.start &lt;- aout$coefficients[match(colnames(modmat.fix),
    names(aout$coefficients))]
cee.start &lt;- rep(0, nblk + npop)
sigma.start &lt;- rep(1, 2)
alphaceesigma.start &lt;- c(alpha.start, cee.start, sigma.start)

foo &lt;- newpickle(alphaceesigma.start, fixed = modmat.fix,
    random = list(modmat.blk, modmat.pop), obj = aout)
</code></pre>


</div>