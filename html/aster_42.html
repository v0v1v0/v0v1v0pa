<div class="container">

<table style="width: 100%;"><tr>
<td>predict.aster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict Method for Aster Model Fits</h2>

<h3>Description</h3>

<p>Obtains predictions (parameter estimates) and optionally estimates
standard errors of those predictions (parameter estimates) from
a fitted Aster model object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'aster'
predict(object, x, root, modmat, amat,
    parm.type = c("mean.value", "canonical"),
    model.type = c("unconditional", "conditional"),
    is.always.parameter = FALSE,
    se.fit = FALSE, info = c("expected", "observed"),
    info.tol = sqrt(.Machine$double.eps), newcoef = NULL,
    gradient = se.fit, ...)

## S3 method for class 'aster.formula'
predict(object, newdata, varvar, idvar, root, amat,
    parm.type = c("mean.value", "canonical"),
    model.type = c("unconditional", "conditional"),
    is.always.parameter = FALSE,
    se.fit = FALSE, info = c("expected", "observed"),
    info.tol = sqrt(.Machine$double.eps), newcoef = NULL,
    gradient = se.fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted object of class inheriting from <code>"aster"</code>
or <code>"aster.formula"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modmat</code></td>
<td>
<p>a model matrix to use instead of <code>object$modmat</code>.
Must have the same structure (three-dimensional array, first index runs
over individuals, second over nodes of the graphical model, third over
covariates).  Must have the same second and third dimensions as
<code>object$modmat</code>.  The second and third components of
<code>dimnames(modmat)</code> and <code>dimnames(object$modmat)</code> must also be
the same.
</p>
<p>May be missing, in which case <code>object$modmat</code> is used.
</p>
<p><code>predict.aster.formula</code> constructs such a <code>modmat</code> from
<code>object$formula</code>, the data frame <code>newdata</code>, and variables
in the environment of the formula.  When <code>newdata</code> is missing,
<code>object$modmat</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>response.  Ignored and may be missing unless
<code>parm.type = "mean.value"</code> and <code>model.type = "conditional"</code>.
Even then may be missing when <code>modmat</code> is missing,
in which case <code>object$x</code> is used.  A matrix whose first and
second dimensions and the corresponding dimnames agrees with
those of <code>modmat</code> and <code>object$modmat</code>.
</p>
<p><code>predict.aster.formula</code> constructs such an <code>x</code> from
the response variable name in <code>object$formula</code>,
the data frame <code>newdata</code>,
and the variables in the environment of the formula.  When <code>newdata</code>
is missing, <code>object$x</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>root data.  Ignored and may be missing unless
<code>parm.type == "mean.value"</code>.
Even then may be missing when <code>modmat</code> is missing,
in which case <code>object$root</code> is used.  A matrix of the
same form as <code>x</code>.
</p>
<p><code>predict.aster.formula</code> looks up the variable supplied as
the argument <code>root</code> in the data frame <code>newdata</code> or in
the variables in the environment of the formula and makes it a matrix
of the same form as <code>x</code>.  When <code>newdata</code>
is missing, <code>object$root</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amat</code></td>
<td>
<p>if <code>zeta</code> is the requested prediction (mean value
or canonical, unconditional or conditional, depending on <code>parm.type</code>
and <code>model.type</code>), then we predict the linear function
<code>t(amat) %*% zeta</code>.  May be missing, in which case the identity
linear function is used.
</p>
<p>For <code>predict.aster</code>, a three-dimensional
array with <code>dim(amat)[1:2] == dim(modmat)[1:2]</code>.
</p>
<p>For <code>predict.aster.formula</code>, a three-dimensional array
of the same dimensions as required for <code>predict.aster</code>
(even though <code>modmat</code> is not provided).  First dimension
is number of individuals in <code>newdata</code>, if provided, otherwise
number of individuals in <code>object$data</code>.  Second dimension
is number of variables (<code>length(object$pred)</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
<p>the type of parameter to predict.  The default is
mean value parameters (the opposite of the default
for <code>predict.glm</code>), the expected value of a linear function
of the response under the MLE probability model (also called the
MLE of the mean value parameter).  The expectation is unconditional
or conditional depending on <code>parm.type</code>.
</p>
<p>The alternative <code>"canonical"</code> is the value of a linear function
of the MLE of canonical parameters under the MLE probability model.
The canonical parameter is unconditional
or conditional depending on <code>parm.type</code>.
</p>
<p>The value of this argument can be abbreviated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.type</code></td>
<td>
<p>the type of model in which to predict.  The default is
<code>"unconditional"</code> in which case the parameters (either mean value
or canonical, depending on the value of <code>parm.type</code>) are those
of an unconditional model.
The alternative is <code>"conditional"</code> in which case the parameters
are those of a conditional model.
</p>
<p>The value of this argument can be abbreviated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.always.parameter</code></td>
<td>
<p>logical, default <code>FALSE</code>.
Only affects the result when <code>parm.type = "mean.value"</code> and
<code>model.type = "conditional"</code>.  <code>TRUE</code> means the conditional
mean value parameter is produced.  <code>FALSE</code> means the conditional
mean values themselves are produced (which depend on data so are not
parameters).  See Conditional Mean Values Section below for further
explanation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>the type of Fisher information to use to compute standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info.tol</code></td>
<td>
<p>tolerance for eigenvalues of Fisher information.
If <code>eval</code> is the vector of eigenvalues of the information matrix,
then <code>eval &lt; cond.tol * max(eval)</code> are considered zero.  Hence the
corresponding eigenvectors are directions of constancy or recession of
the log likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict.  If omitted, see <code>modmat</code> above.  See also details
section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varvar</code></td>
<td>
<p>a variable of length <code>nrow(newdata)</code>, typically a
variable in <code>newdata</code>
that is a factor whose levels are character strings
treated as variable names.  The number of variable names is <code>nnode</code>.
Must be of the form <code>rep(vars, each = nind)</code> where <code>vars</code> is
a vector of variable names.  Not used if <code>newdata</code> is missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idvar</code></td>
<td>
<p>a variable of length <code>nrow(newdata)</code>, typically a
variable in <code>newdata</code>
that indexes individuals.  The number
of individuals is <code>nind</code>.
Must be of the form <code>rep(inds, times = nnode)</code> where <code>inds</code> is
a vector of labels for individuals.  Not used if <code>newdata</code> is missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newcoef</code></td>
<td>
<p>if not <code>NULL</code>,
a variable of length <code>object$coefficients</code> and used
in its place when one wants predictions at other than the fitted
coefficient values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>if <code>TRUE</code> return the gradient (Jacobian of the
transformation) matrix.  This matrix has number of rows equal to the
length of the fitted values and number of columns equal to the number
of regression coefficients.  It is the derivative matrix (matrix of
partial derivatives) of the mapping from regression coefficients to
whatever the predicted values are, which depends on what the
arguments <code>newdata</code>, <code>amat</code>, <code>parm.type</code>, and
<code>model.type</code> are.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that <code>model.type</code> need have nothing to do with the type
of the fitted aster model, which is <code>object$type</code>.
</p>
<p>Whether the
fitted model is conditional or unconditional, one typically wants
<em>unconditional</em> mean value parameters, because conditional mean
value parameters for hypothetical individuals depend on the hypothetical
data <code>x</code>, which usually makes no scientific sense.
</p>
<p>If one asks for <em>conditional</em> mean value parameters, one gets
them only if <code>is.always.parameter = TRUE</code> is specified.
Otherwise, conditional expectations that are not parameters (because
they depend on data) are produced.
See Conditional Mean Values Section for more about this.
</p>
<p>Similarly, if <code>object$type == "conditional"</code>, then the conditional
canonical parameters are a linear function of the regression coefficients
<code class="reqn">\theta = M \beta</code>, where <code class="reqn">M</code> is the model matrix,
but one can predict either <code class="reqn">\theta</code> or the unconditional
canonical parameters <code class="reqn">\varphi</code>,
as selected by <code>model.type</code>.
Similarly, if <code>object$type == "unconditional"</code>,
so <code class="reqn">\varphi = M \beta</code>, one can predict either
<code class="reqn">\theta</code> or <code class="reqn">\varphi</code>
as selected by <code>model.type</code>.
</p>
<p>The specification of the prediction model is confusing because there
are so many possibilities.  First the “usual” case.
The fit was done using a formula, found in <code>object$formula</code>.
A data frame <code>newdata</code> that has the same variables as <code>object$data</code>,
the data frame used in the fit, but may have different rows (representing
hypothetical individuals) is supplied.
But <code>newdata</code> must specify <em>all nodes</em>
of the graphical model for each (hypothetical, new) individual,
just like <code>object$data</code> did for real observed individuals.
Hence <code>newdata</code> is typically constructed using <code>reshape</code>.
See also the details section of <code>aster</code>.
</p>
<p>In this “usual” case we need <code>varvar</code> and <code>idvar</code> to
tell us what rows of <code>newdata</code> correspond to which individuals and
nodes (the same role they played in the original fit by <code>aster</code>).
If we are predicting canonical parameters, then we do not need <code>root</code> or
<code>x</code>.
If we are predicting unconditional mean value parameters, then
we also need <code>root</code> but not <code>x</code>.
If we are predicting conditional mean value parameters, then
we also need both <code>root</code> and <code>x</code>.
In the “usual” case, these are found in <code>newdata</code> and
not supplied as arguments to <code>predict</code>.  Moreover, <code>x</code>
is not named <code>"x"</code> but is the response in <code>out$formula</code>.
</p>
<p>The next case, <code>predict(object)</code> with no other arguments,
is often used with linear models (<code>predict.lm</code>),
but we expect will be little used for aster models.  As for linear
models, this “predicts” the observed data.  In this case
<code>modmat</code>, <code>x</code>, and <code>root</code> are found in <code>object</code>
and nothing is supplied as an argument to <code>predict.aster</code>, except
perhaps <code>amat</code> if one wants a function of predictions for the observed
data.
</p>
<p>The final case, also perhaps little used, is a fail-safe mode for problems
in which the R formula language just cannot be bludgeoned into doing what
you want.  This is the same reason <code>aster.default</code> exists.
Then a model matrix can be constructed “by hand”, and the function
<code>predict.aster</code> is used instead of <code>predict.aster.formula</code>.
</p>
<p>Note that it is possible to use a “constructed by hand”
model matrix even if <code>object</code> was produced by <code>aster.formula</code>.
Simply explicitly call <code>predict.aster</code> rather than <code>predict</code>
to override the R method dispatch (which would
call <code>predict.aster.formula</code> in this case).
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code> and <code>gradient = FALSE</code>, a vector of predictions.
If <code>se.fit = TRUE</code>, a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>Estimated standard errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>The gradient of the transformation from
regression coefficients to predictions</p>
</td>
</tr>
</table>
<p>If <code>gradient = TRUE</code>, a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>The gradient of the transformation from
regression coefficients to predictions</p>
</td>
</tr>
</table>
<h3>Conditional Mean Values</h3>

<p>Both the original aster paper (Geyer, et al., 2007) and this package are
weird about conditional mean values.  Equation (10) of that paper defines
(using different notation from what we use here)
</p>
<p style="text-align: center;"><code class="reqn">\xi_j = E(x_j | x_{p(j)})</code>
</p>

<p>where <code class="reqn">x_j</code> are components of the response vector and <code class="reqn">p(j)</code>
denotes denotes the predecessor of node <code class="reqn">j</code>.  That paper explicitly says
that this is is not a parameter because it depends on the data.  In fact
</p>
<p style="text-align: center;"><code class="reqn">E(x_j | x_{p(j)}) = x_{p(j)} E(x_j | x_{p(j)} = 1)</code>
</p>

<p>(this is equation (3) of that paper in different notation).
Thus it is weird to use a Greek letter to denote this.
</p>
<p>There should be a conditional mean value parameter, and
Geyer (2010, equation (11b)) defines it as
</p>
<p style="text-align: center;"><code class="reqn">\xi_j = E(y_j | y_{p(j)} = 1)</code>
</p>

<p>(This equation only makes sense when the conditioning event
<code class="reqn">x_{p(j)} = 1</code> is possible, which it is not for
<code class="reqn">k</code>-truncated arrows for <code class="reqn">k &gt; 0</code>.  Then a more complicated definition
must be used.  By definition <code class="reqn">x_j</code> is the sum
of <code class="reqn">x_{p(j)}</code> independent and identically distributed random
variables, and <code class="reqn">\xi_j</code> is always the mean of one of those
random variables.)
This gives us the important relationship between conditional and unconditional
mean value parameters
</p>
<p style="text-align: center;"><code class="reqn">\mu_j = \xi_j \mu_{p(j)}</code>
</p>

<p>which holds for all successor nodes <code class="reqn">j</code>.
All later writings of this author use this definition of <code class="reqn">\xi</code>
as does the R package <code>aster2</code> (Geyer, 2017).
This is one of six important parameterizations of an unconditional aster model
(Geyer, 2010, Sections 2.7 and 2.8).  The R package <code>aster2</code> uses all
of them.
</p>
<p>This function (as of version 1.0 of this package) has an argument
<code>is.always.parameter</code> to switch between these two definitions
in case <code>parm.type = "mean.value"</code> and <code>model.type = "conditional"</code>
are specified.  Then <code>is.always.parameter = TRUE</code> specifies that the latter
definition of <code class="reqn">\xi</code> is produced (which is a parameter, with all other
options for <code>parm.type</code> and <code>model.type</code>).  The option
<code>is.always.parameter = FALSE</code> specifies that the former
definition of <code class="reqn">\xi</code> is produced (which is a conditional expectation
but not a parameter) and is what this function produced in versions of this
package before 1.0.
</p>


<h3>References</h3>

<p>Geyer, C. J. (2010)
A Philosophical Look at Aster Models.
Technical Report No. 676.  School of Statistics, University of Minnesota.
<a href="http://purl.umn.edu/57163">http://purl.umn.edu/57163</a>.
</p>
<p>Geyer, C.~J. (2017).
R package <code>aster2</code> (Aster Models), version 0.3.
<a href="https://cran.r-project.org/package=aster2">https://cran.r-project.org/package=aster2</a>.
</p>
<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster models for life history analysis.
<em>Biometrika</em>, <b>94</b>, 415–426.
<a href="https://doi.org/10.1093/biomet/asm030">doi:10.1093/biomet/asm030</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### see package vignette for explanation ###
library(aster)
data(echinacea)
vars &lt;- c("ld02", "ld03", "ld04", "fl02", "fl03", "fl04",
    "hdct02", "hdct03", "hdct04")
redata &lt;- reshape(echinacea, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redata &lt;- data.frame(redata, root = 1)
pred &lt;- c(0, 1, 2, 1, 2, 3, 4, 5, 6)
fam &lt;- c(1, 1, 1, 1, 1, 1, 3, 3, 3)
hdct &lt;- grepl("hdct", as.character(redata$varb))
redata &lt;- data.frame(redata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(redata$varb))
redata &lt;- data.frame(redata, level = as.factor(level))
aout &lt;- aster(resp ~ varb + level : (nsloc + ewloc) + hdct : pop,
    pred, fam, varb, id, root, data = redata)
newdata &lt;- data.frame(pop = levels(echinacea$pop))
for (v in vars)
    newdata[[v]] &lt;- 1
newdata$root &lt;- 1
newdata$ewloc &lt;- 0
newdata$nsloc &lt;- 0
renewdata &lt;- reshape(newdata, varying = list(vars),
     direction = "long", timevar = "varb", times = as.factor(vars),
     v.names = "resp")
hdct &lt;- grepl("hdct", as.character(renewdata$varb))
renewdata &lt;- data.frame(renewdata, hdct = as.integer(hdct))
level &lt;- gsub("[0-9]", "", as.character(renewdata$varb))
renewdata &lt;- data.frame(renewdata, level = as.factor(level))
nind &lt;- nrow(newdata)
nnode &lt;- length(vars)
amat &lt;- array(0, c(nind, nnode, nind))
for (i in 1:nind)
    amat[i , grep("hdct", vars), i] &lt;- 1
foo &lt;- predict(aout, varvar = varb, idvar = id, root = root,
    newdata = renewdata, se.fit = TRUE, amat = amat)
bar &lt;- cbind(foo$fit, foo$se.fit)
dimnames(bar) &lt;- list(as.character(newdata$pop), c("Estimate", "Std. Error"))
print(bar)
</code></pre>


</div>