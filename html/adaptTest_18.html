<div class="container">

<table style="width: 100%;"><tr>
<td>tsT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to implement an adaptive two-stage test</h2>

<h3>Description</h3>

<p>There are four key quantities for the specification of an adaptive two-stage test: the overall test level <code class="reqn">\alpha</code>, stopping bounds <code class="reqn">\alpha_1 &lt;= \alpha_0</code> and the local level <code class="reqn">\alpha_2</code> of the test after the second stage. These quantities are interrelated through the overall level condition. The function <code>tsT</code> calculates any of these quantities based on the others.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsT(typ, a = NA, a0 = NA, a1 = NA, a2 = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p><code class="reqn">\alpha</code>, the overall test level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p><code class="reqn">\alpha_0</code>, the futility stopping bound</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a1</code></td>
<td>
<p><code class="reqn">\alpha_1</code>, the efficacy stopping bound and local level of the test after the first stage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a2</code></td>
<td>
<p><code class="reqn">\alpha_2</code>, the local level of the test after the second stage</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An adaptive two-stage test can be viewed as a family of decreasing functions <code class="reqn">f[c](p_1)</code> in the unit square. Each of these functions is a conditional error function, specifying the type I error conditional on the p-value <code class="reqn">p_1</code> of the first stage. For example, <code class="reqn">f[c](p_1) = \min(1, c/p_1)</code> corresponds to Fisher's combination test (Bauer and Koehne, 1994). Based on this function family, the test can be put into practice by specifying the desired overall level <code class="reqn">\alpha</code>, stopping bounds <code class="reqn">\alpha_1 &lt;= \alpha_0</code> and a parameter <code class="reqn">\alpha_2</code>. After computing <code class="reqn">p_1</code>, the test stops with or without rejection of the null hypothesis if <code class="reqn">p_1 &lt;= \alpha_1</code> or <code class="reqn">p_1 &gt; \alpha_0</code>, respectively. Otherwise, the null hypothesis is rejected if and only if <code class="reqn">p_2 &lt;= f[c](p_1)</code> holds for the p-value <code class="reqn">p_2</code> of the second stage, where <code class="reqn">c</code> is such that the local level of this latter test is <code class="reqn">\alpha_2</code> (e.g., <code class="reqn">c = c(\alpha_2) = \exp(-\chi^2_{4,\alpha_2}/2)</code> for Fisher's combination test).
</p>
<p>The four parameters <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are interdependent: they must satisfy the level condition </p>
<p style="text-align: center;"><code class="reqn">\alpha_1 + \int_{\alpha_1}^{\alpha_0} cef_{\alpha_2}(p_1) d p_1 = \alpha,</code>
</p>
<p> where <code class="reqn">cef_{\alpha_2}</code> is the conditional error function (of a specified family) with parameter <code class="reqn">\alpha_2</code>. For example, this conditon translates to </p>
<p style="text-align: center;"><code class="reqn">\alpha = \alpha_1 + c(\alpha_2) * (\log(\alpha_0) - \log(\alpha_1))</code>
</p>
<p> for Fisher's combination test (assuming that <code class="reqn">c(\alpha_2) &lt; \alpha_1</code>; Bauer and Koehne, 1994). The function <code>tsT</code> calculates any of the four parameters based on the remaining ones. Currently, this is implemented for the following four tests: Bauer and Koehne (1994), Lehmacher and Wassmer (1999), Vandemeulebroecke (2006), and the horizontal conditional error function.
</p>


<h3>Value</h3>

<p>If three of the four quantities <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are provided, <code>tsT</code> returns the fourth. If only <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code> are provided, <code>tsT</code> returns <code class="reqn">\alpha_1</code> under the condition <code class="reqn">\alpha_1 = \alpha_2</code> (the so-called "Pocock-type").
</p>
<p>If the choice of arguments is not allowed (e.g., <code class="reqn">\alpha_0 &lt; \alpha_1</code>) or when a test cannot be constructed with this choice of arguments (e.g., <code class="reqn">\alpha_0 = 1</code> and <code class="reqn">\alpha &lt; \alpha_2</code>), <code>tsT</code> returns <code>NA</code>.
</p>
<p>IMPORTANT: When the result is (theoretically) not unique, <code>tsT</code> returns the maximal <code class="reqn">\alpha_1</code>, maximal <code class="reqn">\alpha_2</code> or minimal <code class="reqn">\alpha_0</code>.
</p>
<p>In all cases, <code>tsT</code> returns the result for the test specified by <code>typ</code>.
</p>


<h3>Note</h3>

<p>The argument <code>typ</code>, and either exactly three of <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code>, or only <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code>, must be provided to <code>tsT</code>.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>
<p>Vandemeulebroecke, M. (2008). Group sequential and adaptive designs - a review of basic concepts and points of discussion. <em>Biometrical Journal</em> 50, 541-557.
</p>


<h3>See Also</h3>

<p><code>adaptTest</code> package description</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example from Bauer and Koehne (1994): full level after final stage, alpha0 = 0.5
alpha  &lt;- 0.1
alpha2 &lt;- 0.1
alpha0 &lt;- 0.5
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
plotCEF(typ="b", a2=alpha2, add=FALSE)
plotBounds(alpha1, alpha0)

## See how similar Lehmacher and Wassmer (1999) and Vandemeulebroecke (2006) are
alpha  &lt;- 0.1
alpha1 &lt;- 0.05
alpha0 &lt;- 0.5
alpha2l &lt;- tsT(typ="l", a=alpha, a0=alpha0, a1=alpha1)
alpha2v &lt;- tsT(typ="v", a=alpha, a0=alpha0, a1=alpha1)
plotCEF(typ="l", a2=alpha2l, add=FALSE)
plotCEF(typ="v", a2=alpha2v, col="red")
plotBounds(alpha1, alpha0)

## A remark about numerics
tsT(typ="b", a=0.1, a1=0.05, a0=0.5)
tsT(typ="b", a=0.1, a2=0.104877, a0=0.5)
tsT(typ="b", a=0.1, a2=tsT(typ="b", a=0.1, a1=0.05, a0=0.5), a0=0.5)

## An example of non-uniqueness: the maximal alpha1 is returned; any
##  smaller value would also be valid
alpha  &lt;- 0.05
alpha0 &lt;- 1
alpha2 &lt;- 0.05
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
tsT(typ="b", a0=alpha0, a1=alpha1, a2=alpha2)
tsT(typ="b", a0=alpha0, a1=alpha1/2, a2=alpha2)
</code></pre>


</div>