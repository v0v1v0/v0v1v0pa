<div class="container">

<table style="width: 100%;"><tr>
<td>spatialNodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Using an autocart model, use the terminal nodes to form a spatial process that uses inverse
distance weighting to interpolate. The prediction for the new data that is passed in is formed
by making a prediction to assign it to a group. Next, the residual for the new prediction is
formed by inverse distance weighting the residual for the other points that are a part of that geometry.</h2>

<h3>Description</h3>

<p>Using an autocart model, use the terminal nodes to form a spatial process that uses inverse
distance weighting to interpolate. The prediction for the new data that is passed in is formed
by making a prediction to assign it to a group. Next, the residual for the new prediction is
formed by inverse distance weighting the residual for the other points that are a part of that geometry.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spatialNodes(
  autocartModel,
  newdata,
  newdataCoords,
  method = "idw",
  distpower = 2,
  distpowerRange = c(0, 2),
  modelByResidual = TRUE,
  decideByGC = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>autocartModel</code></td>
<td>
<p>an autocart model returned from the <code>autocart</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a dataframe that contains the same predictors that were used to form the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdataCoords</code></td>
<td>
<p>a matrix of coordinates for all the predictors contained in <code>newdata</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The type of interpolation to use. Options are "idw" for inverse distance weighting and "tps" for thin-plate splines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distpower</code></td>
<td>
<p>the power to use if you would like to use something other than straight inverse distance, such as inverse distance squared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distpowerRange</code></td>
<td>
<p>A range of distpower to use. This is an adaptive inverse distance weighting method that linearly matches measures of spatial autocorrelation measured by Moran I to the range mentioned in distpower.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modelByResidual</code></td>
<td>
<p>If true, then predict using the average of the "spatial node", and then model the residual using a spatial process. If false, fit a spatial process directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decideByGC</code></td>
<td>
<p>When determining if a spatial process should be ran at a terminal node, should we use the Geary C statistic instead of Moran I?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a prediction for the observations that are represented by <code>newdata</code> and <code>newdataCoords</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load some data for a spatial nodes example
snow &lt;- na.omit(read.csv(system.file("extdata", "ut2017_snow.csv", package = "autocart")))
y &lt;- snow$yr50[1:40]
X &lt;- data.frame(snow$ELEVATION, snow$MCMT, snow$PPTWT, snow$HUC)[1:40, ]
locations &lt;- as.matrix(cbind(snow$LONGITUDE, snow$LATITUDE))[1:40, ]

# Create an autocart model
snow_model &lt;- autocart(y, X, locations, 0.30, 0)

# Predit with the spatial node effect
new_X &lt;- X[1:10, ]
new_loc &lt;- locations[1:10, ]
spatial_node_predictions &lt;- spatialNodes(snow_model, new_X, new_loc, distpowerRange = c(0, 2))

</code></pre>


</div>