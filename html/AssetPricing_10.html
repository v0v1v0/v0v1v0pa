<div class="container">

<table style="width: 100%;"><tr>
<td>plot.AssetPricing</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot a list of asset pricing functions.
</h2>

<h3>Description</h3>

<p>Plot a list of functions — in particular optimal price
functions or expected value functions or derivatives of the
expected value functions.  Such a list is assumed to occur as
a component of an object produced by <code>xsolve()</code> of
<code>vsolve()</code>.  The functions in the list are functions
of residual time.  The indices of the list correspond to the
number of items available for sale and possibly (for optimal
price functions) the size of the arriving group of customers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'AssetPricing'
plot(x,witch=c("price","expVal","vdot"),
             xlim=NULL,ylim=NULL,lty=NULL,cols=NULL,xlab=NULL,
             ylab=NULL,main=NULL,main.panel= NULL,groups=NULL,
             add=FALSE,gloss=FALSE,glind=NULL,extend=0.3,col.gloss=1,
             cex.gloss=0.8,mfrow=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>An object of class <code>AssetPricing</code>, i.e. an object
produced by <code>vsolve()</code>, or <code>xsolve()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>witch</code></td>
<td>

<p>A text string indicating which of the three possible components
of <code>x</code> should be plotted.  May be abbreviated, e.g. to
<code>p</code>, <code>e</code> or <code>v</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>

<p>The <code>x</code> limits of the plot.  Defaults to the <code>tlim</code>
attribute of the object <code>x[[witch]]</code>.  If this attribute does not
exist and <code>xlim</code> is not supplied then an error is given.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>

<p>The <code>y</code> limits of the plot.  Defaults to the <code>ylim</code>
attribute of the object <code>x[[witch]]</code>.  If this attribute does not
exist and <code>ylim</code> is not supplied then an error is given.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>

<p>A vector of line types.  It will be replicated to have a length
equal to the number of rows of <code>groups</code> (see below).
Defaults to having all entries of the vector equal to <code>1</code>,
i.e. solid lines.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>

<p>A vector of colours for the plotted lines.  It will be replicated
to have a length equal to the number of rows of <code>groups</code>
(see below).  Defaults to having all entries of the vector equal
to <code>1</code>, i.e. black.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>

<p>A text string giving a label for the <code>x</code> axis (or axes).
Defaults to the null string.  Ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>

<p>A text string giving a label for the <code>y</code> axis (or axes).
Defaults to the null string.  Ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>

<p>A text string giving an overall title for the plot or for each
page of plots if there is more than one.  Defaults to the null
string and is ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main.panel</code></td>
<td>

<p>A text string which is replicated “np” times (where
“np” is the total number of panels) or a vector of text
strings of length equal to “np”.  Note that “np” will
be equal to the number of unique entries of <code>groups$group</code>.
(See below.)  The <code class="reqn">i^{th}</code> entry of the vector is
used as the title of the <code class="reqn">i^{th}</code> panel of the plots
that are created.  If <code>main.panel</code> is left <code>NULL</code>
the <code class="reqn">i^{th}</code> entry of the vector is set equal to
<code>paste("group",i)</code>.  This argument is ignored if there
is only a single panel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>

<p>A data frame with one, two or three columns, named <code>group</code>,
<code>q</code> and <code>j</code>.  The total number of rows should be less
than or equal to the total number of entries of the function
list <code>x[[witch]]</code>.  Only those function traces corresponding to a
row of <code>groups</code> are plotted.  The traces corresponding to
an individual value in the <code>group</code> column are plotted in the
same panel of a multi-panel array of plots.  See <b>Details</b>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p> Logical scalar; should the plot be added to an
existing plot?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gloss</code></td>
<td>
<p> Either a logical scalar (should a “marginal
gloss” be added to the plot? — if <code>TRUE</code> then the gloss
is constructed internally; see <b>Details</b>)  or a vector of
character strings of which the marginal gloss is to consist.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glind</code></td>
<td>
<p> A logical vector indicating which entries of
<code>gloss</code> should actually be used (plotted).  I.e. marginal
gloss is added for the graphs of functions whose corresponding
values in the entries of <code>glind</code> are <code>TRUE</code>.  Ignored if
<code>gloss</code> is <code>FALSE</code>.  If <code>gloss</code> is <code>TRUE</code> or
is explicitly provided, then if <code>glind</code> is not specified it
defaults to a vector, of the same length as <code>gloss</code> all of
whose entries are <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>
<p> A scalar, between 0 and 1, indicating how much
the <code>x</code>-axis should be extended (to the right) in order to
accommodate the marginal gloss.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.gloss</code></td>
<td>
<p> Scalar specifying the colour in which the
marginal gloss is to be added, e.g. <code>"red"</code> (or equivalently
<code>2</code>).  The default, i.e. <code>1</code>, is black.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.gloss</code></td>
<td>
<p> Character expansion (<code>cex</code>) specifier for
the marginal gloss.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfrow</code></td>
<td>
<p> The dimensions of the array(s) of panels in which
the functions are plotted.  If this argument is left as <code>NULL</code>
then the software makes a “sensible” choice for its value.
If this argument is set equal to <code>NA</code> then the current value
of <code>mfrow</code> for the plotting device is left “as is”. This
permits the setting up of an array of panels vi a call to <code>par(mfrow=...)</code>
<em>a priori</em> without the resulting setting being over-ridden by
the internal code of this plotting method.  One might wish to do this
e.g. for the purpose of <em>adding</em> plotted material to each
panel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Extra arguments to be passed to <code>plot</code>
(effectively to <code>plot.function()</code> or to
<code>plot.stepfun()</code>).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the argument <code>groups</code> is specified then:
</p>

<ul>
<li>
<p> it must <em>always</em> have a column <code>q</code>.  The values
in this column should be integers between <code>1</code> and <code>qmax</code>
(see below).
</p>
</li>
<li>
<p> if <code>jmax</code> (see below) is greater than 1 it must also
have a column <code>j</code>.  The entries of this column should be
integers between <code>1</code> and <code>jmax</code>.
</p>
</li>
<li>
<p> if <code>jmax</code> is equal to <code>1</code> then column <code>j</code>
need not be present.  In this case, it is internally set equal
to a column of <code>1</code>-s.
</p>
</li>
<li>
<p> if the <code>group</code> column is present its entries
should be (consecutive) positive integers running from <code>1</code>
to the total number of groups.
</p>
</li>
<li>
<p> if the <code>group</code> column is not present then this column
is internally set equal to a column of <code>1</code>-s i.e. there is
a single group of traces.
</p>
</li>
</ul>
<p>The value of <code>qmax</code> is the maximum number of items that
are available for sale in the time period under consideration.
It may be obtained as <code>attr(x,"qmax")</code>.
</p>
<p>The value of <code>jmax</code> is, when “double indexing”
applies, the maximum size of an arriving group of customers,
and is otherwise equal to <code>1</code>.  It may be obtained as
<code>attr(x,"jmax")</code>.  Note that “double indexing” can
<em>only</em> apply when <code>x[[witch]]</code> is a list of <em>price</em>
functions, i.e. when <code>witch</code> is equal to <code>price</code>.
Hence “double indexing” does not apply when <code>witch</code>
is equal to <code>expVal</code> or to <code>vdot</code>.  In these cases
<code>jmax</code> is equal to <code>1</code>.
</p>
<p>If <code>groups</code> is not specified then it defaults to a data
frame with number of rows equal to the length of <code>x[[witch]]</code>, The
<code>group</code> column has entries all equal to 1, i.e. there is
a single group of traces.  The <code>q</code> and <code>j</code> columns
contain all possible (valid) combinations of stock size and
customer group size.
</p>
<p>If <code>gloss</code> is <code>FALSE</code> then no marginal gloss is plotted.
If <code>gloss</code> is <code>TRUE</code> then the marginal gloss is created
from the values of the <code>q</code> and <code>j</code> entries in the
columns of <code>groups</code> using <code>paste()</code>.
</p>
<p>Note that if <code>add</code> is <code>TRUE</code> then the gloss may not
actually appear in the plot, since it is placed at the right
hand edge of the plot and may consequently be outside of the
plotting region.  Thus if you wish to use a gloss when adding to
an existing plot you will probably need to take steps to ensure
that there is room in the right hand margin for the plot to appear,
or possibly set <code>par(xpd=NA)</code>.
</p>
<p>If “double indexing” applies then <code>x[[i]]</code> corresponds
to a stock size of <code>q</code> and a customer group size of <code>j</code>
where <code>i = (j-1)*(qmax - j/2) + q</code>.
</p>
<p>To get traces plotted in individual panels (one trace per panel)
set the <code>group</code> column of <code>groups</code> to be <code>1:n</code>
where <code>n</code> is the total number of traces being plotted.
</p>
<p>This function (i.e. <code>plot.AssetPricing()</code> calls upon an
“internal” function <code>plot.flap()</code> to do the hard
yakka. (Note that <code>flap</code> stands for dQuotefunction list
for asset pricing.)
</p>
<p>The function <code>plot.flap()</code> makes use of a modified
version of <code>plot.stepfun()</code>, rather than the one which
appears in <code>package:stats</code>.  The modification causes
<code>plot.stepfun()</code> to treat the <code>xlim</code> argument in a manner
similar to the way in which it is treated by <code>plot.function</code>.
Note that <code>plot.stepfun()</code> is <em>not</em> exported from
this package.  On the advice of Kurt Hornik (31/03/2018) I
created a new generic <code>plot()</code> function in this package
(i.e. <code>AssetPricing</code>) with default method equal to
<code>graphics::plot()</code>, so as to properly accommodate the
existence of this modified <code>plot.stepfun()</code> method.
</p>


<h3>Value</h3>

<p>None.  This function exists only for its side effect, i.e.
the production of a plot or plots.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee, and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533–540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1–25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code>xsolve()</code>
<code>vsolve()</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
S &lt;- expression(exp(-kappa*x/(1+gamma*exp(-beta*t))))
attr(S,"parvec") &lt;- c(kappa=10/1.5,gamma=9,beta=1)
LAMBDA &lt;- function(tt){
    if(tt&lt;0 | tt&gt; 1) 0 else 36*(1-tt)
}
OUT &lt;- xsolve(S=S,lambda=LAMBDA,gprob=(5:1)/15,tmax=1,qmax=30,
                  alpha=0.5,type="dip",verbInt=2)
GLND &lt;- rep(FALSE,30)
GLND[c(1:5,10,15,20,30)] &lt;- TRUE
plot(OUT,witch="e",xlab="residual time",ylab="expected revenue",
     gloss=TRUE,glind=GLND)
GRPS &lt;- data.frame(group=rep(1:6,each=5),q=1:30)
GLND &lt;- c(TRUE,FALSE,TRUE,FALSE,TRUE,rep(c(rep(FALSE,4),TRUE),5))
plot(OUT,witch="e",groups=GRPS,xlab="residual time",ylab="expected revenue",
     gloss=TRUE,glind=GLND)
GRPS &lt;- data.frame(group=rep(1:5,each=6),j=rep(1:5,each=6))
GRPS$q &lt;- with(GRPS,pmax(j,rep(c(1,6,11,16,21,26),5)))
GLND &lt;- rep(c(TRUE,TRUE,rep(FALSE,3),TRUE),5)
plot(OUT,witch="p",groups=GRPS,mfrow=c(3,2),gloss=TRUE,glind=GLND,xlab="price")
# Pretty messy looking:
GRPS$group &lt;- 1
GLND &lt;- unlist(lapply(1:5,function(k){(1:6)==k}))
plot(OUT,witch="p",groups=GRPS,gloss=TRUE,glind=GLND,cols=GRPS$j,xlab="price")

## End(Not run)
</code></pre>


</div>