<div class="container">

<table style="width: 100%;"><tr>
<td>rakelist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to perform full ANES weighting on selected variables.
</h2>

<h3>Description</h3>

<p><code>rakelist</code> takes a list of variables and target values weights a dataset with those variables to match the targets via raking.  It is the primary workhorse command of <code>anesrake</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rakelist(inputter, dataframe, caseid, weightvec = NULL, cap = 999999,
 verbose = FALSE, maxit = 1000, convcrit = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>inputter</code></td>
<td>

<p>The <code>inputter</code> object should contain a list of all target values for the raking procedure.  Each list element in <code>inputter</code>  should be a vector corresponding to the weighting targets for a single variable.  Hence, the vector enumerating the weighting targets for a variable with 2 levels should be of length 2, while a vector enumerating the weighting targets for a variable with 5 levels should be of length 5.  List elements in inputter should be named according to the variable that they will match in the corresponding dataset.  Hence, a list element enumerating the proportion of the sample that should be of each gender should be labeled "female" if the variable in <code>dataframe</code> is also titled "female."
</p>
<p><code>inputter</code> elements must be vectors and can be of class numeric, or factor and must match the class of the corresponding variable in <code>dataframe</code>.  Logical variables in <code>dataframe</code> can be matched to a numeric vector of length 2 and ordered with the <code>TRUE</code> target as the first element and the <code>FALSE</code> target as the second element.  Targets for factors must be labeled to match every level present in the dataframe (e.g. a variable with 2 age groups "under40" and "over40" should have elements named "under40" and "over40" respectively).  <code>anesrake</code> attempts to conform any unrecognized types of vectors to <code>class(numeric)</code>. Weighting targets can be entered either as an N to be reached or as a percent for any given variable.  Targets can be either proportions (ideal) or the number of individuals in the population in each target category (N).  Totals of greater than 1.5 for any given list element are treated as Ns, while values of less than 1.5 are treated as percentages.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataframe</code></td>
<td>

<p>The <code>dataframe</code> command identifies a <code>data.frame</code> object of the data to be weighted.  The data.frame must contain all of the variables that will be used in the weighting process and those variables must have the same names as are present in the <code>inputter</code> list element.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caseid</code></td>
<td>

<p>The <code>caseid</code> command identifies a unique case identifier for each individual in the dataset.  If filters are to be used, the resulting list of weights will be a different length from the overall <code>dataframe</code>.  <code>caseid</code> is included in the output so that weights can be matched to the dataset of relevance.  <code>caseid</code> must be of a length matching the number of cases in <code>dataframe</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightvec</code></td>
<td>

<p><code>weightvec</code> is an optional input if some kind of base weights, stratification correction, or other sampling probability of note that should be accounted for before weighting is conducted.  If defined, <code>weightvec</code> must be of a length equivalent to the number of cases in the <code>dataframe</code>.  If undefined, <code>weightvec</code> will be automatically seeded with a vector of 1s.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cap</code></td>
<td>

<p><code>cap</code> defines the maximum weight to be used.  <code>cap</code> can be defined by the user with the command <code>cap=x</code>, where <code>x</code> is any value above 1 at which the algorithm will cap weights.  If <code>cap</code> is set below 1, the function will return an error.  If <code>cap</code> is set between 1 and 1.5, the function will return a warning that the low cap may substantially increase the amount of time required for weighting.  In the absence of a user-defined cap, the algorithm defaults to a starting value of 5 in line with DeBell and Krosnick, 2009.  For no cap, <code>cap</code> simply needs to be set to an arbitrarily high number. (Note: Capping using the <code>cap</code> command caps at each iteration.)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Users interested in seeing the progress of the algorithm can set <code>verbose</code> to equal <code>TRUE</code>.  The algorithm will then inform the user of the progress of each raking and capping iteration.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Users can set a maximum number of iterations for the function should it fail to converge using <code>maxit=X</code>, where <code>X</code> is the maximum number of iterations.  The default is set to 1000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convcrit</code></td>
<td>

<p><code>convcrit</code> is the criterion for convergence.  The raking algorithm is determined to have converged when the most recent iteration represents less than a <code>convcrit</code> percentage improvement over the prior iteration.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list object of <code>rakelist</code> has the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>weightvec</code></td>
<td>
<p>Vector of weights From raking algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caseid</code></td>
<td>
<p>Case IDs for final weights â€“ helpful for matching <code>weightvec</code> to cases if a filter is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>Number of iterations required for convergence (or non-convergence) of final model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonconvergence</code></td>
<td>
<p>Measure of remaining discrepancy from benchmarks if convergence was not achieved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge</code></td>
<td>
<p>Notes whether full convergence was achieved, algorithm failed to converge because convergence was not possible, or maximum iterations were reached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varsused</code></td>
<td>
<p>List of variables selected for weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p><code>inputter</code> from above, a list of the targets used for weighting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataframe</code></td>
<td>
<p>Copy of the original <code>dataframe</code> used for weighting (<code>filter</code> variable applied if specified)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Josh Pasek, Assistant Professor of Communication Studies at the University of Michigan (www.joshpasek.com).
</p>


</div>