<div class="container">

<table style="width: 100%;"><tr>
<td>lengthintervals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>lengthintervals</h2>

<h3>Description</h3>

<p>This function constructs the vector of interval lengths from a vector of interval endpoints.   
</p>


<h3>Usage</h3>

<pre><code class="language-R">lengthintervals(X, I, type = "midpoints", neighbours, closest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The vector of gridpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>a vector of interval endpoints. This is of length <code>length(X)+1</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character string, either <code>"midpoints"</code> or <code>"average"</code>, denoting the way of computing the interval lengths, if <span class="env">closest=TRUE</span>. If <code>"average"</code>, then the average neighbour distance is associated as the interval lengths to the gridpoints; otherwise the lengths are associated from the interval vector, <span class="env">I</span> in the obvious way : right endpoint - left endpoint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbours</code></td>
<td>
<p>the number of neighbours to be used in the prediction step of the transform. This is only used if <span class="env">closest=TRUE</span>, since it specifies how many distances to average over when <span class="env">type="average"</span>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closest</code></td>
<td>
<p>indicates whether the neighbourhood structure to be used in the transform is symmetrical or not. When combined with <span class="env">type="average"</span>, enables the option of average closest neighbour distance as the associated interval lengths to the gridpoints.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function computes the interval lengths by finding the differences between the consecutive entries of the supplied interval vector <span class="env">I</span>. In the case of the choice of average closest neighbour distance interval association, the method uses the function <code>getnbrs</code> to find the initial neighbours of each gridpoint to compute the average distances. 
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lengths</code></td>
<td>
<p>a vector of <code>length(X)</code> with the intervals lengths associated to the gridpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialnbrs</code></td>
<td>
<p>a matrix with columns <code>order(X)</code>, possibly together with the neighbour indices into <span class="env">X</span> of each gridpoint, if <span class="env">type="average"</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initialindex</code></td>
<td>
<p>If <span class="env">closest=TRUE</span> and <span class="env">type="average"</span>, a matrix of dimension <code>length(X)</code> x <code>neighbours</code>, showing the indices into <code>order(X)</code> of the neighbours of each gridpoint. Otherwise is NULL.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code>getnbrs</code>, <code>intervals</code>     </p>


<h3>Examples</h3>

<pre><code class="language-R">input&lt;-runif(10)
#gridpoint vector
#
I&lt;-intervals(input,"reflect")
#create the interval endpoint vector using the input
#
lengthintervals(input,I,"average",3,TRUE)
#
#computes 'intervals' based on 3 closest neighbour distance averages
#
</code></pre>


</div>