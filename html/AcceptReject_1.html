<div class="container">

<table style="width: 100%;"><tr>
<td>accept_reject</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Acceptance-Rejection Method</h2>

<h3>Description</h3>

<p>This function implements the acceptance-rejection method for generating random numbers from a given probability density function (pdf).
</p>


<h3>Usage</h3>

<pre><code class="language-R">accept_reject(
  n = 1L,
  continuous = TRUE,
  f = NULL,
  args_f = NULL,
  f_base = NULL,
  random_base = NULL,
  args_f_base = NULL,
  xlim = NULL,
  c = NULL,
  parallel = FALSE,
  cores = NULL,
  warning = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of random numbers to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>continuous</code></td>
<td>
<p>A logical value indicating whether the pdf is continuous or
discrete. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>The probability density function (<code>continuous = TRUE</code>), in the
continuous case or the probability mass function, in the discrete case
(<code>continuous = FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args_f</code></td>
<td>
<p>A list of arguments to be passed to the <code>f</code> function. It refers
to the list of arguments of the target distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_base</code></td>
<td>
<p>Base probability density function (for continuous case).If
<code>f_base = NULL</code>, a uniform distribution will be used. In the discrete case,
this argument is ignored, and a uniform probability mass function will be
used as the base.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_base</code></td>
<td>
<p>Random number generation function for the base
distribution passed as an argument to <code>f_base</code>.
If <code>random_base = NULL</code> (default), the uniform generator will be used. In the
discrete case, this argument is
disregarded, and the uniform random number generator function will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args_f_base</code></td>
<td>
<p>A list of arguments for the base distribution. This refers
to the list of arguments that will be passed to the function <code>f_base</code>.
It will be disregarded in the discrete case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>A vector specifying the range of values for the random numbers in
the form <code>c(min, max)</code>. Default is <code>c(0, 100)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>A constant value used in the acceptance-rejection method. If <code>NULL</code>,
<code>c</code> will be estimated automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A logical value indicating whether to use parallel processing
for generating random numbers. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. Default
is <code>NULL</code>, i.e, all available cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warning</code></td>
<td>
<p>A logical value indicating whether to show warnings. Default
is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to the <code>optimize()</code>. With this
argument, it is possible to change the tol argument of <code>optimize()</code>.
Default is <code style="white-space: pre;">⁠tol = .Machine$double.eps^0.25)⁠</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In situations where we cannot use the inversion method (situations where it
is not possible to obtain the quantile function) and we do not know a
transformation that involves a random variable from which we can generate
observations, we can use the acceptance and rejection method.
Suppose that <code class="reqn">X</code> and <code class="reqn">Y</code> are random variables with probability
density function (pdf) or probability function (pf) <code class="reqn">f</code> and <code class="reqn">g</code>,
respectively. In addition, suppose that there is a constant <code class="reqn">c</code> such that
</p>
<p style="text-align: center;"><code class="reqn">f(x) \leq c \cdot g(x), \quad \forall x \in \mathbb{R}.</code>
</p>

<p>for all values of <code class="reqn">t</code>, with <code class="reqn">f(t)&gt;0</code>. To use the acceptance and
rejection method to generate observations from the random variable <code class="reqn">X</code>,
using the algorithm below, first find a random variable <code class="reqn">Y</code> with pdf or
pf <code class="reqn">g</code>, that satisfies the above condition.
</p>
<p>Algorithm of the Acceptance and Rejection Method:
</p>
<p>1 - Generate an observation <code class="reqn">y</code> from a random variable <code class="reqn">Y</code> with
pdf/pf <code class="reqn">g</code>;
</p>
<p>2 - Generate an observation <code class="reqn">u</code> from a random variable <code class="reqn">U\sim \mathcal{U} (0, 1)</code>;
</p>
<p>3 - If <code class="reqn">u &lt; \frac{f(y)}{cg(y)}</code> accept <code class="reqn">x = y</code>; otherwise reject
<code class="reqn">y</code> as an observation of the random variable <code class="reqn">X</code> and return to step 1.
</p>
<p>Proof: Let's consider the discrete case, that is, <code class="reqn">X</code> and <code class="reqn">Y</code> are
random variables with pf's <code class="reqn">f</code> and <code class="reqn">g</code>, respectively. By step 3 of
the above algorithm, we have that <code class="reqn">{accept} = {x = y} = u &lt; \frac{f(y)}{cg(y)}</code>.
That is,
</p>
<p><code class="reqn">P(accept | Y = y) = \frac{P(accept \cap {Y = y})}{g(y)} = \frac{P(U \leq f(y)/cg(y)) \times g(y)}{g(y)} = \frac{f(y)}{cg(y)}.</code>
</p>
<p>Hence, by the Total Probability Theorem, we have that:
</p>
<p><code class="reqn">P(accept) = \sum_y P(accept|Y=y)\times P(Y=y) = \sum_y \frac{f(y)}{cg(y)}\times g(y) = \frac{1}{c}.</code>
</p>
<p>Therefore, by the acceptance and rejection method we accept the occurrence of $Y$ as being an occurrence of <code class="reqn">X</code> with probability <code class="reqn">1/c</code>. In addition, by Bayes' Theorem, we have that
</p>
<p><code class="reqn">P(Y = y | accept) = \frac{P(accept|Y = y)\times g(y)}{P(accept)} = \frac{[f(y)/cg(y)] \times g(y)}{1/c} = f(y).</code>
</p>
<p>The result above shows that accepting <code class="reqn">x = y</code> by the procedure of the algorithm is equivalent to accepting a value from <code class="reqn">X</code> that has pf <code class="reqn">f</code>.
</p>
<p>The argument <code>c = NULL</code> is the default. Thus, the function <code>accept_reject()</code> estimates the value of <code>c</code> using the optimization algorithm <code>optimize()</code> using the Brent method. For more details, see <code>optimize()</code> function.
If a value of <code>c</code> is provided, the function <code>accept_reject()</code> will use this value to generate the random observations. An inappropriate choice of c can lead to low efficiency of the acceptance and rejection method.
</p>
<p>In Unix-based operating systems, the function <code>accept_reject()</code> can be executed in parallel. To do this, simply set the argument <code>parallel = TRUE</code>.
The function <code>accept_reject()</code> utilizes the <code>parallel::mclapply()</code> function to execute the acceptance and rejection method in parallel.
On Windows operating systems, the code will not be parallelized even if <code>parallel = TRUE</code> is set.
</p>
<p>For the continuous case, a base density function can be used, where the arguments
<code>f_base</code>, <code>random_base</code> and <code>args_f_base</code> need to be passed. If at least one of
them is <code>NULL</code>, the function will assume a uniform density function over the
interval <code>xlim</code>.
</p>
<p>For the discrete case, the arguments <code>f_base</code>, <code>random_base</code> and <code>args_f_base</code>
should be <code>NULL</code>, and if they are passed, they will be disregarded, as for
the discrete case, the discrete uniform distribution will always be
considered as the base. Sampling from the discrete uniform distribution
has shown good performance for the discrete case.
</p>
<p>The advantage of using parallelism in Unix-based systems is relative and
should be tested for each case. Significant improvement is observed when
considering parallelism for very large values of n. It is advisable to
conduct benchmarking studies to evaluate the efficiency of parallelism in a
practical situation.
</p>


<h3>Value</h3>

<p>A vector of random numbers generated using the acceptance-rejection
method. The return is an object of <code style="white-space: pre;">⁠class accept_reject⁠</code>, but it can be
treated as an atomic vector.
</p>


<h3>References</h3>

<p>BISHOP, Christopher. 11.4: Slice sampling. Pattern Recognition and Machine Learning. Springer, 2006.
</p>
<p>Brent, R. (1973) Algorithms for Minimization without Derivatives. Englewood Cliffs N.J.: Prentice-Hall.
</p>
<p>CASELLA, George; ROBERT, Christian P.; WELLS, Martin T. Generalized accept-reject sampling schemes.
Lecture Notes-Monograph Series, p. 342-347, 2004.
</p>
<p>NEUMANN V (1951). “Various techniques used in connection with random digits.” Notes by
GE Forsythe, pp. 36–38.
</p>
<p>NEAL, Radford M. Slice sampling. The Annals of Statistics, v. 31, n. 3, p. 705-767, 2003.
</p>


<h3>See Also</h3>

<p><code>inspect()</code>, <code>plot.accept_reject()</code>, <code>qqplot.accept_reject()</code>,
<code>parallel::mclapply()</code> and <code>optimize()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(0) # setting a seed for reproducibility

x &lt;- accept_reject(
  n = 2000L,
  f = dbinom,
  continuous = FALSE,
  args_f = list(size = 5, prob = 0.5),
  xlim = c(0, 5)
)
plot(x)

y &lt;- accept_reject(
  n = 1000L,
  f = dnorm,
  continuous = TRUE,
  args_f = list(mean = 0, sd = 1),
  xlim = c(-4, 4)
)
plot(y)

</code></pre>


</div>