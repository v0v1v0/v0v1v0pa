<div class="container">

<table style="width: 100%;"><tr>
<td>amDataset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Prepare a dataset for use with allelematch
</h2>

<h3>Description</h3>

<p>Given an input matrix or <code>data.frame</code> produce a amDataset object suitable for use with
other allelematch functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">	amDataset(
		multilocusDataset, 
		missingCode = "-99", 
		indexColumn = NULL, 
		metaDataColumn = NULL, 
		ignoreColumn = NULL
		)

	## S3 method for class 'amDataset'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>multilocusDataset</code></td>
<td>

<p>A <code>matrix</code> or <code>data.frame</code> containing samples in rows and alleles in columns.<br>
Sampling IDs and meta-data may be specified in up to two additional columns.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missingCode</code></td>
<td>

<p>A character string giving the code used for missing data.<br>
Missing data may also be represented as <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexColumn</code></td>
<td>

<p>Optional.<br>
A character string giving the column name, or an integer giving the column number containing
the sampling ID or index information.<br>
If an index is not supplied, then the function creates an alphabetical index.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metaDataColumn</code></td>
<td>

<p>Optional.<br>
A character string giving the column name, or an integer giving the column number containing
the meta-data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreColumn</code></td>
<td>

<p>Optional.<br>
A vector of character string(s) giving the column name(s) or integer(s) giving the column
number(s) that should be removed from the input dataset (i.e., those that matching and
clustering should not consider).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>An amDataset object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments to summary.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Examine <code>amExampleData</code> for an example of a typical input dataset in the diploid
case. (Typically these files will be the CSV output from allele calling software). Sample index
or ID information and sample meta-data may be specified in two additional columns. Columns can
optionally be given names, and these are carried through analyses. If column names are not
given, appropriate names are produced.<br></p>
<p>Each datum is treated as a character string in <code>allelematch</code> functions, enabling the mixing
of numeric and alphanumeric data.<br></p>
<p>The multilocus dataset can contain any number of diploid or haploid markers, and these can be in
any order. Thus in the diploid case there should be two columns for each locus (named, say,
locus1a and locus1b). Please note that <code>AlleleMatch</code> functions pay no attention to
genetics. In other words, each column is considered a comparable state. Thus matching and
clustering of multilocus genotypes is done on the basis of superficial similarity of the data
matrix rows, rather than on any appreciation of the allelic states at each locus. See
<code>amPairwise</code> for more discussion.<br></p>
<p>For this reason it is important when working with diploid data to ensure that identical
individuals will have identical alleles in each column. This can be achieved by sorting each
locus so that in each case the lower length allele appears in, say, a column "locus1a" and the
higher in column "locus1b." This pattern is likely the default in allele calling software and
sorting will typically not be required unless data are derived from an unusual source.<br></p>
<p>Only one meta-data column is possible with <code>allelematch</code>. If multiple columns must be
associated with a given sample for downstream analyses, try pasting them together into one
string with an appropriate separator, and separating them later when allelematch analyses are
concluded.
</p>


<h3>Value</h3>

<p>An <code>amDataset</code> object.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern (<a href="mailto:pgalpern@gmail.com">pgalpern@gmail.com</a>)
</p>


<h3>References</h3>

<p>For a complete vignette, please access via the Data S1 Supplementary documentation and tutorials
(PDF) located at &lt;doi:10.1111/j.1755-0998.2012.03137.x&gt;.
</p>


<h3>See Also</h3>

<p><code>amPairwise</code>, <code>amUnique</code>, <code>amExampleData</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">	## Not run: 
	data("amExample5")
	
	## Typical usage
	myDataset &lt;- 
		amDataset(
			amExample5, 
			missingCode = "-99", 
			indexColumn = 1, 
			metaDataColumn = 2, 
			ignoreColumn = "gender"
			)
	
	## Access elements of amDataset object
	myMetaData &lt;- myDataset$metaData
	mySamplingID &lt;- myDataset$index
	myAlleles &lt;- myDataset$multilocus
	
	## View the structure of amDataset object
	unclass(myDataset)
	
## End(Not run)
</code></pre>


</div>