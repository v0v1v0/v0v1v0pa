<div class="container">

<table style="width: 100%;"><tr>
<td>StorageQueue</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class representing an Azure storage queue</h2>

<h3>Description</h3>

<p>A storage queue holds messages. A queue can contain an unlimited number of messages, each of which can be up to 64KB in size. Messages are generally added to the end of the queue and retrieved from the front of the queue, although first in, first out (FIFO) behavior is not guaranteed.
</p>
<p>To generate a queue object, use one of the <code>storage_queue</code>, <code>list_storage_queues</code> or <code>create_storage_queue</code> functions rather than calling the <code>new()</code> method directly.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>endpoint</code></dt>
<dd>
<p>A queue endpoint object. This contains the account and authentication information for the queue.</p>
</dd>
<dt><code>name</code></dt>
<dd>
<p>The name of the queue.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>StorageQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-create"><code>StorageQueue$create()</code></a>
</p>
</li>
<li> <p><a href="#method-delete"><code>StorageQueue$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-clear"><code>StorageQueue$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-get_metadata"><code>StorageQueue$get_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-set_metadata"><code>StorageQueue$set_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-get_message"><code>StorageQueue$get_message()</code></a>
</p>
</li>
<li> <p><a href="#method-get_messages"><code>StorageQueue$get_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-peek_message"><code>StorageQueue$peek_message()</code></a>
</p>
</li>
<li> <p><a href="#method-peek_messages"><code>StorageQueue$peek_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-pop_message"><code>StorageQueue$pop_message()</code></a>
</p>
</li>
<li> <p><a href="#method-pop_messages"><code>StorageQueue$pop_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-put_message"><code>StorageQueue$put_message()</code></a>
</p>
</li>
<li> <p><a href="#method-update_message"><code>StorageQueue$update_message()</code></a>
</p>
</li>
<li> <p><a href="#method-delete_message"><code>StorageQueue$delete_message()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>StorageQueue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>StorageQueue$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize the queue object. Rather than calling this directly, you should use one of the <code>storage_queue</code>, <code>list_storage_queues</code> or <code>create_storage_queue</code> functions.
</p>
<p>Note that initializing this object is a local operation only. If a queue of the given name does not already exist in the storage account, it has to be created remotely by calling the <code>create</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$new(endpoint, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>endpoint</code></dt>
<dd>
<p>An endpoint object.</p>
</dd>
<dt><code>name</code></dt>
<dd>
<p>The name of the queue.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-create"></a>



<h4>Method <code>create()</code>
</h4>

<p>Creates a storage queue in Azure, using the storage endpoint and name from this R6 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$create()</pre></div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-delete"></a>



<h4>Method <code>delete()</code>
</h4>

<p>Deletes this storage queue in Azure.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$delete(confirm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>confirm</code></dt>
<dd>
<p>Whether to ask for confirmation before deleting.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-clear"></a>



<h4>Method <code>clear()</code>
</h4>

<p>Clears (deletes) all messages in this storage queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$clear()</pre></div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-get_metadata"></a>



<h4>Method <code>get_metadata()</code>
</h4>

<p>Retrieves user-defined metadata for the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_metadata()</pre></div>



<h5>Returns</h5>

<p>A named list of metadata properties.
</p>


<hr>
<a id="method-set_metadata"></a>



<h4>Method <code>set_metadata()</code>
</h4>

<p>Sets user-defined metadata for the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$set_metadata(..., keep_existing = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Name-value pairs to set as metadata.</p>
</dd>
<dt><code>keep_existing</code></dt>
<dd>
<p>Whether to retain existing metadata information.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A named list of metadata properties, invisibly.
</p>


<hr>
<a id="method-get_message"></a>



<h4>Method <code>get_message()</code>
</h4>

<p>Reads a message from the front of the storage queue.
</p>
<p>When a message is read, the consumer is expected to process the message and then delete it. After the message is read, it is made invisible to other consumers for a specified interval. If the message has not yet been deleted at the time the interval expires, its visibility is restored, so that another consumer may process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-get_messages"></a>



<h4>Method <code>get_messages()</code>
</h4>

<p>Reads several messages at once from the front of the storage queue.
</p>
<p>When a message is read, the consumer is expected to process the message and then delete it. After the message is read, it is made invisible to other consumers for a specified interval. If the message has not yet been deleted at the time the interval expires, its visibility is restored, so that another consumer may process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt>
<dd>
<p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of objects of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-peek_message"></a>



<h4>Method <code>peek_message()</code>
</h4>

<p>Reads a message from the storage queue, but does not alter its visibility.
</p>
<p>Note that a message obtained via the <code>peek_message</code> or <code>peek_messages</code> method will not include a pop receipt, which is required to delete or update it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$peek_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-peek_messages"></a>



<h4>Method <code>peek_messages()</code>
</h4>

<p>Reads several messages at once from the storage queue, without altering their visibility.
</p>
<p>Note that a message obtained via the <code>peek_message</code> or <code>peek_messages</code> method will not include a pop receipt, which is required to delete or update it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$peek_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt>
<dd>
<p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of objects of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-pop_message"></a>



<h4>Method <code>pop_message()</code>
</h4>

<p>Reads a message from the storage queue, removing it at the same time. This is equivalent to calling <a href="#method-get_message"><code>get_message</code></a> and <a href="#method-delete_message"><code>delete_message</code></a> successively.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$pop_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-pop_messages"></a>



<h4>Method <code>pop_messages()</code>
</h4>

<p>Reads several messages at once from the storage queue, and then removes them.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$pop_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt>
<dd>
<p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of objects of class <code>QueueMessage</code>.
</p>


<hr>
<a id="method-put_message"></a>



<h4>Method <code>put_message()</code>
</h4>

<p>Writes a message to the back of the message queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$put_message(text, visibility_timeout = NULL, time_to_live = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>text</code></dt>
<dd>
<p>The message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
<dt><code>visibility_timeout</code></dt>
<dd>
<p>Optional visibility timeout after being read, in seconds. The default is 30 seconds.</p>
</dd>
<dt><code>time_to_live</code></dt>
<dd>
<p>Optional message time-to-live, in seconds. The default is 7 days.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The message text, invisibly.
</p>


<hr>
<a id="method-update_message"></a>



<h4>Method <code>update_message()</code>
</h4>

<p>Updates a message in the queue. This requires that the message object must include a pop receipt, which is present if it was obtained by means other than <a href="#method-peek_message">peeking</a>.
</p>
<p>This operation can be used to continually extend the invisibility of a queue message. This functionality can be useful if you want a worker role to "lease" a message. For example, if a worker role calls <a href="#method-get_messages"><code>get_messages</code></a> and recognizes that it needs more time to process a message, it can continually extend the message's invisibility until it is processed. If the worker role were to fail during processing, eventually the message would become visible again and another worker role could process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$update_message(msg, visibility_timeout, text = msg$text)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg</code></dt>
<dd>
<p>A message object, of class <code>QueueMessage</code>.</p>
</dd>
<dt><code>visibility_timeout</code></dt>
<dd>
<p>The new visibility timeout (time to when the message will again be visible).</p>
</dd>
<dt><code>text</code></dt>
<dd>
<p>Optionally, new message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-delete_message"></a>



<h4>Method <code>delete_message()</code>
</h4>

<p>Deletes a message from the queue. This requires that the message object must include a pop receipt, which is present if it was obtained by means other than <a href="#method-peek_message">peeking</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$delete_message(msg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg</code></dt>
<dd>
<p>A message object, of class <code>QueueMessage</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print method for this class.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Not currently used.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>QueueMessage</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

endp &lt;- storage_endpoint("https://mystorage.queue.core.windows.net", key="key")

# to talk to an existing queue
queue &lt;- storage_queue(endp, "queue1")

# to create a new queue
queue2 &lt;- create_storage_queue(endp, "queue2")

# various ways to delete a queue (will ask for confirmation first)
queue2$delete()
delete_storage_queue(queue2)
delete_storage_queue(endp, "queue2")

# to get all queues in this storage account
queue_lst &lt;- list_storage_queues(endp)

# working with a queue: put, get, update and delete messages
queue$put_message("new message")
msg &lt;- queue$get_message()
msg$update(visibility_timeout=60, text="updated message")
queue$delete_message(msg)

# delete_message simply calls the message's delete() method, so this is equivalent
msg$delete()

# retrieving multiple messages at a time (up to 32)
msgs &lt;- queue$get_messages(30)

# deleting is still per-message
lapply(msgs, function(m) m$delete())

# you can use the process pool from AzureRMR to do this in parallel
AzureRMR::init_pool()
AzureRMR::pool_lapply(msgs, function(m) m$delete())
AzureRMR::delete_pool()


## End(Not run)
</code></pre>


</div>