<div class="container">

<table style="width: 100%;"><tr>
<td>AR.Sim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Graphical Visualization for Accept-Reject Method
</h2>

<h3>Description</h3>

<p>Package <code>AR</code> provides a graphical presentation for Accept-Reject method by drawing three figures which their explanations are as follow:
</p>
<p>Explanation of Figure 1:  
</p>
<p>Moreover, even when the Rejection Accept-Reject method is applied, it is always hard to optimize the constant <code class="reqn">c</code> for the likelihood ratio. Although, the algorithm works with a bigger constant <code class="reqn">c</code> (with respect to optimal/minimum possible <code class="reqn">c</code>), but increasing <code class="reqn">c</code> cause high rejection rate and the algorithm can be very in-efficient. 
The first figure show three curves <code class="reqn">f_X(x)</code>, <code class="reqn">f_Y(x)</code> and <code class="reqn">\frac{f_X(x)}{f_Y(x)}</code>. Moreover, the optimum <code class="reqn">c</code>  (minimum possible <code class="reqn">c</code>, such that <code class="reqn">\frac{f_X(x)}{f_Y(x)} \leq c</code>) calculated as the maximum height of the curve <code class="reqn">\frac{f_X(x)}{f_Y(x)}</code>, which is also shown on the first figure.
</p>
<p>Explanation of Figure 2:  
</p>
<p>To visualize the motivation behind the <code>Acceptance-Rejection method</code>, imagine graphing curve <code class="reqn">\frac{f_X(y)}{c \ f_Y(y)}</code> onto a large rectangular board and throwing darts at it. Assume that the <code class="reqn">x</code>-positions of these darts/points are uniformly distributed around the board and the distribution of <code class="reqn">y</code>-positions of them are based on <code class="reqn">Y</code> distribution. Now, remove all of the darts/points that are outside the area under the curve <code class="reqn">\frac{f_X(y)}{c \ f_Y(y)}</code>. 
The <code class="reqn">x</code>-positions of the remaining darts will be distributed according to the random variable's density of <code class="reqn">X</code> within the area under the curve. Since, it can be prove that </p>
<p style="text-align: center;"><code class="reqn"> P\left[ Y\leq y \ | \ U \leq \frac{f_X(Y)}{c \ f_Y(Y)} \right] = P\left( X \leq x \right) . </code>
</p>
 
<p>Explanation of Figure 3:  
</p>
<p>For another graphical presentation of the motivation behind the <code>Acceptance-Rejection method</code>, assumes that the considered board (which is presented in explanation of Figure 2) is not necessarily rectangular but is shaped according to some distribution that we know how to generate sample from it (<code class="reqn">c . f_Y(y)</code>).
Therefore, if <code class="reqn">y</code>-positions of random points/darts be equal to <code class="reqn">u.c.f_Y(y)</code>, then all darts/points will be land under the curve <code class="reqn">c.f_Y(y)</code>. 
The acceptance condition in the <code>Acceptance-Rejection method</code> is </p>
<p style="text-align: center;"><code class="reqn">u \leq \frac{f_X(y)}{c \ f_Y(y)},</code>
</p>
<p> or equivalently  </p>
<p style="text-align: center;"><code class="reqn">u.c.f_Y(y) \leq f_X(y),</code>
</p>
 
<p>and it means that after omitting the extra/red random darts/points from the board (which are not satisfy in the acceptance condition), the <code class="reqn">x</code>-positions of the remaining darts/points will be distributed according to the distribution of <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">AR.Sim(n, f_X, Y.dist, Y.dist.par, xlim = c(0, 1), S_X = xlim, Rej.Num = TRUE,
       Rej.Rate = TRUE, Acc.Rate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>The number/length of data which must be generated/simulated from <code class="reqn">f_X</code> density.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_X</code></td>
<td>

<p>The density <code class="reqn">f_X</code> of interest for simulation (called the target density)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.dist</code></td>
<td>

<p>The distribution name of the random variable <code class="reqn">Y</code>, which used to generate the random data from <code class="reqn">f_Y</code>. Precisely, <code>Y.dist</code> is the name of <code class="reqn">f_Y</code> density which is match with <code>DISTRIB</code> Package. For example, use <code> Y.dist = "norm"</code>, when <code class="reqn"> Y \sim N(\mu, \sigma^2) </code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y.dist.par</code></td>
<td>

<p>A vector of <code class="reqn">Y</code> distribution parameters with considered ordering in <code>stats</code> package and also is match with <code>DISTRIB</code> Package. For example, use <code> Y.dist.par = </code>
<code>c(2,3)</code>, when <code class="reqn"> Y \sim N(\mu=2, \sigma^2=9) </code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>

<p><code>NULL</code> or a numeric vector of length 2; if non-NULL it provides the defaults for c(from, to) and, unless <code>add=TRUE</code>, selects the <code class="reqn">x</code>-limits of the available plot. Its default is <code> xlim=c(0,1)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S_X</code></td>
<td>

<p>The support of <code class="reqn">X</code> with default <code> S_X = xlim </code>, which is needed for calculating the optimum value of constant <code class="reqn">c</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rej.Num</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the number of rejections in <code>Accept-Reject method</code>. If <code>Rej.Num = FALSE</code>, then the number of rejections is not reported.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rej.Rate</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the ratio of rejections in <code>Accept-Reject method</code> (i.e. <code>Rej.Num / n</code>). If <code>Rej.Rate = FALSE</code>, then the ratio of rejections is not reported.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Acc.Rate</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the ratio of acceptances in <code>Accept-Reject method</code> (i.e. <code> 1 - Rej.Rate </code>). If <code>Acc.Rate = FALSE</code>, then the ratio of acceptances is not reported.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of generated/simulated data from random variable <code class="reqn">X</code> with length <code class="reqn">n</code>.
</p>
<p>Optimum value for <code class="reqn">c</code>, i.e. the minimum possible value for <code class="reqn">c</code>.
</p>


<h3>References</h3>

<p>Robert, C.P., Casella, G., Introducing Monte Carlo Methods with R, New York: Springer (2010).
</p>
<p>Wikipedia, the free encyclopedia, Rejection sampling, 
https://en.wikipedia.org/wiki/Rejection_sampling
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: 
data = AR.Sim( n = 150, 
         f_X = function(y){dbeta(y,2.7,6.3)},
         Y.dist = "unif", Y.dist.par = c(0,1),
         Rej.Num = TRUE,
         Rej.Rate = TRUE,
         Acc.Rate = FALSE
         ) 

# QQ-plot
q &lt;- qbeta(ppoints(100), 2.7, 6.3)
qqplot(q, data, cex=0.6, xlab="Quantiles of Beta(2.7,6.3)", 
       ylab="Empirical Quantiles of simulated data")
abline(0, 1, col=2)


# ------------------------------------------------------
# Example 2: From Page 54 of (Robert and Casella, 2009)
f_X = function(x) dbeta(x,2.7,6.3)
Simulation1 &lt;- AR.Sim(n=300, f_X, Y.dist = "unif", Y.dist.par = c(0,1)) 
Simulation2 &lt;- AR.Sim(n=2000, f_X, Y.dist="beta", Y.dist.par=c(2,6) ) 
Simulation3 &lt;- AR.Sim(n=1000, f_X, Y.dist="beta", Y.dist.par=c(1.5,3.7) ) 
Simulation4 &lt;- AR.Sim(n=250, f_X, Y.dist="norm", Y.dist.par=c(.5,.2) ) 
Simulation5 &lt;- AR.Sim(n=200,  f_X, Y.dist="exp", Y.dist.par=3 ) 
Simulation6 &lt;- AR.Sim( 400 ,  f_X, Y.dist="gamma", Y.dist.par=c(2,5) ) 

hist(Simulation1, prob=TRUE)#, col="gray20")
hist(Simulation2, prob=TRUE, add=TRUE, col="gray35")
hist(Simulation3, prob=TRUE, add=TRUE, col="gray60")
hist(Simulation4, prob=TRUE, add=TRUE, col="gray75")
hist(Simulation5, prob=TRUE, add=TRUE, col="gray85")
hist(Simulation6, prob=TRUE, add=TRUE, col="gray100")
curve(f_X(x), add=TRUE, col=2, lty=2, lwd=3)

#compare empirical and theoretical percentiles:
p &lt;- seq(.1, .9, .1)
Qhat1 &lt;- quantile(Simulation1, p) #Empirical quantiles of simulated sample 
Qhat2 &lt;- quantile(Simulation2, p) #Empirical quantiles of simulated sample 
Qhat3 &lt;- quantile(Simulation3, p) #Empirical quantiles of simulated sample 
Qhat4 &lt;- quantile(Simulation4, p) #Empirical quantiles of simulated sample 
Qhat5 &lt;- quantile(Simulation5, p) #Empirical quantiles of simulated sample 
Qhat6 &lt;- quantile(Simulation6, p) #Empirical quantiles of simulated sample 
Q &lt;- qbeta(p, 2.7, 6.3)    #Theoretical quantiles of Be(2.7,6.3)
round( rbind(Q, Qhat1, Qhat2, Qhat3, Qhat4, Qhat5, Qhat6), 3)

# Compute p-value of Kolmogorov-Smirnov test:
ks.test(Simulation1, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation2, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation3, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation4, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation5, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation6, "pbeta", 2.7, 6.3)$p.value


# ------------------------------------------------------
# Example 3: Simulate Truncated N(5,2^2) at l=3 and r=14 in left and rigth sides, respectively. 

mu = 5
sigma = 2
l = 3
r = 14
n = 400
f_X = function(x)  dnorm(x,mu,sigma) * 
                   as.integer(l&lt;x &amp; x&lt;r) / (pnorm(r,mu,sigma)-pnorm(l,mu,sigma)) 

Sim1 &lt;- AR.Sim(n, f_X, S_X=c(l,r), Y.dist="norm", Y.dist.par=c(5,4), xlim=c(l-1,r+1) ) 
head(Sim1, 15)
hist(Sim1, prob=TRUE, col="lightgreen")
curve(f_X(x), add=TRUE, col=2, lty=2, lwd=3) # Truncated pdf of N(5,2^2) at l and r
c2 = 1 / (pnorm(r,mu,sigma)-pnorm(l,mu,sigma)) ; c2 #See page 15 jozve

</code></pre>


</div>