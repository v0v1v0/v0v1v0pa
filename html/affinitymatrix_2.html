<div class="container">

<table style="width: 100%;"><tr>
<td>estimate.affinity.matrix.lowrank</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate Dupuy and Galichon's model</h2>

<h3>Description</h3>

<p>This function estimates the affinity matrix of the matching model of Dupuy
and Galichon (2014) under a rank restriction on the affinity matrix, as
suggested by Dupuy, Galichon and Sun (2019). In their own words, "to
accommodate high dimensionality of the data, they propose a novel method that
incorporates a nuclear norm regularization which effectively enforces a rank
constraint on the affinity matrix." This function also performs the saliency
analysis and the rank tests. The user must supply a <em>matched sample</em>
that is treated as the equilibrium matching of a bipartite one-to-one
matching model without frictions and with Transferable Utility. For the sake
of clarity, in the documentation we take the example of the marriage market
and refer to "men" as the observations on one side of the market and to
"women" as the observations on the other side. Other applications may include
matching between CEOs and firms, firms and workers, buyers and sellers, etc.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate.affinity.matrix.lowrank(
  X,
  Y,
  w = rep(1, N),
  A0 = matrix(0, nrow = Kx, ncol = Ky),
  lb = matrix(-Inf, nrow = Kx, ncol = Ky),
  ub = matrix(Inf, nrow = Kx, ncol = Ky),
  pr = 0.05,
  max_iter = 10000,
  tol_level = 1e-08,
  tau = 1,
  scale = 1,
  cross_validation = TRUE,
  manual_lambda = 0,
  lambda_min = 0,
  Nfolds = 5,
  nB = 2000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The matrix of men's traits. Its rows must be ordered so that the
i-th man is matched with the i-th woman: this means that <code>nrow(X)</code>
must be equal to <code>nrow(Y)</code>. Its columns correspond to the different
matching variables: <code>ncol(X)</code> can be different from <code>ncol(Y)</code>.
For the sake of clarity of exposition when using descriptive tools such as
<code>show.correlations</code>, it is recommended assigning the same
matching variable to the k-th column of <code>X</code> and to the k-th column of
<code>Y</code>, whenever possible. If <code>X</code> has more matching variables than
<code>Y</code>, then those variables that appear in <code>X</code> but no in Y should
be found in the last columns of <code>X</code> (and vice versa). The matrix is
demeaned and rescaled before the start of the estimation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The matrix of women's traits. Its rows must be ordered so that the
i-th woman is matched with the i-th man: this means that <code>nrow(Y)</code>
must be equal to <code>nrow(X)</code>.  Its columns correspond to the different
matching variables: <code>ncol(Y)</code> can be different from <code>ncol(X)</code>.
The matrix is demeaned and rescaled before the start of the estimation
algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A vector of sample weights with length <code>nrow(X)</code>. Defaults to
uniform weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A0</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the initial values of the affinity matrix to be fed to the
estimation algorithm. Optional. Defaults to matrix of zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the lower bounds of the elements of the affinity matrix.
Defaults to <code>-Inf</code> for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the upper bounds of the elements of the affinity matrix.
Defaults to <code>Inf</code> for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr</code></td>
<td>
<p>A probability indicating the significance level used to compute
bootstrap two-sided confidence intervals for <code>U</code>, <code>V</code> and
<code>lambda</code>. Defaults to 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>An integer indicating the maximum number of iterations in the
proximal gradient descent algorithm. Defaults to 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_level</code></td>
<td>
<p>A positive real number indicating the tolerance level in the
proximal gradient descent algorithm. Defaults to 1e-8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>A positive real number indicating a sensitivity parameter in the
proximal gradient descent algorithm. Defaults to 1 and should not be
changed unless computational problems arise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A positive real number indicating the scale of the model.
Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross_validation</code></td>
<td>
<p>If <code>TRUE</code>, the function looks for a rank
restriction through cross validation. The cross validation exercise aims to
minimize the covariance mismatch: in other words, it avoids overfitting
without excessively reducing the number of free parameters. Defaults to
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>manual_lambda</code></td>
<td>
<p>A positive real number indicating the user-supply
<code>lambda</code> when <code>cross_validation==FALSE</code>. The higher
<code>lambda</code>, the tighter the rank restriction. Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_min</code></td>
<td>
<p>A positive real number indicating minimum value for
<code>lambda</code> considered during the cross validation. We recommend using 0,
but with a high number of matching variables relatively to the sample size
it is reasonable to set <code>lambda_min</code> to a higher value. Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nfolds</code></td>
<td>
<p>An integer indicating the number of folds in the cross
validation. Defaults to 5 and can be increased with a large sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nB</code></td>
<td>
<p>An integer indicating the number of bootstrap replications used to
compute the confidence intervals of <code>Aopt</code>, <code>U</code>, <code>V</code> and
<code>lambda</code>. Defaults to 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, the function displays messages to keep track
of its progress. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list with elements: <code>X</code>, the demeaned and
rescaled matrix of men's traits; <code>Y</code>, the demeaned and rescaled matrix
of men's traits; <code>fx</code>, the empirical marginal distribution of men;
<code>fy</code>, the empirical marginal distribution of women; <code>Aopt</code>, the
estimated affinity matrix; <code>sdA</code>, the standard errors of <code>Aopt</code>;
<code>tA</code>, the Z-test statistics of <code>Aopt</code>; <code>VarCovA</code>, the full
variance-covariance matrix of <code>Aopt</code>; <code>rank.tests</code>, a list with
all the summaries of the rank tests on <code>Aopt</code>; <code>U</code>, whose columns
are the left-singular vectors of <code>Aopt</code>; <code>V</code>, whose columns are
the right-singular vectors of <code>Aopt</code>; <code>lambda</code>, whose elements
are the singular values of <code>Aopt</code>; <code>UCI</code>, whose columns are the
lower and the upper bounds of the confidence intervals of <code>U</code>;
<code>VCI</code>, whose columns are the lower and the upper bounds of the
confidence intervals of <code>V</code>; <code>lambdaCI</code>, whose columns are the
lower and the upper bounds of the confidence intervals of <code>lambda</code>;
<code>df.bootstrap</code>, a data frame resulting from the <code>nB</code> bootstrap
replications and used to infer the empirical distribution of the estimated
objects; <code>lambda.rank.restriction</code>, a positive real number indicating
the value of the Lagrange multiplier of the nuclear norm constraint of the
affinity matrix, either chosen by the user or through Cross Validation;
<code>df.cross.validation</code>, a data frame containing the detailed results of
the cross validation exercise.
</p>


<h3>See Also</h3>

<p><strong>Dupuy, Arnaud, Alfred Galichon, and Yifei Sun</strong>. "Estimating
matching affinity matrices under low-rank constraints." <em>Information
and Inference: A Journal of the IMA</em> 8, no. 4 (2019): 677-689.
<strong>Dupuy, Arnaud, and Alfred Galichon</strong>. "Personality traits and the
marriage market." <em>Journal of Political Economy</em> 122, no. 6 (2014):
1271-1319.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Parameters
Kx = 2; Ky = 2; # number of matching variables on both sides of the market
N = 100 # sample size
mu = rep(0, Kx+Ky) # means of the data generating process
Sigma = matrix(c(1, -0.0244, 0.1489, -0.1301, -0.0244, 1, -0.0553, 0.2717,
                 0.1489, -0.0553, 1, -0.1959, -0.1301, 0.2717, -0.1959, 1),
                 nrow=Kx+Ky)
    # (normalized) variance-covariance matrix of the data generating process
labels_x = c("Height", "BMI") # labels for men's matching variables
labels_y = c("Height", "BMI") # labels for women's matching variables

# Sample
data = MASS::mvrnorm(N, mu, Sigma) # generating sample
X = data[,1:Kx]; Y = data[,Kx+1:Ky] # men's and women's sample data
w = sort(runif(N-1)); w = c(w,1) - c(0,w) # sample weights

# Main estimation
res = estimate.affinity.matrix.lowrank(X, Y, w = w, tol_level = 1e-03,
                                       nB = 50, Nfolds = 2)

# Summarize results
show.affinity.matrix(res, labels_x = labels_x, labels_y = labels_y)
show.diagonal(res, labels = labels_x)
show.test(res)
show.saliency(res, labels_x = labels_x, labels_y = labels_y,
              ncol_x = 2, ncol_y = 2)
show.cross.validation(res)
show.correlations(res, labels_x = labels_x, labels_y = labels_y,
                  label_x_axis = "Husband", label_y_axis = "Wife", ndims = 2)

</code></pre>


</div>