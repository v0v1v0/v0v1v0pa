<div class="container">

<table style="width: 100%;"><tr>
<td>boot.wt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model Selection Relative Frequencies
</h2>

<h3>Description</h3>

<p>This function computes the model selection relative frequencies based on
the nonparametric bootstrap (Burnham and Anderson 2002).  Models are
ranked based on the AIC, AICc, QAIC, or QAICc.  The function currently
supports objects of <code>aov</code>, <code>betareg</code>, <code>clm</code>, <code>glm</code>,
<code>hurdle</code>, <code>lm</code>, <code>multinom</code>, <code>polr</code>, <code>rlm</code>,
<code>survreg</code>, <code>vglm</code>, and <code>zeroinfl</code> classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
        sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICaov.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsurvreg'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsclm.clm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICglm.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AIChurdle'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)
       
## S3 method for class 'AIClm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICmultinom.nnet'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AICpolr'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICrlm.lm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICsurvreg'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)

## S3 method for class 'AICvglm'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, c.hat = 1, ...)

## S3 method for class 'AICzeroinfl'
boot.wt(cand.set, modnames = NULL, second.ord = TRUE, nobs = NULL,
       sort = TRUE, nsim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total sample
size to compute the AICc (i.e., <code>nobs</code> defaults to total number of
observations).  This is relevant only for certain types of models such 
as mixed models where sample size is not straightforward.  In 
such cases, one might use total number of observations or number of 
independent clusters (e.g., sites) as the value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the model selection table is ranked according
to the (Q)AIC(c) values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of c.hat different
from 1 are only appropriate for binomial GLM's with trials &gt; 1 (i.e.,
success/trial or cbind(success, failure) syntax) or with Poisson
GLM's.  If c.hat &gt; 1, <code>boot.wt</code> will return the quasi-likelihood
analogue of the information criterion requested.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>the number of bootstrap iterations. Burnham and Anderson
(2002) recommend at least 1000 and up to 10 000 iterations for certain
problems.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>boot.wt</code> is implemented for <code>aov</code>, <code>betareg</code>,
<code>glm</code>, <code>hurdle</code>, <code>lm</code>, <code>multinom</code>, <code>polr</code>,
<code>rlm</code>, <code>survreg</code>, <code>vglm</code>, and <code>zeroinfl</code> classes.
During each bootstrap iteration, the data are resampled with
replacement, all the models specified in <code>cand.set</code> are updated
with the new data set, and the top-ranked model is saved. When all
iterations are completed, the relative frequency of selection is
computed for each model appearing in the candidate model set.
</p>
<p>Relative frequencies of the models are often similar to Akaike
weights, and the latter are often preferred due to their link with
a Bayesian perspective (Burnham and Anderson 2002).  <code>boot.wt</code> is
most useful for teaching purposes of sampling-theory based relative
frequencies of model selection. The current implementation is only
appropriate with completely randomized designs.  For more complex data
structures (e.g., blocks or random effects), the bootstrap should be
modified accordingly.
</p>


<h3>Value</h3>

<p><code>boot.wt</code> creates an object of class <code>boot.wt</code> with the
following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Modname</code></td>
<td>
<p>the names of each model of the candidate model set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K </code></td>
<td>
<p>the number of estimated parameters for each model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>(Q)AIC(c) </code></td>
<td>
<p>the information criteria requested for each model
(AICc, AICc, QAIC, QAICc).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Delta_(Q)AIC(c) </code></td>
<td>
<p>the appropriate delta AIC component depending on
the information criteria selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ModelLik </code></td>
<td>
<p>the relative likelihood of the model given the
data (exp(-0.5*delta[i])).  This is not to be confused with the
likelihood of the parameters given the data.  The relative likelihood
can then be normalized across all models to get the model probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>(Q)AIC(c)Wt</code></td>
<td>
<p>the Akaike weights, also termed "model
probabilities" sensu Burnham and Anderson (2002) and Anderson (2008).
These measures indicate the level of support (i.e., weight of
evidence) in favor of any given model being the most parsimonious
among the candidate model set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PiWt </code></td>
<td>
<p>the relative frequencies of model selection from the bootstrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>
<p>if c.hat was specified as an argument, it is included in
the table.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2004) Multimodel inference:
understanding AIC and BIC in model selection. <em>Sociological Methods
and Research</em> <b>33</b>, 261–304.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169–180.
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>confset</code>, <code>c_hat</code>,
<code>evidence</code>, <code>importance</code>, <code>modavg</code>, 
<code>modavgShrink</code>, <code>modavgPred</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">##Mazerolle (2006) frog water loss example
data(dry.frog)

##setup a subset of models of Table 1
Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##create a vector of names to trace back models in set
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = " ")

##generate AICc table with bootstrapped relative
##frequencies of model selection
boot.wt(cand.set = Cand.models, modnames = Modnames, sort = TRUE,
        nsim = 10) #number of iterations should be much higher


##Burnham and Anderson (2002) flour beetle data
## Not run: 
data(beetle)
##models as suggested by Burnham and Anderson p. 198          
Cand.set &lt;- list( )
Cand.set[[1]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "logit"), weights = Number_tested,
                     data = beetle)
Cand.set[[2]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link = "probit"), weights = Number_tested,
                     data = beetle)
Cand.set[[3]] &lt;- glm(Mortality_rate ~ Dose, family =
                     binomial(link ="cloglog"), weights = Number_tested,
                     data = beetle)

##create a vector of names to trace back models in set
Modnames &lt;- paste("Mod", 1:length(Cand.set), sep = " ")

##model selection table with bootstrapped
##relative frequencies
boot.wt(cand.set = Cand.set, modnames = Modnames)

## End(Not run)
</code></pre>


</div>