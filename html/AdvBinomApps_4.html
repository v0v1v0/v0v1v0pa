<div class="container">

<table style="width: 100%;"><tr>
<td>ci.mult.ref.cm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Upper Clopper-Pearson confidence limits for area scaling with differently sized reference products and countermeasures
</h2>

<h3>Description</h3>

<p>Function to compute upper Clopper-Pearson confidence limits of failure probabilities on the basis of differently sized reference products and failures tackled by countermeasures. Optionally, the required numbers of additional inspections for each reference product to reach a predefined target failure probability of the follower product are returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ci.mult.ref.cm(k, n, A.ref, A.follow, K, theta, alpha = 0.1, 
p.target = 1, prec = 2, tailcut = 1e-08, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>vector of total numbers of failures for each reference product.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>vector of numbers of inspected devices for each reference product.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.ref</code></td>
<td>

<p>vector of chip sizes for each reference product (in mm^2).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.follow</code></td>
<td>

<p>size of follower product.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>matrix with entries K[j,i] denoting the number of failures of the j-th reference product tackled with the i-th countermeasure. If two or more countermeasures
have the same efficiency, they can be handled as one countermeasure for several failures. If the i-th countermeasure does not apply to the j-th reference product, then set K[j,i]=0. If there is no countermeasure for a failure at all, then it does not need to be considered in <code>K</code> (the failure itself is already considered in <code>k</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>

<p>vector of (different) effectivenesses of countermeasures.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>alpha-level (1-alpha confidence level, default: 0.1).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.target</code></td>
<td>

<p>target failure probability of follower product (optional).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>

<p>precision for greatest common divisor is 10^-<code>prec</code> (default: 2).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tailcut</code></td>
<td>

<p>probabilities for scaled failures smaller than <code>tailcut</code> are set to zero for each reference product (default: 1e-08). Too small values for <code>tailcut</code> might  cause increased computation times.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>tolerance of <code>uniroot</code>-function used for computing failure probability per greatest common chip size with countermeasures (default: 1e-12).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p.ref.cm</code></td>
<td>
<p>vector of upper Clopper-Pearson confidence limits for each reference product with countermeasures (without the other reference products).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.mm.cm</code></td>
<td>
<p>upper Clopper-Pearson confidence limit of the failure probability per mm^2 with countermeasures (on the basis of all reference products).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.follow.cm</code></td>
<td>
<p>upper Clopper-Pearson confidence limit of the failure probability of the follower product with countermeasures (on the basis of all reference products).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.add.cm</code></td>
<td>
<p>vector of required numbers of additional inspections for each reference product in order to reach p.target for the follower product with countermeasures.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Daniel Kurz, Horst Lewitschnig
</p>
<p>Maintainer: Horst Lewitschnig <a href="mailto:horst.lewitschnig@infineon.com">horst.lewitschnig@infineon.com</a>
</p>


<h3>References</h3>

<p>D. Kurz, H. Lewitschnig and J. Pilz: <em>Failure Probability Estimation with Differently Sized Reference Products for Semiconductor Burn-in Studies</em>. Applied Stochastic Models in Business and Industry, 31(5): 732-744, 2015. DOI: 10.1002/asmb.2100.
</p>
<p>D. Kurz, H. Lewitschnig and J. Pilz: <em>Decision-Theoretical Model for Failures Tackled by Countermeasures</em>. IEEE Transactions on Reliability, 63(2): 583-592, 2014. DOI: 10.1109/TR.2014.2315952.
</p>


<h3>See Also</h3>

<p><code>phi.mult.ref</code>
<code>ci.mult.ref</code>
<code>phi.mult.ref.cm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Reference product 1: 1 failure - failure tackled with 80% efficiency.
#Reference product 2: 2 failures - 1 failure tackled with 80%, 
#1 failure with 60% efficiency.
k&lt;-c(1,2)
K&lt;-matrix(c(1,0,1,1),2,2,byrow=TRUE)
n&lt;-c(110000,138000)
theta&lt;-c(0.8,0.6)
A.ref&lt;-c(5.21,10.71)
A.follow&lt;-8.5
p.target&lt;-20e-06
ci.mult.ref.cm(k,n,A.ref,A.follow,K,theta,p.target=p.target)

#Reference product 1: 1 failure - failure tackled with 20% efficiency.
#Reference product 2: 2 failures - 1 failure tackled with 20%, 
#1 failure with 40% efficiency.
#Reference product 3: 2 failures - both tackled with 60% efficiency.
k&lt;-c(1,2,2)
n&lt;-c(110000,138000,170000)
K&lt;-matrix(c(1,0,0,1,1,0,0,0,2),3,3,byrow=TRUE)
theta&lt;-c(0.2,0.4,0.6)
A.ref&lt;-c(5.21,10.71,7.89)
A.follow&lt;-8.5
p.target&lt;-20e-06
ci.mult.ref.cm(k,n,A.ref,A.follow,K,theta,p.target=p.target)

#Reference product 1: 1 failure - failure tackled with 20% efficiency.
#Reference product 2: 2 failures - 1 failure tackled with 40% efficiency, 
#1 failure without countermeasure.
#Reference product 3: 3 failures - 1 failure tackled with 60% efficiency, 
#2 failures without countermeasures.
k&lt;-c(1,2,3)
n&lt;-c(110000,138000,170000)
K&lt;-matrix(c(1,0,0,0,1,0,0,0,1),3,3,byrow=TRUE)
theta&lt;-c(0.2,0.4,0.6)
A.ref&lt;-c(5.21,10.71,7.89)
A.follow&lt;-8.5
p.target&lt;-20e-06
ci.mult.ref.cm(k,n,A.ref,A.follow,K,theta,p.target=p.target)

</code></pre>


</div>