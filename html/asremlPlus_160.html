<div class="container">

<table style="width: 100%;"><tr>
<td>sort.predictions.frame</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sorts a <code>predictions.frame</code> according to the predicted values 
associated with a factor.</h2>

<h3>Description</h3>

<p>Sorts the rows of a <code>predictions.frame</code> according to the predicted values 
in the <code>predictions.frame</code>. These predicted values are generally obtained using 
<code>predict.asreml</code> by specifying a <code>classify</code> term comprised of one or 
more variables. Generally, the values associated with one variable are sorted in 
parallel within each combination of values of the other variables. When there is more 
than one variable in the <code>classify</code> term, the sorting is controlled using 
one or more of <code>sortFactor</code>, <code>sortParallelToCombo</code> and <code>sortOrder</code>. 
If there is only one variable in the <code>classify</code> then the <code>predictions.frame</code> 
is sorted according to the order of the complete set of predictions.</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'predictions.frame'
sort(x, decreasing = FALSE, classify, sortFactor = NULL, 
     sortParallelToCombo = NULL, sortNestingFactor = NULL, 
     sortOrder = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>predictions.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order is for increasing or decreasing magnitude of the predicted 
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classify</code></td>
<td>
<p>A <code>character</code> string giving the variables that 
define the margins of the multiway table that was predicted. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortFactor</code></td>
<td>
<p>A <code>character</code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortParallelToCombo</code></td>
<td>
<p>A <code>list</code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code>list</code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortNestingFactor</code></td>
<td>
<p>A <code>character</code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortOrder</code></td>
<td>
<p>A <code>character</code> vector whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions.frame</code>. 
It specifies the desired order of the levels in the reordered 
the <code>predictions.frame</code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used at present.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The basic technique is to change the order of the levels of the <code>sortFactor</code> 
within the <code>predictions.frame</code> so 
that they are ordered for a subset of predicted values, one for each levels of the 
<code>sortFactor</code>. When the <code>classify</code> term consists of more than one 
variable then a subset of one combination of the values of variables other than
the <code>sortFactor</code>, the <code>sortParallelToCombo</code> combination, must be chosen for determining the 
order of the <code>sortFactor</code> levels. Then the sorting of the rows (and columns) 
will be in parallel within each combination of the values of <code>sortParallelToCombo</code> variables: 
the <code>classify</code> term, excluding the <code>sortFactor</code>.</p>


<h3>Value</h3>

<p>The sorted <code>predictions.frame</code>. Also, the <code>sortFactor</code> and 
<code>sortOrder</code> attributes are set.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>as.predictions.frame</code>, <code>print.predictions.frame</code>, 
<code>sort.alldiffs</code>, <br><code>predictPlus.asreml</code>, <code>predictPresent.asreml</code></p>


<h3>Examples</h3>

<pre><code class="language-R">##Halve WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
#Analyse pH  
m1.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m1.asr, NULL, NULL)
current.asrt &lt;- as.asrtests(m1.asr)
current.asrt &lt;- rmboundary(current.asrt)
m1.asr &lt;- current.asrt$asreml.obj

#Get predictions and associated statistics  
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = m1.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))
  
#Use sort.predictions.frame and save order for use with other response variables
TS.preds &lt;- TS.diffs$predictions
TS.preds.sort &lt;- sort(TS.preds, sortFactor = "Sources", 
                      sortParallelToCombo = list(Type = "Control"))
sort.order &lt;- attr(TS.preds.sort, which = "sortOrder")
  
#Analyse Turbidity
m2.asr &lt;- asreml(fixed = Turbidity ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m2.asr)
#Use pH sort.order to sort Turbidity alldiffs object
TS.diffs2 &lt;- predictPlus(m2.asr, classify = "Sources:Type", 
                         pairwise = FALSE, error.intervals = "Stand", 
                         tables = "none", present = c("Type","Species","Sources"))
TS.preds2 &lt;- TS.diffs2$predictions
TS.preds2.sort &lt;- sort(TS.preds, sortFactor = "Sources", sortOder = sort.order)

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  #Analyse pH
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  #Use sort.predictions.frame and save order for use with other response variables
  TS.preds.sort &lt;- sort(TS.preds, classify = "Sources:Type", sortFactor = "Sources", 
                        sortParallelToCombo = list(Type = "Control"))
  sort.order &lt;- attr(TS.preds.sort, which = "sortOrder")
  
  #Analyse Turbidity
  m2.lmer &lt;- lmerTest::lmer(Turbidity ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m2.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
}  
</code></pre>


</div>