<div class="container">

<table style="width: 100%;"><tr>
<td>ashape</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>alpha-shape calculation</h2>

<h3>Description</h3>

<p>This function calculates the <code class="reqn">\alpha</code>-shape of a given sample for <code class="reqn">\alpha&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ashape(x, y = NULL, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>The <code>x</code> and <code>y</code> coordinates of a set of points. Alternatively, a single argument <code>x</code> can be provided, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An attempt is made to interpret the arguments x and y in a way suitable for computing the <code class="reqn">\alpha</code>-shape, see <code>xy.coords</code>. 
</p>
<p>The <code class="reqn">\alpha</code>-shape is defined for any finite number of points. However, since the algorithm is based on the Delaunay triangulation, at least three non-collinear points are required. 
</p>
<p>If <code>y</code> is NULL and <code>x</code> is an object of class <code>"delvor"</code>, then the <code class="reqn">\alpha</code>-shape is computed without invoking again the function <code>delvor</code> (it reduces the computational cost). 
</p>
<p>The function <code>ashape</code> returns (among other values) the matrix <code>edges</code>. The structure of <code>edges</code> is that of matrix <code>mesh</code> returned by the function <code>delvor</code>. Note that the <code class="reqn">\alpha</code>-shape is a subgraph of the Delaunay triangulation and, therefore, <code>edges</code> is a submatrix of <code>mesh</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>A <em>n.seg</em>-row matrix with the coordinates and indexes of the edges of the Delaunay triangulation that form the <code class="reqn">\alpha</code>-shape. The number of rows <em>n.seg</em> coincides with the number of segments of the <code class="reqn">\alpha</code>-shape. The matrix also includes information of the Voronoi extremes corresponding to each segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>Length of the <code class="reqn">\alpha</code>-shape.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Value of <code class="reqn">\alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.extremes</code></td>
<td>
<p>Vector with the indexes of the sample points that are <code class="reqn">\alpha</code>-extremes. See Edelsbrunnner <em>et al.</em> (1983).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delvor.obj</code></td>
<td>
<p>Object of class <code>"delvor"</code> returned by the <code>delvor</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A 2-column matrix with the coordinates of the set of points.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Edelsbrunner, H., Kirkpatrick, D.G. and Seidel, R. (1983). On the shape of a set of points in the plane. <em>IEEE Transactions on Information Theory</em>, 29(4), pp.551-559.</p>


<h3>See Also</h3>

<p><code>plot.ashape</code>, <code>delvor</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Uniform sample of size n=300 in the annulus B(c,0.5)\B(c,0.25), 
# with c=(0.5,0.5). 
n &lt;- 300
theta&lt;-runif(n,0,2*pi)
r&lt;-sqrt(runif(n,0.25^2,0.5^2))
x&lt;-cbind(0.5+r*cos(theta),0.5+r*sin(theta))
# Value of alpha
alpha &lt;- 0.1
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)
# If we change the value of alpha there is no need to compute
# again the Delaunay triangulation and Voronoi Diagram
alpha &lt;- 0.4
ashape.obj.new &lt;- ashape(ashape.obj$delvor.obj, alpha = alpha)

# Random sample  from a uniform distribution on a Koch snowflake 
# with initial side length 1 and 3 iterations
x &lt;- rkoch(2000, side = 1, niter = 3)
# Value of alpha
alpha &lt;- 0.05
# alpha-shape 
ashape.obj &lt;- ashape(x, alpha = alpha)

## End(Not run)
</code></pre>


</div>