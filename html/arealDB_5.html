<div class="container">

<table style="width: 100%;"><tr>
<td>normTable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Normalise data tables</h2>

<h3>Description</h3>

<p>Harmonise and integrate data tables into standardised format
</p>


<h3>Usage</h3>

<pre><code class="language-R">normTable(
  input = NULL,
  pattern = NULL,
  ontoMatch = NULL,
  outType = "rds",
  beep = NULL,
  update = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>[<code>character(1)</code>]<br> path of the file to normalise. If this
is left empty, all files at stage two as subset by <code>pattern</code> are
chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>[<code>character(1)</code>]<br> an optional regular expression. Only
dataset names which match the regular expression will be processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ontoMatch</code></td>
<td>
<p>[<code>character(.)</code>]<br> name of the column(s) that shall be
matched with an ontology (defined in <code>start_arealDB</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outType</code></td>
<td>
<p>[<code>logical(1)</code>]<br> the output file-type, currently
implemented options are either <em>*.csv</em> (more exchangeable for a
workflow based on several programs) or <em>*.rds</em> (smaller and less
error-prone data-format but can only be read by R efficiently).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beep</code></td>
<td>
<p>[<code>integerish(1)</code>]<br> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code>beep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update</code></td>
<td>
<p>[<code>logical(1)</code>]<br> whether or not the physical files should
be updated (<code>TRUE</code>) or the function should merely return the new
object (<code>FALSE</code>, default). This is helpful to check whether the
metadata specification and the provided file(s) (translation and ID tables)
are properly specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br> be verbose about translating terms
(default <code>FALSE</code>). Furthermore, you can use
<code>suppressMessages</code> to make this function completely silent.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To normalise data tables, this function proceeds as follows:
</p>
 <ol>
<li>
<p> Read in <code>input</code> and extract initial metadata from
the file name. </p>
</li>
<li>
<p> Employ the function
<code>tabshiftr::reorganise</code> to reshape <code>input</code> according to
the respective schema description. </p>
</li>
<li>
<p> The territorial names are matched
with the gazetteer to harmonise new territorial names (at this step, the
function might ask the user to edit the file 'matching.csv' to align new
names with already harmonised names). </p>
</li>
<li>
<p> Harmonise territorial unit
names. </p>
</li>
<li>
<p> If <code>update = TRUE</code>, store the processed data table at
stage three.</p>
</li>
</ol>
<h3>Value</h3>

<p>This function harmonises and integrates so far unprocessed data
tables at stage two into stage three of the areal database. It produces for
each main polygon (e.g. nation) in the registered data tables a file that
includes all thematic areal data.
</p>


<h3>See Also</h3>

<p>Other normalise functions: 
<code>normGeometry()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(dev.interactive()){
  # build the example database
  makeExampleDB(until = "normGeometry", path = tempdir())

  # normalise all available data tables ...
  normTable(update = TRUE)

  # ... and check the result
  output &lt;- readRDS(paste0(tempdir(), "/adb_tables/stage3/Estonia.rds"))
}
</code></pre>


</div>