<div class="container">

<table style="width: 100%;"><tr>
<td>search-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Search object</h2>

<h3>Description</h3>

<p>This object defines the properties of a search in act.
It also contains the results of this search in a specific corpus, if the search has already been run. (Note that you can also create a search without running it immediately).
A search object can be run on different corpora.
</p>
<p>Some of the slots are defined by the user.
Other slots are <code>[READ ONLY]</code>, which means that they can be accessed by the user but
should not be changed. They contain values that are filled when you execute functions
on the object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt>
<dd>
<p>Character string; name of the search. Will be used, for example, as name of the sub folder when creating media cuts</p>
</dd>
<dt><code>pattern</code></dt>
<dd>
<p>Character string; search pattern as a regular expression.</p>
</dd>
<dt><code>search.mode</code></dt>
<dd>
<p>Character string; defines if the original contents of the annotations should be searched or if the full texts should be searched. Slot takes the following values: <code>content</code>, <code>fulltext</code> (=default, includes both full text modes), <code>fulltext.byTime</code>, <code>fulltext.byTier</code>.</p>
</dd>
<dt><code>search.normalized</code></dt>
<dd>
<p>logical. if <code>TRUE</code> the normalized annotations will be used for searching.</p>
</dd>
<dt><code>resultid.prefix</code></dt>
<dd>
<p>Character string; search results will be numbered consecutively; This character string will be placed before the consecutive numbers.</p>
</dd>
<dt><code>resultid.start</code></dt>
<dd>
<p>Integer; search results will be numbered consecutively; This is the start number of the identifiers.</p>
</dd>
<dt><code>filter.transcript.names</code></dt>
<dd>
<p>Vector of character strings; names of transcripts to include in the search. If the value is <code>character()</code> or <code>""</code> filter will be ignored.</p>
</dd>
<dt><code>filter.transcript.includeRegEx</code></dt>
<dd>
<p>Character string; Regular expression that defines which transcripts should be INcluded in the search (matching the name of the transcript).</p>
</dd>
<dt><code>filter.transcript.excludeRegEx</code></dt>
<dd>
<p>Character string; Regular expression that defines which transcripts should be EXcluded in the search (matching the name of the transcript).</p>
</dd>
<dt><code>filter.tier.names</code></dt>
<dd>
<p>Vector of character strings; names of tiers to include in the search. If the value is <code>character()</code> or <code>""</code> filter will be ignored.</p>
</dd>
<dt><code>filter.tier.includeRegEx</code></dt>
<dd>
<p>Character string; Regular expression that defines which tiers should be INcluded in the search (matching the name of the tier).</p>
</dd>
<dt><code>filter.tier.excludeRegEx</code></dt>
<dd>
<p>Character string; Regular expression that defines which tiers should be EXcluded in the search (matching the name of the tier).</p>
</dd>
<dt><code>filter.section.startsec</code></dt>
<dd>
<p>Double; Time value in seconds, limiting the search to a certain time span in each transcript, defining the start of the search window.</p>
</dd>
<dt><code>filter.section.endsec</code></dt>
<dd>
<p>Double; Time value in seconds, limiting the search to a certain time span in each transcript, defining the end of the search window.</p>
</dd>
<dt><code>concordance.make</code></dt>
<dd>
<p>Logical; If a concordance should be created when the search is run.</p>
</dd>
<dt><code>concordance.width</code></dt>
<dd>
<p>Integer; number of characters to include in the concordance.</p>
</dd>
<dt><code>cuts.span.beforesec</code></dt>
<dd>
<p>Double; Seconds how much the cuts (media and print transcripts) should start before the start of the search hit.</p>
</dd>
<dt><code>cuts.span.aftersec</code></dt>
<dd>
<p>Double; Seconds how much the cuts (media and print transcripts) should end after the end of the search hit.</p>
</dd>
<dt><code>cuts.column.srt</code></dt>
<dd>
<p>Character string; name of  destination column in the search results data frame where the srt substitles will be inserted; column will be created if not present in data frame; set to "" for no insertion.</p>
</dd>
<dt><code>cuts.column.printtranscript</code></dt>
<dd>
<p>Character string; name of  destination column in the search results data frame where the print transcripts will be inserted; column will be created if not present in data frame; set to "" for no insertion.</p>
</dd>
<dt><code>cuts.printtranscripts</code></dt>
<dd>
<p>Character string; <code>[READ ONLY]</code> All print transcripts for the search results (if generated previously)</p>
</dd>
<dt><code>cuts.cutlist.mac</code></dt>
<dd>
<p>Character string; <code>[READ ONLY]</code> 'FFmpeg' cut list for use on a Mac, to cut the media files for the search results.</p>
</dd>
<dt><code>cuts.cutlist.win</code></dt>
<dd>
<p>Character string; <code>[READ ONLY]</code> 'FFmpeg' cut list for use on Windows, to cut the media files for the search results.</p>
</dd>
<dt><code>results</code></dt>
<dd>
<p>Data.frame; Results of the search.1</p>
</dd>
<dt><code>results.nr</code></dt>
<dd>
<p>Integer; <code>[READ ONLY]</code> Number of search results.</p>
</dd>
<dt><code>results.tiers.nr</code></dt>
<dd>
<p>Integer; <code>[READ ONLY]</code> Number of tiers over which the search results are distrubuted.</p>
</dd>
<dt><code>results.transcripts.nr</code></dt>
<dd>
<p>Integer; <code>[READ ONLY]</code> Number of transcripts over which the search results are distrubuted.</p>
</dd>
<dt><code>x.name</code></dt>
<dd>
<p>Character string; <code>[READ ONLY]</code> name of the corpus object on which the search has been run.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
mysearch &lt;- act::search_new(examplecorpus, pattern= "yo")
mysearch
# Search in normalized content vs. original content
mysearch.norm  &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=TRUE)
mysearch.org   &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=FALSE)
mysearch.norm@results.nr
mysearch.org@results.nr

# The difference is because during normalization capital letters will be converted
# to small letters. One annotation in the example corpus contains a "yo" with a
# capital letter:
mysearch &lt;- act::search_new(examplecorpus, pattern="yO", searchNormalized=FALSE)
mysearch@results$hit

# Search in full text vs. original content.
# Full text search will find matches across annotations.
# Let's define a regular expression with a certain span.
# Search for the word "no" 'no' followed by a "pero" 'but'
# in a distance ranging from 1 to 20 characters.
myRegEx &lt;- "\\bno\\b.{1,20}pero"
mysearch &lt;- act::search_new(examplecorpus, pattern=myRegEx, searchMode="fulltext")
mysearch
mysearch@results$hit

</code></pre>


</div>