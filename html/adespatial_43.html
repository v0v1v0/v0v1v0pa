<div class="container">

<table style="width: 100%;"><tr>
<td>scores.listw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to compute and manage Moran's Eigenvector Maps (MEM) of a listw
object</h2>

<h3>Description</h3>

<p>These functions compute MEM (i.e., eigenvectors of a doubly centered spatial
weighting matrix). Corresponding eigenvalues are linearly related to Moran's
index of spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scores.listw(
  listw,
  wt = rep(1, length(listw$neighbours)),
  MEM.autocor = c("non-null", "all", "positive", "negative"),
  store.listw = FALSE
)

mem(
  listw,
  wt = rep(1, length(listw$neighbours)),
  MEM.autocor = c("non-null", "all", "positive", "negative"),
  store.listw = FALSE
)

orthobasis.listw(
  listw,
  wt = rep(1, length(listw$neighbours)),
  MEM.autocor = c("non-null", "all", "positive", "negative"),
  store.listw = FALSE
)

## S3 method for class 'orthobasisSp'
x[i, j, drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>An object of the class <code>listw</code> created by functions of the
<code>spdep</code> package</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>A vector of weights. It is used to orthogonalize the eigenvectors.
It could be useful if MEM are used in weighted regression or canonical
correspondence analysis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MEM.autocor</code></td>
<td>
<p>A string indicating if all MEMs must be returned or only
those corresponding to non-null, positive or negative autocorrelation. The
difference between options <code>all</code> and <code>non-null</code> is the following:
when there are several null eigenvalues, option <code>all</code> removes only one
of the eigenvectors with null eigenvalues and returns (n-1) eigenvectors,
whereas <code>non-null</code> does not return any of the eigenvectors with null
eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.listw</code></td>
<td>
<p>A logical indicating if the spatial weighting matrix
should be stored in the attribute <code>listw</code> of the returned object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>orthobasisSp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, j</code></td>
<td>
<p>Elements to extract (integer or empty): index of rows (i) and
columns (j).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>A logical. If TRUE, object containing only one colum is converted in 
vector</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Testing the nullity of eigenvalues is based on E(i)/E(1) where E(i) is i-th
eigenvalue and E(1) is the maximum absolute value of eigenvalues
</p>


<h3>Value</h3>

<p>An object of class <code>orthobasisSp</code> , subclass <code>orthobasis</code>. 
The MEMs are stored as a <code>data.frame</code>. It contains several attributes 
(see <code>?attributes</code>) including: </p>
<ul>
<li> <p><code>values</code>: The 
associated eigenvalues. </p>
</li>
<li> <p><code>listw</code>: The associated spatial 
weighting matrix (if <code>store.listw = TRUE</code>). </p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dray, S., Legendre, P., and Peres-Neto, P. R. (2006). Spatial
modeling: a comprehensive framework for principal coordinate analysis of
neighbor matrices (PCNM). <em>Ecological Modelling</em> <b>196</b>, 483–493.
</p>
<p>Griffith D. A. (1996) Spatial autocorrelation and eigenfunctions of the
geographic weights matrix accompanying geo-referenced data. <em>Canadian
Geographer</em> <b>40</b>, 351–367.
</p>


<h3>See Also</h3>

<p><code>nb2listw</code> <code>orthobasis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if(require("ade4", quietly = TRUE) &amp; require("spdep", quietly = TRUE)){
data(oribatid)
nbtri &lt;- tri2nb(as.matrix(oribatid$xy))
sc.tri &lt;- scores.listw(nb2listw(nbtri, style = "B"))
summary(sc.tri)
}
if(require("adegraphics", quietly = TRUE)){
s.value(oribatid$xy,sc.tri[,1:9])
plot(sc.tri[,1:6], oribatid$xy, pSp.cex = 5, pSp.alpha = 0.5, pbackground.col = 'lightblue')
}

</code></pre>


</div>