<div class="container">

<table style="width: 100%;"><tr>
<td>neig</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Neighbourhood Graphs</h2>

<h3>Description</h3>

<p><code>neig</code> creates objects of class <code>neig</code> with : <br>
a list of edges<br>
a binary square matrix<br>
a list of vectors of neighbours<br>
an integer (linear and circular graphs)<br>
a data frame of polygons (area)<br></p>
<p>scores.neig returns the eigenvectors of neighbouring,<br>
orthonormalized scores (null average, unit variance 1/n and null covariances) of maximal autocorrelation.<br></p>
<p>nb2neig returns an object of class <code>neig</code> using an object of class <code>nb</code> in the library 'spdep'
</p>
<p>neig2nb returns an object of class <code>nb</code> using an object of class <code>neig</code>
</p>
<p>neig2mat returns the incidence matrix between edges (1 = neighbour ; 0 = no neighbour)
</p>
<p>neig.util.GtoL and neig.util.LtoG are utilities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">neig(list = NULL, mat01 = NULL, edges = NULL,
    n.line = NULL, n.circle = NULL, area = NULL)

scores.neig  (obj) 
## S3 method for class 'neig'
print(x, ...) 
## S3 method for class 'neig'
summary(object, ...)
nb2neig (nb)
neig2nb (neig)
neig2mat (neig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>list</code></td>
<td>
<p>a list which each component gives the number of neighbours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat01</code></td>
<td>
<p>a symmetric square matrix of 0-1 values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>a matrix of 2 columns with integer values giving a list of edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.line</code></td>
<td>
<p>the number of points for a linear plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.circle</code></td>
<td>
<p>the number of points for a circular plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>area</code></td>
<td>
<p>a data frame containing a polygon set (see area.plot)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>an object of class 'nb'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neig, x, obj, object</code></td>
<td>
<p>an object of class 'neig'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Thioulouse, J., D. Chessel, and S. Champely. 1995. 
Multivariate analysis of spatial patterns: a unified approach to local and global structures.
<em>Environmental and Ecological Statistics</em>, <b>2</b>, 1â€“14.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(!adegraphicsLoaded()) {
  
  if(requireNamespace("deldir", quietly = TRUE)) {
  
    data(mafragh)
    par(mfrow = c(2, 1))
    provi &lt;- deldir::deldir(mafragh$xy)
    provi.neig &lt;- neig(edges = as.matrix(provi$delsgs[, 5:6]))
    
    s.label(mafragh$xy, neig = provi.neig, inc = FALSE, 
      addax = FALSE, clab = 0, cnei = 2)
    dist &lt;- apply(provi.neig, 1, function(x) 
      sqrt(sum((mafragh$xy[x[1], ] - mafragh$xy[x[2], ]) ^ 2)))
    #hist(dist, nclass = 50)
    mafragh.neig &lt;- neig(edges = provi.neig[dist &lt; 50, ])
    s.label(mafragh$xy, neig = mafragh.neig, inc = FALSE, 
      addax = FALSE, clab = 0, cnei = 2)
    par(mfrow = c(1, 1))
    
    data(irishdata)
    irish.neig &lt;- neig(area = irishdata$area)
    summary(irish.neig)
    print(irish.neig)
    s.label(irishdata$xy, neig = irish.neig, cneig = 3,
      area = irishdata$area, clab = 0.8, inc = FALSE)
    
    irish.scores &lt;- scores.neig(irish.neig)
    par(mfrow = c(2, 3))
    for(i in 1:6)
      s.value(irishdata$xy, irish.scores[, i], inc = FALSE, grid = FALSE, addax = FALSE,
        neig = irish.neig, csi = 2, cleg = 0, sub = paste("Eigenvector ",i), csub = 2)
    par(mfrow = c(1, 1))
    
    a.neig &lt;- neig(n.circle = 16)
    a.scores &lt;- scores.neig(a.neig)
    xy &lt;- cbind.data.frame(cos((1:16) * pi / 8), sin((1:16) * pi / 8))
    par(mfrow = c(4, 4))
    for(i in 1:15)
      s.value(xy, a.scores[, i], neig = a.neig, csi = 3, cleg = 0)
    par(mfrow = c(1, 1))
    
    a.neig &lt;- neig(n.line = 28)
    a.scores &lt;- scores.neig(a.neig)
    par(mfrow = c(7, 4))
    par(mar = c(1.1, 2.1, 0.1, 0.1))
    for(i in 1:27)
      barplot(a.scores[, i], col = grey(0.8))
    par(mfrow = c(1, 1))
  }

  if(requireNamespace("spdep", quietly = TRUE)) {
    
    data(mafragh)
    maf.rel &lt;- spdep::relativeneigh(as.matrix(mafragh$xy))
    maf.rel &lt;- spdep::graph2nb(maf.rel)
    s.label(mafragh$xy, neig = neig(list = maf.rel), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2)
    
    par(mfrow = c(2, 2))
    w &lt;- matrix(runif(100), 50, 2)
    x.gab &lt;- spdep::gabrielneigh(w)
    x.gab &lt;- spdep::graph2nb(x.gab)
    s.label(data.frame(w), neig = neig(list = x.gab), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "relative")
    x.rel &lt;- spdep::relativeneigh(w)
    x.rel &lt;- spdep::graph2nb(x.rel)
    s.label(data.frame(w), neig = neig(list = x.rel), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "Gabriel")
    k1 &lt;- spdep::knn2nb(spdep::knearneigh(w))
    s.label(data.frame(w), neig = neig(list = k1), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "k nearest neighbours")
    
    all.linked &lt;- max(unlist(spdep::nbdists(k1, w)))
    z &lt;- spdep::dnearneigh(w, 0, all.linked)
    s.label(data.frame(w), neig = neig(list = z), inc = FALSE, clab = 0, 
      addax = FALSE, cne = 1, cpo = 2, sub = "Neighbourhood contiguity by distance")
    par(mfrow = c(1, 1))
  }
  
}</code></pre>


</div>