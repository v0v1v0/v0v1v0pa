<div class="container">

<table style="width: 100%;"><tr>
<td>transform1d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>1D affine transformation matrices</h2>

<h3>Description</h3>

<p><code>transform1d()</code>, <code>reflect1d()</code>, <code>scale2d()</code>,
and <code>translate1d()</code> create 1D affine transformation matrix objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">transform1d(mat = diag(2L))

project1d(point = as_point1d("origin"), ...)

reflect1d(point = as_point1d("origin"), ...)

scale1d(x_scale = 1)

translate1d(x = as_coord1d(0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>A 2x2 matrix representing a post-multiplied affine transformation matrix.
The last <strong>column</strong> must be equal to <code>c(0, 1)</code>.
If the last <strong>row</strong> is <code>c(0, 1)</code> you may need to transpose it
to convert it from a pre-multiplied affine transformation matrix to a post-multiplied one.
If a 1x1 matrix we'll quietly add a final column/row equal to <code>c(0, 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point</code></td>
<td>
<p>A Point1D object of length one representing the point
you with to reflect across or project to or an object coercible to one by <code>as_point1d(point, ...)</code>
such as "origin".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Passed to <code>as_coord1d()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_scale</code></td>
<td>
<p>Scaling factor to apply to x coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A Coord1D object of length one or an object coercible to one by <code>as_coord1d(x, ...)</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<dl>
<dt><code>transform1d()</code></dt>
<dd>
<p>User supplied (post-multiplied) affine transformation matrix</p>
</dd>
</dl>
<p>.
</p>
<dl>
<dt><code>reflect1d()</code></dt>
<dd>
<p>Reflections across a point.</p>
</dd>
<dt><code>scale1d()</code></dt>
<dd>
<p>Scale the x-coordinates by multiplicative scale factors.</p>
</dd>
<dt><code>translate1d()</code></dt>
<dd>
<p>Translate the coordinates by a Coord1D class object parameter.</p>
</dd>
</dl>
<p><code>transform1d()</code> 1D affine transformation matrix objects are meant to be
post-multiplied and therefore should <strong>not</strong> be multiplied in reverse order.
Note the Coord1D class object methods auto-pre-multiply affine transformations
when "method chaining" so pre-multiplying affine transformation matrices
to do a single cumulative transformation instead of a method chain of multiple transformations
will not improve performance as much as as it does in other R packages.
</p>
<p>To convert a pre-multiplied 1D affine transformation matrix to a post-multiplied one
simply compute its transpose using <code>t()</code>.  To get an inverse transformation matrix
from an existing transformation matrix that does the opposite transformations
simply compute its inverse using <code>solve()</code>.
</p>


<h3>Value</h3>

<p>A 2x2 post-multiplied affine transformation matrix with classes "transform1d" and "at_matrix"
</p>


<h3>Examples</h3>

<pre><code class="language-R">p &lt;- as_coord1d(x = sample(1:10, 3))

# {affiner} affine transformation matrices are post-multiplied
# and therefore should **not** go in reverse order
mat &lt;- transform1d(diag(2)) %*%
         scale1d(2) %*%
         translate1d(x = -1)
p1 &lt;- p$
  clone()$
  transform(mat)

# The equivalent result appyling affine transformations via method chaining
p2 &lt;- p$
  clone()$
  transform(diag(2))$
  scale(2)$
  translate(x = -1)

all.equal(p1, p2)
</code></pre>


</div>