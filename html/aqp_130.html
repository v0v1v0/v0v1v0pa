<div class="container">

<table style="width: 100%;"><tr>
<td>harden.melanization</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Harden (1982) Melanization</h2>

<h3>Description</h3>

<p>Calculate "melanization" component of "Profile Development Index" after Harden (1982) "A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California". Accepts vectorized inputs for value and reference value to produce vector output. A convenient use case would be to apply this on a profile-specific basis, where the <code>value_ref</code> has a single value, and <code>value</code> is a vector of length equal to the number of horizons within the upper 100 cm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">harden.melanization(value, value_ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>numeric vector containing Munsell values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value_ref</code></td>
<td>
<p>A numeric vector containing Munsell value(s) for reference material</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In Harden (1982), "melanization" is calculated relative to a reference parent material for all horizons within 100cm of the soil surface. In addition, several other non-color components are normalized relative to a maximum value and summed to obtain the overall Profile Development Index.
</p>


<h3>Value</h3>

<p>A numeric vector reflecting horizon darkening relative to a reference (e.g. parent) material.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Harden, J.W. (1982) A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California. Geoderma. 28(1) 1-28. doi:  10.1016/0016-7061(82)90037-4
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

library(aqp)
data("jacobs2000", package="aqp")

# LEFT JOIN hue, value, chroma matrix color columns
horizons(jacobs2000) &lt;- cbind(horizons(jacobs2000)[,c(idname(jacobs2000), hzidname(jacobs2000))],
                              parseMunsell(jacobs2000$matrix_color_munsell, convertColors = FALSE))

# calculate a mixed 150-200cm color ~"parent material"

jacobs2000$c_horizon_color &lt;- profileApply(jacobs2000, function(p) {

  # and derive the parent material from the 150-200cm interval
  p150_200 &lt;- glom(p, 150, 200, truncate = TRUE)
  p150_200$thickness &lt;- p150_200$bottom - p150_200$top

  # mix colors
  clrs &lt;- na.omit(horizons(p150_200)[,c('matrix_color_munsell','thickness')])
  mixMunsell(clrs$matrix_color_munsell, w = clrs$thickness)$munsell

})

# segment profile into 1cm slices (for proper depth weighting)
jacobs2000$melan &lt;- profileApply(jacobs2000, function(p) {

  # sum the melanization index over the 0-100cm interval
  p0_100 &lt;- hz_segment(p, 0:100)

  ccol &lt;- parseMunsell(p$c_horizon_color, convertColors = FALSE)

  sum(harden.melanization(
    value = as.numeric(p0_100$value),
    value_ref = as.numeric(ccol$value)), na.rm = TRUE)

})

jacobs2000$melanorder &lt;- order(jacobs2000$melan)

# Plot in order of increasing Melanization index

plotSPC(jacobs2000, 
        color = "matrix_color",
        label = "melan",
        plot.order = jacobs2000$melanorder,
        max.depth = 250
        )

segments(
  x0 = 0.5, 
  x1 = length(jacobs2000) + 0.5, 
  y0 = c(0,100,150,200), 
  y1 = c(0,100,150,200), 
  lty = 2
)

# Add [estimated] parent material color swatches
lapply(seq_along(jacobs2000$c_horizon_color), function(i) {
  rect(i - 0.15, 250, i + 0.15, 225,
       col = parseMunsell(jacobs2000$c_horizon_color[jacobs2000$melanorder[i]]))
})
</code></pre>


</div>