<div class="container">

<table style="width: 100%;"><tr>
<td>aws</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>AWS for local constant models on a grid</h2>

<h3>Description</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models on a 1D, 2D or 3D grid. For "Gaussian"
models, i.e. regression with additive "Gaussian" errors, a homoskedastic
or heteroskedastic model is used depending on the content of <code>sigma2</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">aws(y,hmax=NULL, mask=NULL, aws=TRUE, memory=FALSE, family="Gaussian",
                lkern="Triangle", aggkern="Uniform",
                sigma2=NULL, shape=NULL, scorr=0, spmin=0.25,
		            ladjust=1,wghts=NULL,u=NULL,graph=FALSE,demo=FALSE,
                testprop=FALSE,maxni=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>array <code>y</code> containing the observe response (image intensity) data. <code>dim(y)</code> determines the dimensionality and extend of the grid design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmax</code></td>
<td>
 <p><code>hmax</code> specifies the maximal bandwidth. Defaults to <code>hmax=250, 12, 5</code>
for 1D, 2D, 3D images, respectively.
In case of <code>lkern="Gaussian"</code> the bandwidth is assumed to be given in full width half maximum (FWHM) units, i.e., <code>0.42466</code> times gridsize.   </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aws</code></td>
<td>
<p> logical: if TRUE structural adaptation (AWS) is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p> optional logical mask, same dimensionality as <code>y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memory</code></td>
<td>
<p> logical: if TRUE stagewise aggregation is used as an additional
adaptation scheme. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p><code>family</code> specifies the probability distribution. Default is <code>family="Gaussian"</code>, also implemented
are "Bernoulli", "Poisson", "Exponential", "Volatility", "Variance" and "NCchi". <code>family="Volatility"</code> specifies a Gaussian distribution with
expectation 0 and unknown variance. <code>family="Volatility"</code> specifies that <code>p*y/theta</code> is distributed as <code class="reqn">\chi^2</code> with <code>p=shape</code>
degrees of freedom. <code>family="NCchi"</code> uses a noncentral Chi distribution with <code>p=shape</code> degrees of freedom and noncentrality parameter <code>theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lkern</code></td>
<td>
<p> character: location kernel, either "Triangle", "Plateau", "Quadratic", "Cubic" or "Gaussian".
The default "Triangle" is equivalent to using an Epanechnikov kernel, "Quadratic" and  "Cubic" refer to a Bi-weight and Tri-weight
kernel, see Fan and Gijbels (1996). "Gaussian" is a truncated (compact support) Gaussian kernel.
This is included for comparisons only and should be avoided due to its large computational costs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggkern</code></td>
<td>
<p> character: kernel used in stagewise aggregation, either "Triangle" or "Uniform" </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p><code>sigma2</code> allows to specify the variance in case of <code>family="Gaussian"</code>. Not used if <code>family!="Gaussian"</code>.
Defaults to <code>NULL</code>. In this case a homoskedastic variance estimate is generated. If <code>length(sigma2)==length(y)</code> then <code>sigma2</code>
is assumed to contain the pointwise variance of <code>y</code> and a heteroscedastic variance model is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>Allows to specify an additional shape parameter for certain family models. Currently only used for family="Variance", that is <code class="reqn">\chi</code>-Square distributed observations
with <code>shape</code> degrees of freedom. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scorr</code></td>
<td>
<p>The vector <code>scorr</code> allows to specify a first order correlations of the noise for each coordinate direction,
defaults to 0 (no correlation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spmin</code></td>
<td>
<p>Determines the form (size of the plateau) in the adaptation kernel.
Not to be changed by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ladjust</code></td>
<td>
<p> factor to increase the default value of lambda </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wghts</code></td>
<td>
 <p><code>wghts</code> specifies the  diagonal elements of a weight matrix to adjust for different distances between grid-points
in different coordinate directions, i.e. allows to define a more appropriate metric in the design space. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p> a "true" value of the regression function, may be provided to
report risks at each iteration. This can be used to test the propagation condition with <code>u=0</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>If  <code>graph=TRUE</code> intermediate results are illustrated after each iteration step. Defaults to <code>graph=FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demo</code></td>
<td>
<p> If <code>demo=TRUE</code> the function pauses after each iteration. Defaults to <code>demo=FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testprop</code></td>
<td>
<p>If set this provides diagnostics for testing the propagation condition. The values of <code>y</code> should correspond to the specified
family and a global model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxni</code></td>
<td>
<p>If TRUE use <code class="reqn">max_{l&lt;=k}(N_i^{(l)}</code> instead of <code class="reqn">(N_i^{(k)}</code> in the definition of the statistical penalty.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function implements the propagation separation approach to
nonparametric smoothing (formerly introduced as Adaptive weights smoothing)
for varying coefficient likelihood models  on a 1D, 2D or 3D grid. For "Gaussian"
models, i.e. regression with additive "Gaussian" errors, a homoskedastic
or heteroskedastic model is used depending on the content of <code>sigma2</code>.
<code>aws==FALSE</code> provides the stagewise aggregation procedure from Belomestny and Spokoiny (2004).
<code>memory==FALSE</code> provides Adaptive weights smoothing without control by stagewise aggregation.
</p>
<p>The essential parameter in the procedure is a critical value <code>lambda</code>. This parameter has an
interpretation as a significance level of a test for equivalence of two local
parameter estimates. Optimal values mainly depend on the choosen <code>family</code>.
Values set internally are choosen to fulfil a propagation condition, i.e. in case of a
constant (global) parameter value and large <code>hmax</code> the procedure
provides, with a high probability, the global (parametric) estimate.
More formally we require the parameter <code>lambda</code>
to be specified such that
<code class="reqn">\bf{E} |\hat{\theta}^k - \theta| \le (1+\alpha) \bf{E} |\tilde{\theta}^k - \theta|</code>
where <code class="reqn">\hat{\theta}^k</code> is the aws-estimate in step <code>k</code> and <code class="reqn">\tilde{\theta}^k</code>
is corresponding nonadaptive estimate using the same bandwidth (<code>lambda=Inf</code>).
The value of lambda can be adjusted by specifying the factor <code>ladjust</code>. Values <code>ladjust&gt;1</code> lead to an less effective adaptation while <code>ladjust&lt;&lt;1</code> may lead to random segmentation
of, with respect to a constant model, homogeneous regions.
</p>
<p>The numerical complexity of the procedure is mainly determined by <code>hmax</code>. The number
of iterations is approximately <code>Const*d*log(hmax)/log(1.25)</code> with <code>d</code> being the dimension
of <code>y</code> and the constant depending on the kernel <code>lkern</code>. Comlexity in each iteration step is <code>Const*hakt*n</code> with <code>hakt</code>
being the actual bandwith in the iteration step and <code>n</code> the number of design points.
<code>hmax</code> determines the maximal possible variance reduction.
</p>


<h3>Value</h3>

<p>returns anobject of class <code>aws</code> with slots
</p>
<table>
<tr style="vertical-align: top;">
<td><code>y = "numeric"</code></td>
<td>
<p>y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dy = "numeric"</code></td>
<td>
<p>dim(y)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ni = "integer"</code></td>
<td>
<p>integer(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask = "logical"</code></td>
<td>
<p>logical(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta = "numeric"</code></td>
<td>
<p>Estimates of regression function, <code>length: length(y)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mae = "numeric"</code></td>
<td>
<p>Mean absolute error for each iteration step if u was specified,  numeric(0) else</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var = "numeric"</code></td>
<td>
<p>approx. variance of the estimates of the regression function. Please note that this does not reflect variability due to randomness of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmin = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmax = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wghts = "numeric"</code></td>
<td>
<p>numeric(0), ratio of distances <code>wghts[-1]/wghts[1]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree = "integer"</code></td>
<td>
<p>0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmax  = "numeric"</code></td>
<td>
<p>effective hmax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2  = "numeric"</code></td>
<td>
<p>provided or estimated error variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scorr = "numeric"</code></td>
<td>
<p>scorr</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family = "character"</code></td>
<td>
<p>family</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape = "numeric"</code></td>
<td>
<p>shape</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lkern  = "integer"</code></td>
<td>
<p>integer code for lkern,
1="Plateau", 2="Triangle", 3="Quadratic", 4="Cubic", 5="Gaussian"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda = "numeric"</code></td>
<td>
<p>effective value of lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ladjust = "numeric"</code></td>
<td>
<p>effective value of ladjust</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aws = "logical"</code></td>
<td>
<p>aws</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memory = "logical"</code></td>
<td>
<p>memory</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>homogen = "logical"</code></td>
<td>
<p>homogen</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>earlystop = "logical"</code></td>
<td>
<p>FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varmodel = "character"</code></td>
<td>
<p>"Constant"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcoef = "numeric"</code></td>
<td>
<p>numeric(0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call = "function"</code></td>
<td>
<p>the arguments of the call to <code>aws</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>use <code>setCores='number of threads'</code> to enable parallel execution.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl, <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
<a href="https://www.wias-berlin.de/people/polzehl/">https://www.wias-berlin.de/people/polzehl/</a></p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Appendix A.
Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl, K. Papafitsoros, K. Tabelow (2020). Patch-Wise Adaptive Weights Smoothing in R, Journal of
Statistical Software, 95(6), 1-27. doi:10.18637/jss.v095.i06.
</p>
<p>J. Polzehl, V. Spokoiny,  Adaptive Weights Smoothing with applications to image restoration,
J. R. Stat. Soc. Ser. B Stat. Methodol.  62 ,  (2000)  , pp. 335–354. DOI:10.1111/1467-9868.00235.
</p>
<p>J. Polzehl, V. Spokoiny,  Propagation-separation approach for local likelihood estimation,
Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335–362. DOI:10.1007/s00440-005-0464-1.
</p>


<h3>See Also</h3>

<p>See also <code>paws</code>, <code>lpaws</code>, <code>vaws</code>,<code>link{awsdata}</code>, <code>aws.irreg</code>, <code>aws.gaussian</code></p>


<h3>Examples</h3>

<pre><code class="language-R">require(aws)
# 1D local constant smoothing
## Not run: demo(aws_ex1)
## Not run: demo(aws_ex2)
# 2D local constant smoothing
## Not run: demo(aws_ex3)
</code></pre>


</div>