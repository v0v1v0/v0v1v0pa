<div class="container">

<table style="width: 100%;"><tr>
<td>animint2-gganimintproto</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Base gganimintproto classes for ggplot2</h2>

<h3>Description</h3>

<p>If you are creating a new geom, stat, position, or scale in another package,
you'll need to extend from <code>animint2::Geom</code>, <code>animint2::Stat</code>,
<code>animint2::Position</code>, or <code>animint2::Scale</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">a_scales_list()

ScalesList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ScalesList</code> (inherits from <code>gganimintproto</code>) of length 9.
</p>


<h3>Geoms</h3>

<p>All <code>geom_*</code> functions (like <code>geom_point</code>) return a layer that
contains a <code>Geom*</code> object (like <code>GeomPoint</code>). The <code>Geom*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code>Geom*</code> objects is a <code>gganimintproto</code> object, descended
from the top-level <code>Geom</code>, and each implements various methods and
fields. To create a new type of Geom object, you typically will want to
implement one or more of the following:
</p>
<p>Compared to <code>Stat</code> and <code>Position</code>, <code>Geom</code> is a little
different because the execution of the setup and compute functions is
split up. <code>setup_data</code> runs before position adjustments, and
<code>draw_layer</code> is not run until render time,  much later. This
means there is no <code>setup_params</code> because it's hard to communicate
the changes.
</p>

<ul>
<li>
<p> Override either <code>draw_panel(self, data, panel_scales, coord)</code> or
<code>draw_group(self, data, panel_scales, coord)</code>. <code>draw_panel</code> is
called once per panel, <code>draw_group</code> is called once per group.
</p>
<p>Use <code>draw_panel</code> if each row in the data represents a
single element. Use <code>draw_group</code> if each group represents
an element (e.g. a smooth, a violin).
</p>
<p><code>data</code> is a data frame of scaled aesthetics. <code>panel_scales</code>
is a list containing information about the scales in the current
panel. <code>coord</code> is a coordinate specification. You'll
need to call <code>coord$transform(data, panel_scales)</code> to work
with non-Cartesian coords. To work with non-linear coordinate systems,
you typically need to convert into a primitive geom (e.g. point, path
or polygon), and then pass on to the corresponding draw method
for munching.
</p>
<p>Must return a grob. Use <code>zeroGrob</code> if there's nothing to
draw.
</p>
</li>
<li> <p><code>draw_key</code>: Renders a single legend key.
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code>aes()</code> of
default values for aesthetics.
</p>
</li>
<li> <p><code>reparameterise</code>: Converts width and height to xmin and xmax,
and ymin and ymax values. It can potentially set other values as well.
</p>
</li>
</ul>
<h3>Coordinate systems</h3>

<p>All <code>coord_*</code> functions (like <code>coord_trans</code>) return a <code>Coord*</code>
object (like <code>CoordTrans</code>). The <code>Coord*</code> object is responsible for
adjusting the position of overlapping geoms.
</p>
<p>The way that the <code>coord_*</code> functions work is slightly different from the
<code>geom_*</code> and <code>stat_*</code> functions, because a <code>coord_*</code> function
actually "instantiates" the <code>Coord*</code> object by creating a descendant,
and returns that.
</p>
<p>Each of the <code>Coord*</code> objects is a <code>gganimintproto</code> object,
descended from the top-level <code>Coord</code>.  To create a new type of Coord
object, you typically will want to implement one or more of the following:
</p>

<ul>
<li> <p><code>aspect</code>: Returns the desired aspect ratio for the plot.
</p>
</li>
<li> <p><code>labels</code>: Returns a list containing labels for x and y.
</p>
</li>
<li> <p><code>render_fg</code>: Renders foreground elements.
</p>
</li>
<li> <p><code>render_bg</code>: Renders background elements.
</p>
</li>
<li> <p><code>render_axis_h</code>: Renders the horizontal axis.
</p>
</li>
<li> <p><code>render_axis_v</code>: Renders the vertical axis.
</p>
</li>
<li> <p><code>range</code>: Returns the x and y ranges
</p>
</li>
<li> <p><code>train</code>: Return the trained scale ranges.
</p>
</li>
<li> <p><code>transform</code>: Transforms x and y coordinates.
</p>
</li>
<li> <p><code>distance</code>: Calculates distance.
</p>
</li>
<li> <p><code>is_linear</code>: Returns <code>TRUE</code> if the coordinate system is
linear; <code>FALSE</code> otherwise.
</p>
</li>
</ul>
<h3>Stats</h3>

<p>All <code>stat_*</code> functions (like <code>stat_bin</code>) return a layer that
contains a <code>Stat*</code> object (like <code>StatBin</code>). The <code>Stat*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code>Stat*</code> objects is a <code>gganimintproto</code> object, descended
from the top-level <code>Stat</code>, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
implement one or more of the following:
</p>

<ul>
<li>
<p> Override one of :
<code>compute_layer(self, data, scales, ...)</code>,
<code>compute_panel(self, data, scales, ...)</code>, or
<code>compute_group(self, data, scales, ...)</code>.
</p>
<p><code>compute_layer()</code> is called once per layer, <code>compute_panel_()</code>
is called once per panel, and <code>compute_group()</code> is called once per
group. All must return a data frame.
</p>
<p>It's usually best to start by overriding <code>compute_group</code>: if
you find substantial performance optimisations, override higher up.
You'll need to read the source code of the default methods to see
what else you should be doing.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels.<code>...</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setp_params()</code>. Should return modified <code>data</code>.
Default methods removes all rows containing a missing value in
required aesthetics (with a warning if <code>!na.rm</code>).
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code>aes()</code> of
default values for aesthetics.
</p>
</li>
</ul>
<h3>Positions</h3>

<p>All <code>position_*</code> functions (like <code>position_dodge</code>) return a
<code>Position*</code> object (like <code>PositionDodge</code>). The <code>Position*</code>
object is responsible for adjusting the position of overlapping geoms.
</p>
<p>The way that the <code>position_*</code> functions work is slightly different from
the <code>geom_*</code> and <code>stat_*</code> functions, because a <code>position_*</code>
function actually "instantiates" the <code>Position*</code> object by creating a
descendant, and returns that.
</p>
<p>Each of the <code>Position*</code> objects is a <code>gganimintproto</code> object,
descended from the top-level <code>Position</code>, and each implements the
following methods:
</p>

<ul>
<li> <p><code>compute_layer(self, data, params, panel)</code> is called once
per layer. <code>panel</code> is currently an internal data structure, so
this method should not be overriden.
</p>
</li>
<li> <p><code>compute_panel(self, data, params, panel)</code> is called once per
panel and should return a modified data frame.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels. <code>params</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setp_params()</code>. Should return modified <code>data</code>.
Default checks that required aesthetics are present.
</p>
</li>
</ul>
<p>And the following fields
</p>

<ul><li> <p><code>required_aes</code>: a character vector giving the aesthetics
that must be present for this position adjustment to work.
</p>
</li></ul>
<h3>Scales</h3>

<p>All <code>scale_*</code> functions (like <code>scale_x_continuous</code>) return a
<code>Scale*</code> object (like <code>ScaleContinuous</code>). The <code>Scale*</code>
object represents a single scale.
</p>
<p>Each of the <code>Scale*</code> objects is a <code>gganimintproto</code> object,
descended from the top-level <code>Scale</code>.
</p>


<h3>See Also</h3>

<p>gganimintproto
</p>


</div>