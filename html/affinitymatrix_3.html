<div class="container">

<table style="width: 100%;"><tr>
<td>estimate.affinity.matrix.unipartite</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate Ciscato, Galichon and Gousse's model</h2>

<h3>Description</h3>

<p>This function estimates the affinity matrix of the matching model of Ciscato
Gousse and Galichon (2020), performs the saliency analysis and the rank
tests. The user must supply a <em>matched sample</em> that is treated as the
equilibrium matching of a bipartite one-to-one matching model without
frictions and with Transferable Utility. The model differs from the original
Dupuy and Galichon (2014) since all agents are pooled in one group and can
match within the group. For the sake of clarity, in the documentation we take
the example of the same-sex marriage market and refer to "first partner" and
"second partner" in order to distinguish between the arbitrary partner order
in a database (e.g., survey respondent and partner of the respondent). Note
that in this case the variable "sex" is treated as a matching variable rather
than a criterion to assign partners to one side of the market as in the
bipartite case. Other applications may include matching between coworkers,
roommates or teammates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate.affinity.matrix.unipartite(
  X,
  Y,
  w = rep(1, N),
  A0 = matrix(0, nrow = K, ncol = K),
  lb = matrix(-Inf, nrow = K, ncol = K),
  ub = matrix(Inf, nrow = K, ncol = K),
  pr = 0.05,
  max_iter = 10000,
  tol_level = 1e-06,
  scale = 1,
  nB = 2000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The matrix of traits of the first partner. Its rows must be ordered
so that the i-th individual in <code>X</code> is matched with the i-th partner in
<code>Y</code>: this means that <code>nrow(X)</code> must be equal to <code>nrow(Y)</code>.
Its columns correspond to the different matching variables: <code>ncol(X)</code>
must be equal to <code>ncol(Y)</code> and the variables must be sorted in the
same way in both matrices. The matrix is demeaned and rescaled before the
start of the estimation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The matrix of traits of the second partner. Its rows must be ordered
so that the i-th individual in <code>Y</code> is matched with the i-th partner in
<code>X</code>: this means that <code>nrow(Y)</code> must be equal to <code>nrow(X)</code>.
Its columns correspond to the different matching variables: <code>ncol(Y)</code>
must be equal to <code>ncol(X)</code> and the variables must be sorted in the
same way in both matrices. The matrix is demeaned and rescaled before the
start of the estimation algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A vector of sample weights with length <code>nrow(X)</code>. Defaults to
uniform weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A0</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the initial values of the affinity matrix to be fed to the
estimation algorithm. Optional. Defaults to a matrix of zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the lower bounds of the elements of the affinity matrix.
Defaults to <code>-Inf</code> for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>A vector or matrix with <code>ncol(X)*ncol(Y)</code> elements
corresponding to the upper bounds of the elements of the affinity matrix.
Defaults to <code>Inf</code> for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr</code></td>
<td>
<p>A probability indicating the significance level used to compute
bootstrap two-sided confidence intervals for <code>U</code>, <code>V</code> and
<code>lambda</code>. Defaults to 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>An integer indicating the maximum number of iterations in the
Maximum Likelihood Estimation. See <code>optim</code> for the
<code>"L-BFGS-B"</code> method. Defaults to 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_level</code></td>
<td>
<p>A positive real number indicating the tolerance level in the
Maximum Likelihood Estimation. See <code>optim</code> for the
<code>"L-BFGS-B"</code> method. Defaults to 1e-6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A positive real number indicating the scale of the model.
Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nB</code></td>
<td>
<p>An integer indicating the number of bootstrap replications used to
compute the confidence intervals of <code>U</code>, <code>V</code> and <code>lambda</code>.
Defaults to 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, the function displays messages to keep track
of its progress. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns a list with elements: <code>X</code>, the demeaned and
rescaled matrix of traits of the first partner; <code>Y</code>, the demeaned and
rescaled matrix of traits of the second partner; <code>fx</code>, the empirical
marginal distribution of first partners; <code>fy</code>, the empirical marginal
distribution of second partners; <code>Aopt</code>, the estimated affinity
matrix; <code>sdA</code>, the standard errors of <code>Aopt</code>; <code>tA</code>, the
Z-test statistics of <code>Aopt</code>; <code>VarCovA</code>, the full
variance-covariance matrix of <code>Aopt</code>; <code>rank.tests</code>, a list with
all the summaries of the rank tests on <code>Aopt</code>; <code>U</code>, whose columns
are the left-singular vectors of <code>Aopt</code>; <code>V</code>, whose columns are
the right-singular vectors of <code>Aopt</code>; <code>lambda</code>, whose elements
are the singular values of <code>Aopt</code>; <code>UCI</code>, whose columns are the
lower and the upper bounds of the confidence intervals of <code>U</code>;
<code>VCI</code>, whose columns are the lower and the upper bounds of the
confidence intervals of <code>V</code>; <code>lambdaCI</code>, whose columns are the
lower and the upper bounds of the confidence intervals of <code>lambda</code>;
<code>df.bootstrap</code>, a data frame resulting from the <code>nB</code> bootstrap
replications and used to infer the empirical distribution of the estimated
objects.
</p>


<h3>See Also</h3>

<p><strong>Ciscato, Edoardo, Alfred Galichon, and Marion Gousse</strong>. "Like
attract like? a structural comparison of homogamy across same-sex and
different-sex households." <em>Journal of Political Economy</em> 128, no. 2
(2020): 740-781. <strong>Dupuy, Arnaud, and Alfred Galichon</strong>. "Personality
traits and the marriage market." <em>Journal of Political Economy</em> 122,
no. 6 (2014): 1271-1319.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Parameters
K = 4 # number of matching variables
N = 100 # sample size
mu = rep(0, 2*K) # means of the data generating process
Sigma = matrix(c(1, -0.0992, 0.0443, -0.0246, -0.8145, 0.083, -0.0438,
    0.0357, -0.0992, 1, 0.0699, -0.0043, 0.083, 0.8463, 0.0699, -0.0129, 0.0443,
    0.0699, 1, -0.0434, -0.0438, 0.0699, 0.5127, -0.0383, -0.0246, -0.0043,
    -0.0434, 1, 0.0357, -0.0129, -0.0383, 0.6259, -0.8145, 0.083, -0.0438,
    0.0357, 1, -0.0992, 0.0443, -0.0246, 0.083, 0.8463, 0.0699, -0.0129, -0.0992,
    1, 0.0699, -0.0043, -0.0438, 0.0699, 0.5127, -0.0383, 0.0443, 0.0699, 1,
    -0.0434, 0.0357, -0.0129, -0.0383, 0.6259, -0.0246, -0.0043, -0.0434, 1),
               nrow=K+K) # (normalized) variance-covariance matrix of the
               # data generating process with a block symmetric structure
labels = c("Sex", "Age", "Educ.", "Black") # labels for matching variables

# Sample
data = MASS::mvrnorm(N, mu, Sigma) # generating sample
X = data[,1:K]; Y = data[,K+1:K] # men's and women's sample data
w = sort(runif(N-1)); w = c(w,1) - c(0,w) # sample weights

# Main estimation
res = estimate.affinity.matrix.unipartite(X, Y, w = w, nB = 500)

# Summarize results
show.affinity.matrix(res, labels_x = labels, labels_y = labels)
show.diagonal(res, labels = labels)
show.test(res)
show.saliency(res, labels_x = labels, labels_y = labels,
              ncol_x = 2, ncol_y = 2)
show.correlations(res, labels_x = labels, labels_y = labels,
                  label_x_axis = "First partner",
                  label_y_axis = "Second partner", ndims = 2)

</code></pre>


</div>