<div class="container">

<table style="width: 100%;"><tr>
<td>s1d.density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>1-D plot of a numeric score by density curves</h2>

<h3>Description</h3>

<p>This function represents a score with a density curve for each level of a factor.
</p>


<h3>Usage</h3>

<pre><code class="language-R">s1d.density(score, fac = gl(1, NROW(score)), kernel = c("normal", "box", 
  "epanech", "biweight", "triweight"), bandwidth = NULL, gridsize = 450, 
  col = NULL, fill = TRUE, facets = NULL, plot = TRUE, storeData = TRUE,
  add = FALSE, pos = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>a numeric vector (or a data frame) used to produce the plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>a factor (or a matrix of factors) to split <code>score</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>the smoothing kernel used, see <code>bkde</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridsize</code></td>
<td>
<p>the number of equally spaced points at which to estimate the density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>a logical, a color or a colors vector for labels, rugs, lines and polygons according to their factor level. 
Colors are recycled whether there are not one color by factor level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>a logical to yield the polygons density curves filled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>facets</code></td>
<td>
<p>a factor splitting <code>score</code> so that subsets
of the data are represented on different sub-graphics</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>a logical indicating if the graphics is displayed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>storeData</code></td>
<td>
<p>a logical indicating if the data are stored in
the returned object. If <code>FALSE</code>, only the names of the data
arguments are stored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the graphic is superposed to the graphics
already plotted in the current device</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>an integer indicating the position of the
environment where the data are stored, relative to the environment
where the function is called. Useful only if <code>storeData</code> is
<code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional graphical parameters (see
<code>adegpar</code> and <code>trellis.par.get</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>kernel</code>, <code>bandwidth</code> and <code>gridsize</code> are passed as parameters to <code>bkde</code> function of the <code>KernSmooth</code> package.
</p>
<p>Graphical parameters for rugs are available in <code>plines</code> of <code>adegpar</code> and the ones for density curves filled in <code>ppolygons</code>.
Some appropriated graphical parameters in <code>p1d</code> are also available.
</p>


<h3>Value</h3>

<p>An object of class <code>ADEg</code> (subclass <code>C1.density</code>) or <code>ADEgS</code> (if <code>add</code> is <code>TRUE</code> and/or 
if facets or data frame for <code>score</code> or data frame for <code>fac</code> are used).<br>
The result is displayed if <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Alice Julien-Laferriere, Aurelie Siberchicot <a href="mailto:aurelie.siberchicot@univ-lyon1.fr">aurelie.siberchicot@univ-lyon1.fr</a> and Stephane Dray
</p>


<h3>See Also</h3>

<p><code>C1.density</code>
<code>ADEg.C1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">score &lt;- c(rnorm(1000, mean = -0.5, sd = 0.5), rnorm(1000, mean = 1))
fac &lt;- rep(c("A", "B"), each = 1000)
s1d.density(score, fac, col = c(2, 4), p1d.reverse = TRUE)
</code></pre>


</div>