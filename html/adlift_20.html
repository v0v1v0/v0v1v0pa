<div class="container">

<table style="width: 100%;"><tr>
<td>denoiseheteroprop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>denoiseheteroprop</h2>

<h3>Description</h3>

<p>Denoises the inputted signal using artificial levels noise variance estimation and bayesian thresholding, assuming noise variances known up to proportionality constants.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">denoiseheteroprop(x, f, pred, neigh, int, clo, keep, 
rule = "median",gamvec,returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and <code>AdaptNeigh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or "hard or <br> "soft" (hard or soft thresholding). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamvec</code></td>
<td>
<p>A vector of proportions of the noise standard deviations (in the order of <span class="env">x</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform, so that they can be used in the bayesian thresholding procedure EbayesThresh.  The normalising factors are calculated assuming that the noise associated to the ith gridpoint is <code class="reqn">\gamma_{i}\sigma</code>. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variance of the coefficients.  EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>the matrix associated to the wavelet transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code>denoise</code>   </p>


<h3>Examples</h3>

<pre><code class="language-R">x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
n1&lt;-rnorm(256,0,.1)
z1&lt;-y1+n1
gvec&lt;-c(rep(.4,times=100),rep(.7,times=100),rep(.3,times=56))
#
est1&lt;-denoiseheteroprop(x1,z1,AdaptNeigh,1,TRUE,TRUE,2,"median",gvec)
sum(abs(y1-est1))
#
#the error between the true signal and the denoised version. 


</code></pre>


</div>