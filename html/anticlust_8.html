<div class="container">

<table style="width: 100%;"><tr>
<td>fast_anticlustering</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast anticlustering</h2>

<h3>Description</h3>

<p>Increasing the speed of (k-means / k-plus) anticlustering by (1) 
conducting fewer exchanges during the optimization and (2) using an alternative
formulation of the k-means objective. Makes anticlustering applicable to 
quite large data sets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fast_anticlustering(
  x,
  K,
  k_neighbours = Inf,
  categories = NULL,
  exchange_partners = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector, matrix or data.frame of data points.
Rows correspond to elements and columns correspond to
features. A vector represents a single numeric feature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>How many anticlusters should be created. Alternatively:
(a) A vector describing the size of each group, or (b) a vector
of length <code>nrow(x)</code> describing how elements are assigned
to anticlusters before the optimization starts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_neighbours</code></td>
<td>
<p>The number of nearest neighbours that serve as
exchange partner for each element. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>categories</code></td>
<td>
<p>A vector, data.frame or matrix representing one
or several categorical constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exchange_partners</code></td>
<td>
<p>Optional argument. A list of length
<code>NROW(x)</code> specifying for each element the indices of the
elements that serve as exchange partners. If used, this
argument overrides the <code>k_neighbours</code> argument. See
examples.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function was created to make anticlustering applicable to
large data sets (e.g., several 100,000 elements). It optimizes the
k-means objective because computing all pairwise distances as is
done when optimizing the "diversity" (i.e., the default in
<code>anticlustering</code>) is not feasible for very large data
sets (for about N &gt; 20000 on my personal computer). Using
<code>fast_anticlustering</code> for k-plus anticlustering is also
possible by applying <code>kplus_moment_variables</code> on the
input (and possibly by using the argument <code>exchange_partners</code>,
see Examples).
</p>
<p>The function <code>fast_anticlustering</code> employs a speed-optimized
exchange method, which is basically equivalent to <code>method =
"exchange"</code> in <code>anticlustering</code>, but may reduce the number
of exchanges that are investigated for each input element. The number of 
exchange partners per element has to be set using the argument <code>k_neighbours</code>. By
default, it is set to <code>Inf</code>, meaning that all possible swaps are
tested. If <code>k_neighbours</code> is set differently (which is usually recommended when running 
this function), the default behaviour is to generate exchange partners using a
nearest neighbour search (using the function <code>nn2</code>
from the <code>RANN</code> package). Using more exchange partners can improve the quality of
the results, but also increase run time. Note that for very large
data sets, anticlustering generally becomes "easier" (even a random
split may yield satisfactory results), so using few exchange
partners is usually not a problem. 
</p>
<p>It is possible to specify custom exchange partners using the
argument <code>exchange_partners</code> instead of relying on the default
nearest neighbour search.  When using <code>exchange_partners</code>, it
is not necessary that each element has the same number of exchange
partners; this is why the argument <code>exchange_partners</code> has to
be a <code>list</code> instead of a <code>matrix</code> or
<code>data.frame</code>. Exchange partners can for example be generated
by <code>generate_exchange_partners</code> (see Examples), but a
custom list may also be used. Note that categorical constraints
induced via <code>categories</code> may not be respected during the
optimization if the <code>exchange_partners</code> argument allows
exchanges between members of different categories, so care must be
taken when combining the arguments <code>exchange_partners</code> and
<code>categories</code>.
</p>
<p>In <code>anticlustering(..., objective = "variance")</code>, the run time
of computing the k-means objective is in O(M N), where N is the
total number of elements and M is the number of variables. This is
because the variance is computed as the sum of squared distances
between all data points and their cluster centers.  The function
<code>fast_anticlustering</code> uses a different - but equivalent -
formulation of the k-means objective, where the re-computation of
the objective only depends and M but no longer on N. In
particular, this variant of k-means anticlustering minimizes 
the weighted sum of squared distances between
cluster centroids and the overall data centroid; the distances
between all individual data points and their cluster center are not
computed (Späth, 1986). Using the different objective formulation 
reduces the run time by an
order of magnitude and makes k-means anticlustering applicable to
very large data sets (even in the millions). For a fixed number of
exchange partners (specified using the argument
<code>k_neighbours</code>), the approximate run time of
<code>fast_anticlustering</code> is in O(M N). The algorithm
<code>method = "exchange"</code> in <code>anticlustering</code> with
<code>objective = "variance"</code> has a run time of O(M N^3). 
Thus, <code>fast_anticlustering</code> can improve the run time
by two orders of magnitude as compared to the standard exchange
algorithm. The nearest neighbour search, which is done in the
beginning usually does not strongly contribute to the overall
run time. It is nevertheless possible to suppress the nearest
neighbour search by using the <code>exchange_partners</code> argument.
</p>
<p>When setting the <code>categories</code> argument, exchange partners
(i.e., nearest neighbours) will be generated from the same
category. Note that when <code>categories</code> has multiple columns,
each combination of these categories is treated as a distinct
category by the exchange method. You can also use
<code>categories_to_binary</code> to potentially improve results
for several categorical variables, instead of using the argument
<code>categories</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Papenberg <a href="mailto:martin.papenberg@hhu.de">martin.papenberg@hhu.de</a>
</p>


<h3>References</h3>

<p>Papenberg, M., &amp; Klau, G. W. (2021). Using anticlustering to partition 
data sets into equivalent parts. Psychological Methods, 26(2), 
161–174. https://doi.org/10.1037/met0000301.
</p>
<p>Papenberg, M. (2024). K-plus Anticlustering: An Improved k-means Criterion for 
Maximizing Between-Group Similarity. British Journal of Mathematical and 
Statistical Psychology, 77(1), 80–102. https://doi.org/10.1111/bmsp.12315
</p>
<p>Späth, H. (1986). Anticlustering: Maximizing the variance criterion.
Control and Cybernetics, 15, 213-218.
</p>


<h3>See Also</h3>

<p><code>anticlustering</code>
</p>
<p><code>kplus_moment_variables</code>
</p>
<p><code>categories_to_binary</code>
</p>
<p><code>variance_objective</code>
</p>
<p><code>generate_exchange_partners</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Use fewer or more exchange partners to adjust speed (vs. quality tradeoff)
features &lt;- iris[, - 5]
N &lt;- nrow(features)
init &lt;- sample(rep_len(1:3, N)) # same starting point for all calls:
groups1 &lt;- fast_anticlustering(features, K = init) # default: all exchanges
groups2 &lt;- fast_anticlustering(features, K = init, k_neighbours = 20) 
groups3 &lt;- fast_anticlustering(features, K = init, k_neighbours = 2)

variance_objective(features, groups1)
variance_objective(features, groups2)
variance_objective(features, groups3)

# K-plus anticlustering is straight forward when sticking with the default
# for k_neighbours
kplus_anticlusters &lt;- fast_anticlustering(
  kplus_moment_variables(features, T = 2), 
  K = 3
)
mean_sd_tab(features, kplus_anticlusters)

# Some care is needed when applying k-plus using with this function 
# while using a reduced number of exchange partners generated in the 
# nearest neighbour search. Then we:
# 1) Use kplus_moment_variables() on the numeric input
# 2) Generate custom exchange_partners because otherwise nearest 
#    neighbours are internally selected based on the extended k-plus 
#    variables returned by kplus_moment_variables() 
#    (which does not really make sense)
kplus_anticlusters &lt;- fast_anticlustering(
  kplus_moment_variables(features, T = 2), 
  K = 3,
  exchange_partners = generate_exchange_partners(120, features = features, method = "RANN")
 )
mean_sd_tab(features, kplus_anticlusters)
# Or we use random exchange partners: 
kplus_anticlusters &lt;- fast_anticlustering(
  kplus_moment_variables(features, T = 2), 
  K = 3,
  exchange_partners = generate_exchange_partners(120, N = nrow(features), method = "random")
)
mean_sd_tab(features, kplus_anticlusters)


# Working on several 1000 elements is very fast (Here n = 10000, m = 2)
data &lt;- matrix(rnorm(10000 * 2), ncol = 2)
start &lt;- Sys.time()
groups &lt;- fast_anticlustering(data, K = 5, k_neighbours = 5)
Sys.time() - start 

</code></pre>


</div>