<div class="container">

<table style="width: 100%;"><tr>
<td>aodml</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ML Estimation of Generalized Linear Models for Overdispersed Count Data</h2>

<h3>Description</h3>

<p>The function fits a beta-binomial (BB) or a negative binomial (NB) generalized linear model from clustered data. <br></p>
<p>For the BB model, data have the form {<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>}, where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of “successes”, and <code class="reqn">N</code> the number of clusters. The response is the proportion <code class="reqn">y = m/n.</code> 
</p>
<p>For the NB model, data can be of two types. When modeling simple counts, data have the form {<code class="reqn">m_1, m_2, ..., m_N</code>}, where <code class="reqn">m_i</code> is the number of occurences of the event under study. When modeling rates (e.g. hazard rates), data have the same form as for the BB model, where <code class="reqn">n_i</code> is the denominator of the rate for cluster <code class="reqn">i</code> (considered as an “offset”, i.e. a constant known value) and <code class="reqn">m_i</code> the number of occurences of the event. For both types of data, the response is the count <code class="reqn">y = m</code>. </p>


<h3>Usage</h3>

<pre><code class="language-R">  aodml(formula,
  data,
  family = c("bb", "nb"),
  link = c("logit", "cloglog", "probit"), 
	phi.formula = ~ 1,
  phi.scale = c("identity", "log", "inverse"),
  phi.start = NULL,
  fixpar = list(),
  hessian = TRUE,
  method = c("BFGS", "Nelder-Mead", "CG", "SANN"),
  control = list(maxit = 3000, trace = 0), ...)
  
  ## S3 method for class 'aodml'
print(x, ...)
  ## S3 method for class 'aodml'
summary(object, ...)
  ## S3 method for class 'aodml'
anova(object, ...)
  ## S3 method for class 'anova.aodml'
print(x, digits, ...)
  ## S3 method for class 'aodml'
fitted(object, ..., what = c("mu", "nu", "eta", "phi"))
  ## S3 method for class 'aodml'
residuals(object, ..., type = c("deviance", "pearson", "response"))
  ## S3 method for class 'aodml'
coef(object, ...)
  ## S3 method for class 'aodml'
df.residual(object, ...)
  ## S3 method for class 'aodml'
logLik(object, ...)
  ## S3 method for class 'aodml'
deviance(object, ...)
  ## S3 method for class 'aodml'
AIC(object, ..., k = 2)
  ## S3 method for class 'aodml'
vcov(object, ...)
  ## S3 method for class 'aodml'
predict(object, ..., type = c("link", "response"), se.fit = FALSE, newdata = NULL)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula for the mean <code class="reqn">\mu</code>, defining the parameter vector <code class="reqn">b</code> (see details).
</p>
<p>For the BB model, the left-hand side of the formula must be of the form 
</p>
<p><code>cbind(m, n - m) ~ ...</code>
</p>
<p>where the fitted proportion is <code>m/n</code>.
</p>
<p>For the NB model, the left-hand side of the formula must be of the form 
</p>
<p><code>m ~ ...</code>
</p>
<p>where the fitted count is <code>m</code>. To fit a rate, argument <code>offset</code> must be used in the right-hand side of the formula (see examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the response (<code>m</code> and, optionnally, <code>n</code>) and the explanatory variable(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Define the model which is fitted: “bb” for the BB model and “nb” for the NB model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>For the BB model only. Define the link function <code class="reqn">g</code> for the mean <code class="reqn">\mu</code>: “cloglog”, “logit” (default) or “probit”. For the NB model, <code>link</code> is automatically set to “log”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.formula</code></td>
<td>
<p>A right-hand side formula to model optional heterogeneity for the over-dispersion parameter <code class="reqn">\Phi</code> (see details). Only one single factor is allowed.
</p>
<p>Default to <code>formula(~ 1)</code> (i.e. no heterogeneity).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.scale</code></td>
<td>
<p>Scale on which <code class="reqn">\Phi</code> is estimated (see details): “identity” (default), “log” or “inverse”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi.start</code></td>
<td>
<p>Optional starting values for <code class="reqn">\Phi</code>. Default to 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixpar</code></td>
<td>
<p>An optional list of 2 vectors of same length (<code class="reqn">&gt;=1</code>) to set some parameters as constant in the model.
</p>
<p>The first vector indicates which parameters are set as constant (i.e., not optimized) in the global parameter vector <code class="reqn">(b, \Phi)</code>.
</p>
<p>The second vector indicates the corresponding values. For instance,
</p>
<p><code>fixpar = list(c(4, 5), c(0, 0.1))</code>
</p>
<p>means that the 4th and 5th components of vector <code class="reqn">(b, \Phi)</code> are set to 0 and 0.1. Argument <code>fixpar</code> can be usefull, for instance, to calculate profiled log-likehoods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>A logical (default to <code>TRUE</code>). If <code>FALSE</code>, the hessian and the variances-covariances matrices of the parameters are not calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Define the method used for the optimization (see <code>optim</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list to control the optimization parameters. See <code>optim</code>. By default, the maximum number of iterations is set to 3000, and trace is set to 0 to avoid spurious warnings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>aodml</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>aodml</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to print in print.summary.aodml and print.anova.aodml.
Default to <code>max(3, getOption("digits") - 3)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>optim</code> (e.g. argument <code>method</code> if using function <code>aodml</code>), or further objects of class <code>aodml</code> (function <code>anova.aodml</code>), or further arguments passed to <code>print.aodml</code> and <code>print.anova.aodml</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>For function <code>fitted</code>, a character string indicating the type of fitted values to be returned: legal values are “mu” for the fitted response; “nu” for the fitted linear predictor without offset (link scale); “eta” for the fitted linear predictor with offset (link scale); “phi” for the fitted overdispersion coefficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>For function <code>residuals</code>, a character string indicating the type of residuals to be computed; legal values are “deviance” for the deviance's residuals, “pearson” for the Pearson's residuals, and “response” for the response. For function <code>predict</code>, a character string indicating the type of prediction to be computed; legal values are “link” and “response”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Numeric scalar for the penalty parameter used to compute the information criterion. The default value (<code class="reqn">k = 2</code>) is the regular AIC = -2 * logLik + 2 * <code class="reqn">p</code>, where <code class="reqn">p</code> is the number of model coefficients. NB: for AICc, <code class="reqn">k</code> is set to 2, and AICc = AIC + 2 * <code class="reqn">p</code> * <code class="reqn">(p + 1)</code> / <code class="reqn">(n - p - 1)</code>, with <code class="reqn">n</code> the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>Logical scalar indicating whether standard errors should be computed for the predicted values. Default to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>A <code>data.frame</code> containing the explanatory variables - and possibly the offset - for the values of which predictions are to be made.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>Beta-binomial model (BB)</b><br></p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n ~ Binomial(n, \lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a Beta distribution <code class="reqn">Beta(a_1, a_2)</code>. Noting <code class="reqn">B</code> the beta function, the marginal (beta-binomial) distribution of <code class="reqn">m</code> is
</p>
<p style="text-align: center;"><code class="reqn">P(m | n) = C(n, m) * B(a_1 + m, a_2 + n - m) / B(a_1, a_2)</code>
</p>

<p>Using the re-parameterization <code class="reqn">\mu = a_1 / (a_1 + a_2)</code> and <code class="reqn">\Phi = 1 / (a_1 + a_2 + 1)</code>, the marginal mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = n * \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = n * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>
</p>

<p>The response in <code>aodml</code> is <code class="reqn">y = m/n</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = g^{-1}(X * b) =  g^{-1}(\nu)</code>, where <code class="reqn">g</code> is the link function, <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> a vector of fixed effects and <code class="reqn">\nu = X * b</code> is the corresponding linear predictor. The variance is <code class="reqn">Var[y] = (1 / n) * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>.<br></p>
<p><b>Negative binomial model (NB)</b><br></p>
<p><em>—— Simple counts (model with no offset)</em><br></p>
<p>For a given cluster <code class="reqn">(m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">y | \lambda ~ Poisson(\lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a Gamma distribution of mean <code class="reqn">\mu</code> and shape <code class="reqn">k</code> (<code class="reqn">Var[\lambda] = \mu^2 / k</code>). Noting <code class="reqn">G</code> the gamma function, the marginal (negative binomial) distribution of <code class="reqn">m</code> is
</p>
<p style="text-align: center;"><code class="reqn">P(m) = {G(m+k) / (m! * G(k))} * (k / (k + \mu))^k * (\mu / (k + \mu))^m</code>
</p>

<p>Using the re-parameterization <code class="reqn">\Phi = 1 / k</code>, the marginal mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = \mu + \Phi * \mu^2</code>
</p>

<p>The response in <code>aodml</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b) =  exp(\nu)</code>. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br></p>
<p><em>—— Rates (model with offset)</em><br></p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n ~ Poisson(\lambda)</code>
</p>

<p>The marginal (negative binomial) distribution <code class="reqn">P(m|n)</code> is the same as for the case with no offset (<code class="reqn">= P(m)</code>). The response in <code>aodml</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b + log(n)) =  exp(\nu + log(n)) = exp(\eta)</code>, where <code class="reqn">log(n)</code> is the offset. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br></p>
<p><b>Other details</b><br></p>
<p>Argument <code>phi.scale</code> of function <code>aodml</code> enables to estimate the over-dispersion parameter under different scales.
</p>
<p>If <code>phi.scale = "identity"</code> (Default), the function estimates <code class="reqn">\Phi</code>. 
</p>
<p>If <code>phi.scale = "log"</code>, the function estimates <code class="reqn">log(\Phi)</code>.
</p>
<p>If <code>phi.scale = "inverse"</code>, the function estimates <code class="reqn">1/\Phi</code>.<br></p>
<p>The full parameter vector returned by <code>aodml</code>, say <code>param</code>, is equal to <code class="reqn">(b, \Phi)</code>. This vector is estimated by maximizing the log-likelihood of the marginal model using function <code>optim</code>. The estimated variances-covariances matrix of <code>param</code> is calculated by the inverse of the observed hessian matrix returned by <code>optim</code>, and is referred to as <code>varparam</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>aodml</code>, printed and summarized by various functions. Function <code>deviance.aodml</code> returns the value <code>-2 * (logL - logL_max)</code>. The “deviance” used in function <code>AIC.aodml</code> to calculate AIC and AICc is <code>-2 * logL</code>.</p>


<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.<br>
Griffiths, D.A., 1973. <em>Maximum likelihood estimation for the beta-binomial distribution and an application
to the household distribution of the total number of cases of disease</em>. Biometrics 29, 637-648.<br>
Lawless, J.F., 1987. <em>Negative binomial and mixed Poisson regression</em>. The Canadian Journal of Statistics, 15(3): 209-225.<br>
McCullagh, P., Nelder, J. A., 1989, 2nd ed. <em>Generalized linear models</em>. New York, USA: Chapman and Hall.<br>
Prentice, R.L., 1986. <em>Binary regression using an extended beta-binomial distribution, with discussion of
correlation induced by covariate measurement errors</em>. J.A.S.A. 81, 321-327.<br>
Williams, D.A., 1975. <em>The analysis of binary responses from toxicological experiments involving
reproduction and teratogenicity</em>. Biometrics 31, 949-952.
</p>


<h3>See Also</h3>

<p><code>glm</code> and <code>optim</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
#------ Beta-binomial model

data(orob2)
fm1 &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb")

# summaries
fm1
summary(fm1)
coef(fm1)
vcov(fm1)
logLik(fm1)
deviance(fm1)
AIC(fm1)
gof(fm1)

# predictions
cbind(
  fitted(fm1),
  fitted(fm1, what = "nu"),
  fitted(fm1, what = "eta"),
  fitted(fm1, what = "phi")
)
predict(fm1, type = "response", se.fit = TRUE)
newdat &lt;- data.frame(seed = c("O73", "O75"))
predict(fm1, type = "response", se.fit = TRUE, newdata = newdat)

# model with heterogeneity in phi
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2,
  family = "bb", phi.formula = ~ seed)
summary(fm)
AIC(fm1, fm)

# various phi scales
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb")
fm$phi
fm$phi.scale
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb",
            phi.scale = "log")
fm$phi
fm$phi.scale
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb",
            phi.scale = "inverse")
fm$phi
fm$phi.scale

### Models with coefficient(s) set as constant

# model with 1 phi coefficient, set as constant "0.02"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
  family = "bb", fixpar = list(5, 0.02))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
  family = "bb", phi.formula = ~ seed, fixpar = list(5, 1e-15))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0",
# and the mu intercept (1rst coef of vector b) set as as constant "-0.5"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
            family = "bb", phi.formula = ~ seed,
            fixpar = list(c(1, 5), c(-0.5, 1e-15)))
fm$param
fm$varparam
  
### Model tests

# LR tests - non-constant phi
fm0 &lt;- aodml(cbind(m, n - m) ~ 1, data = orob2, family = "bb")
fm2 &lt;- aodml(cbind(m, n - m) ~ seed + root, data = orob2, family = "bb")
fm3 &lt;- aodml(cbind(m, n - m) ~ seed * root, data = orob2, family = "bb")
anova(fm0, fm1, fm2, fm3)

# LR tests - constant phi
# phi is assumed to be estimated from fm3
fm2.bis &lt;- aodml(cbind(m, n - m) ~ seed  + root, data = orob2,
                 family = "bb", fixpar = list(4, fm3$phi))
LRstat &lt;- 2 * (logLik(fm3) - logLik(fm2.bis))  
pchisq(LRstat, df = 1, lower.tail = FALSE)  
  
# Wald test of the seed factor in fm1
wald.test(b = coef(fm3), varb = vcov(fm3), Terms = 4)

#------ Negative binomial model

### Modelling counts

data(salmonella)
fm1 &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb")
## fm1 &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb",
##              method = "Nelder-Mead")

# summaries
fm1
summary(fm1)
coef(fm1)
vcov(fm1)
logLik(fm1)
deviance(fm1)
AIC(fm1)
gof(fm1)

# predictions
cbind(
  fitted(fm1),
  fitted(fm1, what = "nu"),
  fitted(fm1, what = "eta"),
  fitted(fm1, what = "phi")
)
predict(fm1, type = "response", se.fit = TRUE)
newdat &lt;- data.frame(dose = c(20, 40))
predict(fm1, type = "response", se.fit = TRUE, newdata = newdat)

# various phi scales
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb")
fm$phi
fm$phi.scale
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella,
            family = "nb", phi.scale = "log")
fm$phi
fm$phi.scale
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella,
            family = "nb", phi.scale = "inverse")
fm$phi
fm$phi.scale
  
# LR and Wald tests of the "log(dose + 10) + dose" factors
fm0 &lt;- aodml(m ~ 1, data = salmonella, family = "nb")
anova(fm0, fm1)
fm0.bis &lt;- aodml(m ~ 1, data = salmonella, family = "nb",
                 fixpar = list(2, fm1$phi))
LRstat &lt;- 2 * (logLik(fm1) - logLik(fm0.bis))  
pchisq(LRstat, df = 2, lower.tail = FALSE)  
wald.test(b = coef(fm1), varb = vcov(fm1), Terms = 2:3)

### Modelling a rate
  
data(dja)
# rate "m / trisk"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)),
            data = dja, family = "nb")
summary(fm)

fm &lt;- aodml(formula = m ~ group + offset(log(trisk)),
            phi.formula = ~ group, data = dja, family = "nb",
            phi.scale = "log")
summary(fm)
  
# model with 1 phi coefficient, set as constant "0.8"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
            family = "nb", phi.formula = ~1, fixpar = list(3, 0.8))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0" in the identity scale
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
            family = "nb", phi.formula = ~ group, phi.scale = "log",
            fixpar = list(4, -15))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant "0" in the identity scale,
# and the mu intercept coefficient (1rst coef of vector b) set as as constant "-0.5"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
  family = "nb", phi.formula = ~ group, phi.scale = "log",
  fixpar = list(c(1, 4), c(-0.5, -15)))
fm$param
fm$varparam
</code></pre>


</div>