<div class="container">

<table style="width: 100%;"><tr>
<td>rcomphierarc.summaries</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summary Statistics of a Portfolio</h2>

<h3>Description</h3>

<p>Methods for class <code>"portfolio"</code> objects.
</p>
<p><code>aggregate</code> splits portfolio data into subsets and computes
summary statistics for each.
</p>
<p><code>frequency</code> computes the frequency of claims for subsets of
portfolio data.
</p>
<p><code>severity</code> extracts the individual claim amounts.
</p>
<p><code>weights</code> extracts the matrix of weights.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'portfolio'
aggregate(x, by = names(x$nodes), FUN = sum,
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
frequency(x, by = names(x$nodes),
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
severity(x, by = head(names(x$node), -1), splitcol = NULL,
        classification = TRUE, prefix = NULL, ...)

## S3 method for class 'portfolio'
weights(object, classification = TRUE, prefix = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>an object of class <code>"portfolio"</code>, typically
created with <code>simul</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>character vector of grouping elements using the level names
of the portfolio in <code>x</code>. The names can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>the function to be applied to data subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classification</code></td>
<td>
<p>boolean; if <code>TRUE</code>, the node identifier
columns are included in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>characters to prefix column names with; if <code>NULL</code>,
sensible defaults are used when appropriate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitcol</code></td>
<td>
<p>columns of the data matrix to extract separately;
usual matrix indexing methods are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments to <code>FUN</code>, or passed to or from
other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, <code>aggregate.portfolio</code> computes the aggregate claim amounts
for the grouping specified in <code>by</code>. Any other statistic based on
the individual claim amounts can be used through argument <code>FUN</code>.
</p>
<p><code>frequency.portfolio</code> is equivalent to using <code>aggregate.portfolio</code>
with argument <code>FUN</code> equal to <code>if (identical(x, NA)) NA else
    length(x)</code>.
</p>
<p><code>severity.portfolio</code> extracts individual claim amounts of a portfolio
by groupings using the default method of <code>severity</code>.
Argument <code>splitcol</code> allows to get the individual claim amounts of
specific columns separately.
</p>
<p><code>weights.portfolio</code> extracts the weight matrix of a portfolio.
</p>


<h3>Value</h3>

<p>A matrix or vector depending on the groupings specified in <code>by</code>.
</p>
<p>For the <code>aggregate</code> and <code>frequency</code> methods: if at least one
level other than the last one is used for grouping, the result is a
matrix obtained by binding the appropriate node identifiers extracted
from <code>x$classification</code> if <code>classification = TRUE</code>, and the
summaries per grouping. If the last level is used for grouping, the
column names of <code>x$data</code> are retained; if the last level is not
used for grouping, the column name is replaced by the deparsed name of
<code>FUN</code>. If only the last level is used (column summaries), a named
vector is returned.
</p>
<p>For the <code>severity</code> method: a list of two elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p><code>NULL</code> or a matrix of claim amounts for the
columns not specified in <code>splitcol</code>, with the appropriate node
identifiers extracted from <code>x$classification</code> if
<code>classification = TRUE</code>;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>same as above, but for the columns specified in
<code>splitcol</code>.</p>
</td>
</tr>
</table>
<p>For the <code>weights</code> method: the weight matrix of the portfolio with
node identifiers if <code>classification = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>,
Louis-Philippe Pouliot.
</p>


<h3>See Also</h3>

<p><code>rcomphierarc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">nodes &lt;- list(sector = 3, unit = c(3, 4),
              employer = c(3, 4, 3, 4, 2, 3, 4), year = 5)
model.freq &lt;- expression(sector = rexp(1),
                         unit = rexp(sector),
                         employer = rgamma(unit, 1),
                         year = rpois(employer))
model.sev &lt;- expression(sector = rnorm(6, 0.1),
                        unit = rnorm(sector, 1),
                        employer = rnorm(unit, 1),
                        year = rlnorm(employer, 1))
pf &lt;- rcomphierarc(nodes, model.freq, model.sev)

aggregate(pf)            # aggregate claim amount by employer and year
aggregate(pf, classification = FALSE) # same, without node identifiers
aggregate(pf, by = "sector")	      # by sector
aggregate(pf, by = "y")		      # by year
aggregate(pf, by = c("s", "u"), mean) # average claim amount

frequency(pf)			      # number of claims
frequency(pf, prefix = "freq.")       # more explicit column names

severity(pf)			      # claim amounts by row
severity(pf, by = "year")	      # by column
severity(pf, by = c("s", "u"))        # by unit
severity(pf, splitcol = "year.5")     # last year separate
severity(pf, splitcol = 5)            # same
severity(pf, splitcol = c(FALSE, FALSE, FALSE, FALSE, TRUE)) # same

weights(pf)

## For portfolios with weights, the following computes loss ratios.
## Not run: aggregate(pf, classif = FALSE) / weights(pf, classif = FALSE)
</code></pre>


</div>