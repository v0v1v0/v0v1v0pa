<div class="container">

<table style="width: 100%;"><tr>
<td>derivePHMM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derive a profile hidden Markov model from sequences.</h2>

<h3>Description</h3>

<p><code>derivePHMM</code> generates a profile HMM from a given multiple sequence alignment
or a list of unaligned sequences.
</p>


<h3>Usage</h3>

<pre><code class="language-R">derivePHMM(x, ...)

## S3 method for class 'DNAbin'
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  threshold = 0.5,
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'AAbin'
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  threshold = 0.5,
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'list'
derivePHMM(
  x,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  threshold = 0.5,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## Default S3 method:
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  threshold = 0.5,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  cpp = TRUE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of aligned sequences or a list of unaligned sequences.
Accepted modes are "character" and "raw" (for "DNAbin" and "AAbin" objects).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>aditional arguments to be passed to <code>"Viterbi"</code> (if
<code>refine = "Viterbi"</code>) or <code>"forward"</code> (if
<code>refine = "BaumWelch"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seqweights</code></td>
<td>
<p>either NULL (all sequences are given weights
of 1), a numeric vector the same length as <code>x</code> representing
the sequence weights used to derive the model, or a character string giving
the method to derive the weights from the sequences
(see <code>weight</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wfactor</code></td>
<td>
<p>numeric. The factor to multiply the sequence weights by.
Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer representing the k-mer size to be used in tree-based
sequence weighting (if applicable). Defaults to 5. Note that higher
values of k may be slow to compute and use excessive memory due to
the large numbers of calculations required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
"RNA", "DNA", "AA", "AMINO". Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a "DNAbin" or "AAbin" object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix.
Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects. Defaults to "-"
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endchar</code></td>
<td>
<p>the character used to represent unknown residues in
the alignment matrix (if applicable). Ignored for <code>"DNAbin"</code> or
<code>"AAbin"</code> objects. Defaults to "?" otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudocounts</code></td>
<td>
<p>character string, either "background", Laplace"
or "none". Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the sequences.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the transition and emission counts.
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
generally recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities in the returned model should be logged. Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qa</code></td>
<td>
<p>an optional named 9-element vector of background transition
probabilities with <code>dimnames(qa) = c("DD", "DM", "DI", "MD", "MM",
"MI", "ID", "IM", "II")</code>, where M, I and D represent match, insert and
delete states, respectively. If <code>NULL</code>, background transition
probabilities are estimated from the sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qe</code></td>
<td>
<p>an optional named vector of background emission probabilities
the same length as the residue alphabet (i.e. 4 for nucleotides and 20
for amino acids) and with corresponding names (i.e. <code>c("A", "T",
"G", "C")</code> for DNA). If <code>qe = NULL</code>, background emission probabilities
are automatically derived from the sequences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMM. If NULL (default) no maximum size is enforced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inserts</code></td>
<td>
<p>character string giving the model construction method
by which alignment columns
are marked as either match or insert states. Accepted methods include
<code>"threshold"</code> (only columns with fewer than a specified
proportion of gaps form match states in the model), <code>"map"</code> (default;
match and insert columns are found using the maximum <em>a posteriori</em>
method outlined in Durbin et al (1998) chapter 5.7), <code>"inherited"</code>
(match and insert columns are inherited from the input alignment),
and <code>"none"</code> (all columns are assigned
match states in the model). Alternatively, insert columns can be
specified manually by providing a logical vector the same length
as the number of columns in the alignment, with <code>TRUE</code> for insert
columns and <code>FALSE</code> for match states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>the maximum proportion of gaps for an alignment column
to be considered for a match state in the PHMM (defaults to 0.5).
Only applicable when <code>inserts = "threshold"</code>.
Note that the maximum <em>a posteriori</em>
method works poorly for alignments with few sequences,
so the 'threshold' method is
automatically used when the number of sequences is less than 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>penalty parameter used to favour models with fewer match
states. Equivalent to the log of the prior probability of marking each
column (Durbin et al 1998, chapter 5.7). Only applicable when
<code>inserts = "map"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit.endgaps</code></td>
<td>
<p>logical. Should gap characters at each end of the
sequences be ignored when deriving the transition probabilities
of the model? Defaults to FALSE.
Set to TRUE if <code>x</code> is not a strict global alignment
(i.e. if the alignment contains partial sequences with missing
sections represented with gap characters).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>an optional character string. The name of the
new profile hidden Markov model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>an optional character string. The description of the
new profile hidden Markov model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compo</code></td>
<td>
<p>logical indicating whether the average emission
probabilities of the model modules should be returned with the
PHMM object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consensus</code></td>
<td>
<p>placeholder. Consensus sequences will be available in
a future version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alignment</code></td>
<td>
<p>logical indicating whether the alignment used to
derive the final model (if applicable) should be included as an element of
the returned PHMM object. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressive</code></td>
<td>
<p>logical indicating whether the alignment used
to derive the initial model parameters
should be built progressively (assuming input is a list of
unaligned sequences, ignored otherwise).
Defaults to FALSE, in which case the
longest sequence or sequences are used (faster,
but possibly less accurate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>optional integer vector indicating which sequences should
be used as seeds for building the guide tree for the progressive
alignment (assuming input is a list of unaligned sequences,
and <code>progressive = TRUE</code>, ignored otherwise).
Defaults to NULL, in which a set of log(n, 2)^2 non-identical
sequences are chosen from the list of sequences by k-means clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine</code></td>
<td>
<p>the method used to iteratively refine the model parameters
following the initial progressive alignment and model derivation step.
Current supported options are <code>"Viterbi"</code> (Viterbi training;
the default option), <code>"BaumWelch"</code> (a modified version of the
Expectation-Maximization algorithm), and "none" (skips the model
refinement step).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of EM iterations or Viterbi training
iterations to carry out before the cycling process is terminated and
the partially trained model is returned. Defaults to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltaLL</code></td>
<td>
<p>numeric, the maximum change in log likelihood between EM
iterations before the cycling procedure is terminated (signifying model
convergence). Defaults to 1E-07. Only applicable if
<code>method = "BaumWelch"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>integer giving the number of CPUs to parallelize the operation
over. Defaults to 1, and reverts to 1 if x is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be aligned, due to the extra time required to initialize
the cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs a similar operation to the  <code>hmmbuild</code>
function in the <a href="http://www.hmmer.org">HMMER</a> package.
If the primary input argument is an alignment, the function creates a
profile hidden Markov model (object class:<code>"PHMM"</code>) using the
method described in Durbin et al (1998) chapter 5.3. Alternatively, if
a list of non-aligned sequences is passed, the sequences are first aligned
using the <code>align</code> function before being used to derive the
model.
</p>
<p>The function outputs an object of class <code>"PHMM"</code>, which is a list
consisting of emission and transition probability matrices
(elements named "E" and "A"), vectors of non-position-specific
background emission and transition probabilities
("qe" and "qa", respectively) and other model metadata including
"name", "description", "size" (the number of modules in the model), and
"alphabet" (the set of symbols/residues emitted by the model).
</p>


<h3>Value</h3>

<p>an object of class <code>"PHMM"</code>
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code>deriveHMM</code>, <code>map</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Small globin alignment data from Durbin et al (1998) Figure 5.3
data(globins)
## derive a profile hidden Markov model from the alignment
globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
plot(globins.PHMM, main = "Profile HMM for small globin alignment")
##
## derive a profle HMM from the woodmouse dataset in the
## ape package and plot the first 5 modules
library(ape)
data(woodmouse)
woodmouse.PHMM &lt;- derivePHMM(woodmouse)
plot(woodmouse.PHMM, from = 0, to = 5, main = "Partial woodmouse profile HMM")
</code></pre>


</div>