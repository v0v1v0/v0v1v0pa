<div class="container">

<table style="width: 100%;"><tr>
<td>optFederov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimal design</h2>

<h3>Description</h3>

<p>Calculates an exact or approximate algorithmic design for one of three criteria, using Federov's exchange algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optFederov(frml,data,nTrials,center=FALSE,approximate=FALSE,criterion="D",
	evaluateI=FALSE,space=NULL,augment=FALSE,rows,nullify=0,
	maxIteration=100,nRepeats=5,DFrac=1,CFrac=1,args=FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>frml</code></td>
<td>
<p>This may be omitted if <code>data</code> is the fully model expanded candidate list.
If present it should be a formula starting with ~ which describes the model using
variable names from <code>data</code>. It may be ~. if all variables from <code>data</code> are to be used linearly.
In addition to the usual operators, quad(), cubic() and cubicS() may be used to 
expand variables from <code>data</code> into polynomial models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The candidate list. A matrix or data.frame describing the variables. If a matrix is input and 
the columns are not named, they will be assigned names X1,X2, etc. If a data.frame is input without 
column names, they will be named Var1, Var2, etc. Although data may be input as global variables used 
in frml, it is preferable to input it here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nTrials</code></td>
<td>
<p>If approximate=FALSE, it is the number of trials in the final design and if missing, it will be 
taken as the greater of <code>length(rows)</code> or 5 plus the number of terms in the model. If approximate=TRUE,
nTrials will be used to round the optimal proportions so that the replications of the points add to nTrials.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approximate</code></td>
<td>
<p>When FALSE, an exact design in nTrails will be calculated. When TRUE the proportions for
an approximate theory design will be calculated. If nTrials is set, any proportion less than 1/(2*maxIteration)
will be discarded before the proportions are efficiently rounded, otherwise all non-zero proportions will be 	 	 
shown: these are the support points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>When TRUE, the numeric variables will be centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>"D", "A", or "I"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluateI</code></td>
<td>
<p>TRUE to evaluate and report I in addition to
other criteria. This parameter is included, because evaluating
I requires extra effort.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>space</code></td>
<td>
<p>If the criterion is "I" or evaluate I is true, the space over which the I criterion is to
be evaluated may be input. It should be a matrix with the same column types and names as in data. If
space is not input the evaluation will be done over the space described by data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>augment</code></td>
<td>
<p>If TRUE, the row numbers in <code>rows</code> will never be exchanged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>Either a vector of row numbers (not row names) from <code>data</code> to be used as the
starting design or a vector of row numbers for the design to be augmented. Note, replicate
row numbers will be discarded and the length of rows cannot exceed the number of rows in data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullify</code></td>
<td>
<p>When non-zero, the initial design is obtained by nullification. If <code>nullify=1</code>,
<code>nTrials</code> will be calculated (In this case nRepeats is set to 1). If <code>nullify=2</code>, 
number-of-terms trials will be calculated, and the remainder, up to <code>nTrials</code>, will be filled 
out at random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIteration</code></td>
<td>
<p>maximum number of times points are exchanged, within each repeat, in seeking an optimum design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRepeats</code></td>
<td>
<p>Number of times the entire process is repeated. Has no effect when approximate=TRUE, 
or when nullify=1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DFrac</code></td>
<td>
<p>Design fraction: the fraction of design used in search: 1 uses all of
them, 0 uses only the one with the smallest variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CFrac</code></td>
<td>
<p>Candidate fraction: the fraction of candidate set searched : 1 uses all of
them, 0 uses only the one with the largest variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>If TRUE, the actual arguments to the function including the starting random number
seed will be output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">E(y)=Zb</code>, where <code class="reqn">y</code> is a vector of n observations, <code class="reqn">Z</code> is an <code class="reqn">n\times k</code> matrix, and <code class="reqn">b</code> is a vector of k parameters. The “exact” design problem is to find a matrix <code class="reqn">Z</code>, with rows selected from a <code class="reqn">N \times k</code> matrix <code class="reqn">X</code>, that is “best” in some sense. The matrix <code class="reqn">X</code> can be a discretization of a continuous space or it can represent categories. In either case, the algorithmic design calculation is with respect to <code class="reqn">X</code>, and not to some larger space containing the points.
</p>
<p>Approximate designs weight the candidate points with a probability measure, which for practical purposes amounts to allowing unequal replication. 
</p>
<p>The Federov(1972) algorithm starts with <code class="reqn">n</code> points chosen from <code class="reqn">X</code>. They may be chosen randomly or by nullification, a procedure which iteratively adds points from the null space of <code class="reqn">X</code>, until a non-singular <code class="reqn">n</code> point design is found. The Federov algorithm exchanges points in the <code class="reqn">n</code> point design <code class="reqn">Z</code> with points in <code class="reqn">X-Z</code>, i.e. points not in <code class="reqn">Z</code>, in order to optimize a criterion, and quits when no profitable exchanges are possible, or the input parameter <code>maxIteration</code> is reached. The quality of the result depends on the starting design and the result may represent a local optimum. The procedure is repeated <code>nRepeats</code> times in order to come nearer to a global optimum. The parameters <code>DFrac</code> and <code>CFrac</code> control the portions of <code class="reqn">Z</code> and <code class="reqn">X-Z</code> that are used.
</p>
<p>The goal of algorithmic design is to maximize the information about the parameters. The information matrix is a matrix proportional to <code class="reqn">M=Z'Z/n</code>, and various functions of <code class="reqn">M</code> are chosen for optimization. The most popular of these is the <code>D</code> criterion, <code class="reqn">|M|^{1/k}</code>, which is thus a scaling of the “generalized variance.” Other criteria of interest involve the variance of predicted values, such as the <code>G</code> criterion, which is the minimax value of <code class="reqn">d(x)=x'(Mi)x</code>, over <code class="reqn">X</code>, where <code class="reqn">Mi</code> is the inverse of <code class="reqn">M</code>, and <code class="reqn">x'</code> is a row of <code class="reqn">X</code>; and the <code>I</code> criterion, which is the average value of <code class="reqn">d(x)</code> in the experimental region. These criteria are invariant under linear transformations of the parameter vector, which frees them from a dependency on units of scale. Other criteria are not invariant, such as the largest eigenvalue of <code class="reqn">M</code> or the <code>A</code> criterion, which is <code class="reqn">trace(Mi)/k</code>: it is of course proportional to the average variance of the parameter estimates. The criteria <code>D</code>, <code>A</code>, and <code>I</code> are supported by <code>optFederov()</code>, and <code>G</code>, which is intimately connected to <code>D</code>, is reported.
</p>
<p>The theoretical optimum value of <code>G</code> is known for approximate theory designs, and so <code class="reqn">G_e</code>, the <code>G</code> efficiency of <code>G</code> is available as a standard of design quality. It is especially useful, because <code class="reqn">G_e</code> provides a lower bound on <code class="reqn">D_e</code>, the <code>D</code> efficiency for approximate theory, to wit: </p>
<p style="text-align: center;"><code class="reqn">D_e\ge exp(1-1/G_e)</code>
</p>
<p>.
</p>
<p>A vignette giving further details is availble. To access it, type
</p>
<p>vignette("AlgDesign")
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>The kth root of the generalized variance: <code class="reqn">det(M)^{1/k}</code>, where <code class="reqn">det(M)</code> is the
determinant of the normalized dispersion matrix <code class="reqn">M</code> –
i.e. <code class="reqn">M=Z'Z/n</code>, where <code class="reqn">Z=X[rows,]</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The average coefficient variance: <code class="reqn">trace(Mi)/k</code>, where <code class="reqn">Mi</code> is the inverse of <code class="reqn">M</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>The average prediction variance over X, which can be shown to be <code class="reqn">trace((X'X*Mi)/N)</code>, where
N is the number of rows in X. This is calculated only when I is the criterion or when <code>evaluateI</code> is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ge</code></td>
<td>
<p>The minimax normalized variance over X, expressed as an efficiency with respect to the optimal approximate
theory design. It is defined as <code class="reqn">k/max(d)</code>, where <code class="reqn">max(d)</code> is the maximum normalized
variance over <code class="reqn">X</code> – i.e. the max of <code class="reqn">x'(Mi)x</code>, over all rows <code class="reqn">x'</code>
of <code class="reqn">X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dea</code></td>
<td>
<p>A lower bound on <code>D</code> efficiency for approximate theory designs. It is equal to <code class="reqn">exp(1-1/Ge)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>The design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>A numerical vector of the design row numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>A list of the actual arguments used in this call.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Algorithmic design is often used with continuous and mixture variables for which R has minimal support, thus the functions quad(), cubic(), and cubicS() may be used in frml. The translation is done with expand.formula.
</p>
<p>Mixture variables are variables such that the rows of <code>data</code> sum to a constant value, usually unity. Because of the mixture constraint, models containing mixture variables should not have a constant term. The linear and quadratic models for mixture variables A, B, and C are given by <code class="reqn">-1+(A+B+C)</code> and <code class="reqn">-1+(A+B+C)^2</code> respectively. See Gorman and Hinman [1962] for 
details.
</p>
<p>The function gen.mixture() generates a list of candidate points whose rows sum to unity.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). optFederov. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Donev, A.N. (1992). <em>Optimum experimental
designs</em>. Clarendon Press, Oxford.
</p>
<p>Gorman, J.W. and Hinman, J.E. (1962). Simplex lattice designs for 
multicomponent systems. <em>Technometrics</em>. 4-4. 463-487.
</p>
<p>Federov, V.V. (1972). <em>Theory of optimal experiments</em>. Academic
Press, N.Y.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# EXAMPLE 1
# A quadratic polynomial in three variables. The resulting D will be about 0.46.
# This may be compared with a standard central composite design obtained from
# rows 1,3,5,7,9,11,13,15,17,19,21,23,25,27 of dat, which has a D value of 0.46.
# The central composite design seems to be the optimal design for all three criteria.

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C"))

desD&lt;-optFederov(~quad(A,B,C),dat,nTrials=14,eval=TRUE)
desA&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,crit="A")
desI&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,crit="I")

rows&lt;-c(1,3,5,7,9,11,13,15,17,19,21,23,25,27)
desO&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,rows=rows)

# The I criterion may be seen to decrease as the space is expanded. 

levels&lt;-seq(-1,1,by=.1)
dat&lt;-expand.grid(list(A=levels,B=levels,C=levels))

desL&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE)

# This is not the case for A or D. For A and D, the support points are the points 
# of the grid with the three levels above. Points not on this grid move
# the criteria in a non-optimal direction; hence, the enlarging space has no effect.

# EXAMPLES 2
# Standard designs are usually optimal designs. If nTrials is set to that for
# a standard design, and if nRepeats is large enough, the standard design will 
# often be found For example, a half replicate of a 2^4 will be obtained by the 
# following. 

dat&lt;-gen.factorial(levels=2,nVars=3,varNames=c("A","B","C"))
desH&lt;-optFederov(~.,dat,8)

# A third replicate of a 3^3 will be obtained by the following:

dat&lt;-gen.factorial(levels=3,nVars=3,factor=1:3)
desT&lt;-optFederov(~.,dat,9)

# An orthogonal design similar to a 12 run Plackett-Burman design can be 
# created by the following. 

dat&lt;-gen.factorial(levels=2,nVars=11,varNames=c("A","B","C","D","E","F","G","H","J","K","L"))
desPB&lt;-optFederov(~.,dat,12,nRepeats=20)

# The above calculation is numerically difficult for the A and I criteria, 
# and nRepeats=100 or more may be needed. 

# It is instructive to examine a case in which the standard design is not found.
# The following is an attempt to create a Latin square design. It is not always successful.

lv&lt;-factor(1:5)
dat&lt;-expand.grid(A=lv,B=lv,C=lv)
desL&lt;-optFederov(~.,dat,nTrials=25,nRep=100)

# It may be summarized as follows.

cs&lt;-xtabs(~.,desL$design)
{xx&lt;-matrix(0,5,5); for (i in 1:5) xx=xx+cs[1:5,1:5,i]*i;xx}
 


# EXAMPLE 3
# Mixture variables have a constant sum, usually 1. This causes a linear dependency
# among terms of polynomial models. In particular the constant term is dependent.
# Squared terms in a quadratic model are confounded with interaction terms, so that
# a quadratic model for three mixture variables is ~0+(A+B+C)^2. The following
# calculation generates a set of candidate varibles using gen.mixture() with
# four values on each axis, and then creates a 15 run design. The design is optimal.
# Indeed, the candidate set produced by gen.mixture(2,5) is optimal. Note: 
# nullify=TRUE is used to ensure that this example will run withough error. The
# default value of 5 for nRepeats is sometimes not enought to find a starting
# design with a mixture problem.


dat&lt;-gen.mixture(4,5)
desM&lt;-optFederov(~(X1+X2+X3+X4+X5)^2-1,dat,15,nullify=TRUE)

# EXAMPLES 4
# Design augmenation can be obtained by setting augment=TRUE, and placing the row numbers
# of the design to be agmented in rows. Augmentation is often used to (1) add a new variable
# to an existing design or (2) to increase the complexity of the model. The following illustrates
# adding a variable to an existing design using desD above. It is assumed that all runs of the
# existing design have been made at the -1 level of the new variable:

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C"))
desA&lt;-optFederov(~quad(.),dat,nTrials=25,augment=TRUE,rows=desD$rows)

# The half fraction in desH, can be augmented to support an additional term:

dat&lt;-gen.factorial(levels=2,nVars=4,varNames=c("A","B","C","D"))
desH&lt;-optFederov(~.,dat,8)
desH2&lt;-optFederov(~A+B+C+D+I(A*B),dat,10,aug=TRUE,rows=desH$rows)

# EXAMPLES 5
# Optimal approximate theory designs have non-zero probabilities only on support points.
# For the first example above the approximate theory design is as follows. It shows
# that all points in the cubic lattice are support points. The D for this 
# design is 0.474 which may be compared with the D of 0.463 of the first example to
# indicate that that exact design had a D-efficiency of 97%. The lower bound Dea
# was 82%.

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C")) 
desDA&lt;-optFederov(~quad(A,B,C),dat,eval=TRUE,approx=TRUE)

# The largest proportions will be rounded if nTrials is specified.

desDAN&lt;-optFederov(~quad(A,B,C),dat,eval=TRUE,approx=TRUE,nTrials=15)
</code></pre>


</div>