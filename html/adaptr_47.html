<div class="container">

<table style="width: 100%;"><tr>
<td>prog_breaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate breakpoints and other values for printing progress</h2>

<h3>Description</h3>

<p>Used internally. Generates breakpoints, messages, and 'batches' of trial
numbers to simulate when using <code>run_trials()</code> with the <code>progress</code> argument in
use. Breaks will be multiples of the number of <code>cores</code>, and repeated use of
the same values for breaks is avoided (if, e.g., the number of breaks times
the number of cores is not possible if few new trials are to be run). Inputs
are validated by <code>run_trials()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prog_breaks(progress, prev_n_rep, n_rep_new, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>single numeric <code style="white-space: pre;">⁠&gt; 0⁠</code> and <code style="white-space: pre;">⁠&lt;= 1⁠</code> or <code>NULL</code>. If <code>NULL</code>
(default), no progress is printed to the console. Otherwise, progress
messages are printed to the control at intervals proportional to the value
specified by progress.<br><strong>Note:</strong> as printing is not possible from within clusters on multiple
cores, the function conducts batches of simulations on multiple cores (if
specified), with intermittent printing of statuses. Thus, all cores have to
finish running their current assigned batches before the other cores may
proceed with the next batch. If there are substantial differences in the
simulation speeds across cores, using <code>progress</code> may thus increase total
run time (especially with small values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prev_n_rep</code></td>
<td>
<p>single integer, the previous number of simulations run (to
add to the indices generated and used).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_rep_new</code></td>
<td>
<p>single integers, number of new simulations to run (i.e.,
<code>n_rep</code> as supplied to <code>run_trials()</code> minus the number of previously run
simulations if <code>grow</code> is used in <code>run_trials()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p><code>NULL</code> or single integer. If <code>NULL</code>, a default value/cluster set
by <code>setup_cluster()</code> will be used to control whether simulations are run in
parallel on a default cluster or sequentially in the main process; if a
cluster/value has not been specified by <code>setup_cluster()</code>, <code>cores</code> will
then be set to the value stored in the global <code>"mc.cores"</code> option (if
previously set by <code style="white-space: pre;">⁠options(mc.cores = &lt;number of cores&gt;⁠</code>), and <code>1</code> if that
option has not been specified.<br>
If the resulting number of <code>cores = 1</code>, computations will be run
sequentially in the primary process, and if <code>cores &gt; 1</code>, a new parallel
cluster will be setup using the <code>parallel</code> library and removed once the
function completes. See <code>setup_cluster()</code> for details.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List containing <code>breaks</code> (the number of patients at each break),
<code>start_mess</code> and <code>prog_mess</code> (the basis of the first and subsequent
progress messages), and <code>batches</code> (a list with each entry corresponding to
the simulation numbers in each batch).
</p>


</div>