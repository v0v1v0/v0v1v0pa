<div class="container">

<table style="width: 100%;"><tr>
<td>MCMC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
(Adaptive) Metropolis Sampler
</h2>

<h3>Description</h3>

<p>Implementation of the robust adaptive Metropolis sampler of Vihola (2012).
</p>


<h3>Usage</h3>

<pre><code class="language-R">MCMC(p, n, init, scale = rep(1, length(init)),
    adapt = !is.null(acc.rate), acc.rate = NULL, gamma = 2/3,
    list = TRUE, showProgressBar=interactive(), n.start = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>function that returns a value proportional to the log probability
density to sample from. Alternatively it can be a function that returns a list
with at least one element named <code>log.density</code>. See details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>number of samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>vector with initial values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>vector with the variances <em>or</em> covariance matrix of the jump distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>

<p>if <code>TRUE</code>, adaptive sampling is used, if <code>FALSE</code> classic metropolis
sampling, if a positive integer the adaption stops after <code>adapt</code> iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc.rate</code></td>
<td>

<p>desired acceptance rate (ignored if <code>adapt=FALSE</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>controls the speed of adaption. Should be between 0.5 and 1. A lower
gamma leads to faster adaption.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list</code></td>
<td>

<p>logical. If <code>TRUE</code> a list is returned otherwise only a matrix with the samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showProgressBar</code></td>
<td>

<p>logical. If <code>TRUE</code> a progress bar is shown.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.start</code></td>
<td>

<p>iteration where the adaption starts. Only internally used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments passed to <code>p</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm tunes the covariance matrix of the (normal) jump
distribution to achieve the desired acceptance rate. Classic
(non-adaptive) Metropolis sampling can be obtained by setting <code>adapt=FALSE</code>.
</p>
<p>Note, due to the calculation for the adaption steps the sampler is
rather slow. However, with a suitable jump distribution good mixing can
be observed with less samples. This is crucial if
the computation of <code>p</code> is slow.
</p>
<p>In some cases the function <code>p</code> may not only calculate the log
density but return a list containing also other values. For example
if <code>p</code> is a log posterior one may be also interested to store
the corresponding prior and likelihood values. The function must
either return always a scalar or always a list, however, the length of
the list may vary.
</p>


<h3>Value</h3>

<p>If <code>list=FALSE</code> a matrix is with the samples.
</p>
<p>If <code>list=TRUE</code> a list is returned with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>matrix with samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.p</code></td>
<td>
<p>vector with the (unnormalized) log density for each sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sample</code></td>
<td>
<p>number of generated samples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.rate</code></td>
<td>
<p>acceptance rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaption</code></td>
<td>
<p>either logical if adaption was used or not, or the
number of adaption steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling.parameters</code></td>
<td>
<p>a list with further sampling
parameters. Mainly used by <code>MCMC.add.samples()</code></p>
</td>
</tr>
</table>
<p>.
</p>
<table><tr style="vertical-align: top;">
<td><code>extra.values</code></td>
<td>
<p>A list containing additional return values provided by
<code>p</code>. Only if <code>p</code> provides a list.</p>
</td>
</tr></table>
<h3>Note</h3>

<p>Due to numerical errors it may happen that the computed
covariance matrix is not positive definite. In such a case the nearest positive
definite matrix is calculated with <code>nearPD()</code>
from the package <span class="pkg">Matrix</span>.
</p>


<h3>Author(s)</h3>

<p>Andreas Scheidegger, <a href="mailto:andreas.scheidegger@eawag.ch">andreas.scheidegger@eawag.ch</a> or
<a href="mailto:scheidegger.a@gmail.com">scheidegger.a@gmail.com</a>.
</p>
<p>Thanks to David Pleydell, Venelin, and Umberto Picchini for spotting
errors and providing improvements. Ian Taylor implemented the usage of
<code>adapt_S</code> which lead to a nice speedup.
</p>


<h3>References</h3>

<p>Vihola, M. (2012) Robust adaptive Metropolis algorithm with coerced acceptance rate.
Statistics and Computing, 22(5), 997-1008. doi:10.1007/s11222-011-9269-5.
</p>


<h3>See Also</h3>

<p><code>MCMC.parallel</code>, <code>MCMC.add.samples</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ----------------------
## Banana shaped distribution

## log-pdf to sample from
p.log &lt;- function(x) {
  B &lt;- 0.03                              # controls 'bananacity'
  -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2
}


## ----------------------
## generate samples

## 1) non-adaptive sampling
samp.1 &lt;- MCMC(p.log, n=200, init=c(0, 1), scale=c(1, 0.1),
               adapt=FALSE)

## 2) adaptive sampling
samp.2 &lt;- MCMC(p.log, n=200, init=c(0, 1), scale=c(1, 0.1),
               adapt=TRUE, acc.rate=0.234)


## ----------------------
## summarize results

str(samp.2)
summary(samp.2$samples)

## covariance of last jump distribution
samp.2$cov.jump


## ----------------------
## plot density and samples

x1 &lt;- seq(-15, 15, length=80)
x2 &lt;- seq(-15, 15, length=80)
d.banana &lt;- matrix(apply(expand.grid(x1, x2), 1,  p.log), nrow=80)

par(mfrow=c(1,2))
image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="no adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.1$samples, type='b', pch=3)

image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="with adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.2$samples, type='b', pch=3)



## ----------------------
## function returning extra information in a list


p.log.list &lt;- function(x) {
  B &lt;- 0.03                              # controls 'bananacity'
  log.density &lt;- -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2

  result &lt;- list(log.density=log.density)

  ## under some conditions one may want to return other infos
  if(x[1]&lt;0) {
    result$message &lt;- "Attention x[1] is negative!"
    result$x &lt;- x[1]
  }

  result
}

samp.list &lt;- MCMC(p.log.list, n=200, init=c(0, 1), scale=c(1, 0.1),
                  adapt=TRUE, acc.rate=0.234)

## the additional values are stored under `extras.values`
head(samp.list$extras.values)

</code></pre>


</div>