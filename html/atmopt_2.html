<div class="container">

<table style="width: 100%;"><tr>
<td>atm.addpts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Add new data for ATM
</h2>

<h3>Description</h3>

<p><code>atm.addpts</code> adds new data into an ATM object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  atm.addpts(atm.obj,des.new,obs.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>atm.obj</code></td>
<td>
<p>Current ATM object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>des.new</code></td>
<td>
<p>Design matrix for new evaluations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.new</code></td>
<td>
<p>Observations for new evaluations.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">  ## Not run: 
####################################################
# Example 1: detpep10exp (9-D)
####################################################
nfact &lt;- 9 #number of factors
ntimes &lt;- floor(nfact/3) #number of "repeats" for detpep10exp
lev &lt;- 4 #number of levels
nlev &lt;- rep(lev,nfact) #number of levels for each factor
nelim &lt;- 3 #number of level eliminations
fn &lt;- function(xx){detpep10exp(xx,ntimes,nlev)} #objective to minimize (assumed expensive)

#initialize objects
# (predicts &amp; removes levels based on tuned ATM percentages)
fit.atm &lt;- atm.init(nfact,nlev)
#initialize sel.min object
# (predicts minimum using smallest observed value &amp; removes levels with largest minima)
fit.min &lt;- atm.init(nfact,nlev)

#Run for nelim eliminations:
res.atm &lt;- rep(NA,nelim) #for ATM results
res.min &lt;- rep(NA,nelim) #for sel.min results
for (i in 1:nelim){

  # ATM updates:
  new.des &lt;- atm.nextpts(fit.atm) #get design points
  new.obs &lt;- apply(new.des,1,fn) #sample function
  fit.atm &lt;- atm.addpts(fit.atm,new.des,new.obs) #add data to object
  fit.atm &lt;- atm.predict(fit.atm) #predict minimum setting
  idx.atm &lt;- fit.atm$idx.opt
  res.atm[i] &lt;- fn(idx.atm)
  fit.atm &lt;- atm.remlev(fit.atm) #removes worst performing level

  # sel.min updates:
  new.des &lt;- atm.nextpts(fit.min) #get design points
  new.obs &lt;- apply(new.des,1,fn) #sample function
  fit.min &lt;- atm.addpts(fit.min,new.des,new.obs) #add data to object
  fit.min &lt;- atm.predict(fit.min, alphas=rep(0,nfact)) #find setting with smallest observation
  idx.min &lt;- fit.min$idx.opt
  res.min[i] &lt;- fn(idx.min)
  #check: min(fit.min$obs.all)
  fit.min &lt;- atm.remlev(fit.min) #removes worst performing level

}

res.atm
res.min

#conclusion: ATM finds better solutions by learning &amp; exploiting additive structure

####################################################
# Example 2: camel6 (24-D)
####################################################
nfact &lt;- 24 #number of factors
ntimes &lt;- floor(nfact/2.0) #number of "repeats" for camel6
lev &lt;- 4
nlev &lt;- rep(lev,nfact) #number of levels for each factor
nelim &lt;- 3 #number of level eliminations
fn &lt;- function(xx){camel6(xx,ntimes,nlev)} #objective to minimize (assumed expensive)

#initialize objects
# (predicts &amp; removes levels based on tuned ATM percentages)
fit.atm &lt;- atm.init(nfact,nlev)
#initialize sel.min object
# (predicts minimum using smallest observed value &amp; removes levels with largest minima)
fit.min &lt;- atm.init(nfact,nlev)

#Run for nelim eliminations:
res.atm &lt;- rep(NA,nelim) #for ATM results
res.min &lt;- rep(NA,nelim) #for sel.min results
for (i in 1:nelim){

  # ATM updates:
  new.des &lt;- atm.nextpts(fit.atm) #get design points
  new.obs &lt;- apply(new.des,1,fn) #sample function
  fit.atm &lt;- atm.addpts(fit.atm,new.des,new.obs) #add data to object
  fit.atm &lt;- atm.predict(fit.atm) #predict minimum setting
  idx.atm &lt;- fit.atm$idx.opt
  res.atm[i] &lt;- fn(idx.atm)
  fit.atm &lt;- atm.remlev(fit.atm) #removes worst performing level

  # sel.min updates:
  new.des &lt;- atm.nextpts(fit.min) #get design points
  new.obs &lt;- apply(new.des,1,fn) #sample function
  fit.min &lt;- atm.addpts(fit.min,new.des,new.obs) #add data to object
  fit.min &lt;- atm.predict(fit.min, alphas=rep(0,nfact)) #find setting with smallest observation
  idx.min &lt;- fit.min$idx.opt
  res.min[i] &lt;- fn(idx.min)
  #check: min(fit.min$obs.all)
  fit.min &lt;- atm.remlev(fit.min) #removes worst performing level

}

res.atm
res.min

#conclusion: ATM finds better solutions by learning &amp; exploiting additive structure

## End(Not run)
</code></pre>


</div>