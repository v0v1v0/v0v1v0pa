<div class="container">

<table style="width: 100%;"><tr>
<td>hierarchy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Support for Item Hierarchies</h2>

<h3>Description</h3>

<p>Functions to use item hierarchies to aggregate items at different
group levels, to perform multi-level transaction analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">addAggregate(x, by, postfix = "*")

filterAggregate(x)

aggregate(x, ...)

## S4 method for signature 'itemMatrix'
aggregate(x, by)

## S4 method for signature 'itemsets'
aggregate(x, by)

## S4 method for signature 'rules'
aggregate(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an transactions, itemsets or rules object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>name of a field (hierarchy level) available in
itemInfo of <code>x</code> or a grouping vector of the same length
as items in <code>x</code> by which should be aggregated. Items with the same
group label in <code>by</code> will be aggregated into a single with that name.
Note that the grouping vector will be coerced to factor before use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postfix</code></td>
<td>
<p>characters added to mark group-level items.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Often an item hierarchy is available for transactions
used for association rule
mining. For example in a supermarket dataset items like "bread" and "beagle"
might belong to the item group (category) "baked goods."
</p>
<p>Transactions can store item hierarchies as additional columns in the
itemInfo data.frame (<code>"labels"</code> cannot be used since it is reserved for
the item labels).
</p>
<p><b>Aggregation:</b> To perform analysis at a group level of the item
hierarchy, <code>aggregate()</code> produces a new object with items aggregated to
a given group level. A group-level item is present if one or more of the
items in the group are present in the original object.  If rules are
aggregated, and the aggregation would lead to the same aggregated group item
in the lhs and in the rhs, then that group item is removed from the lhs.
Rules or itemsets, which are not unique after the aggregation, are also
removed. Note also that the quality measures are not applicable to the new
rules and thus are removed.  If these measures are required, then aggregate
the transactions before mining rules.
</p>
<p><b>Multi-level analysis:</b> To analyze relationships between individual
items and item groups at the same time, <code>addAggregate()</code> can be used to
create a new transactions object which contains both, the original items and
group-level items (marked with a given postfix). In association rule mining,
all items are handled the same, which means that we will produce a large
number of rules of the type:
</p>
<p><code style="white-space: pre;">⁠item A =&gt; group of item A⁠</code>
</p>
<p>with a confidence of 1. This will also happen if you mine itemsets.
<code>filterAggregate()</code> can be used to filter these spurious rules or
itemsets.
</p>


<h3>Value</h3>

<p><code>aggregate()</code> returns an object of the same class as <code>x</code>
encoded with a number of items equal to the number of unique values in
<code>by</code>. Note that for associations (itemsets and rules) the number of
associations in the returned set will most likely be reduced since several
associations might map to the same aggregated association and aggregate
returns a unique set. If several associations map to a single aggregated
association then the quality measures of one of the original associations is
randomly chosen.
</p>
<p><code>addAggregate()</code> returns a new transactions object with the original
items and the group-items added. <code>filterAggregateRules()</code> returns a new
rules object with the spurious rules remove.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other preprocessing: 
<code>discretize()</code>,
<code>itemCoding</code>,
<code>merge()</code>,
<code>sample()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code>abbreviate()</code>,
<code>c()</code>,
<code>crossTable()</code>,
<code>duplicated()</code>,
<code>extract</code>,
<code>image()</code>,
<code>inspect()</code>,
<code>is.superset()</code>,
<code>itemFrequency()</code>,
<code>itemFrequencyPlot()</code>,
<code>itemMatrix-class</code>,
<code>match()</code>,
<code>merge()</code>,
<code>random.transactions()</code>,
<code>sample()</code>,
<code>sets</code>,
<code>size()</code>,
<code>supportingTransactions()</code>,
<code>tidLists-class</code>,
<code>transactions-class</code>,
<code>unique()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Groceries")
Groceries

## Groceries contains a hierarchy stored in itemInfo
head(itemInfo(Groceries))

## Example 1: Aggregate items using an existing hierarchy stored in itemInfo.
## We aggregate to level2 stored in Groceries. All items with the same level2 label
## will become a single item with that name.
## Note that the number of items is therefore reduced to 55
Groceries_level2 &lt;- aggregate(Groceries, by = "level2")
Groceries_level2
head(itemInfo(Groceries_level2)) ## labels are alphabetically sorted!


## compare original and aggregated transactions
inspect(head(Groceries, 2))
inspect(head(Groceries_level2, 2))

## Example 2: Aggregate using a character vector.
## We create here labels manually to organize items by their first letter.
mylevels &lt;- toupper(substr(itemLabels(Groceries), 1, 1))
head(mylevels)

Groceries_alpha &lt;- aggregate(Groceries, by = mylevels)
Groceries_alpha
inspect(head(Groceries_alpha, 2))

## Example 3: Aggregate rules
## Note: You could also directly mine rules from aggregated transactions to
## get support, lift and support
rules &lt;- apriori(Groceries, parameter = list(supp = 0.005, conf = 0.5))
rules
inspect(rules[1])

rules_level2 &lt;- aggregate(rules, by = "level2")
inspect(rules_level2[1])

## Example 4: Mine multi-level rules.
## (1) Add aggregate items. These items will have labels ending with a *
Groceries_multilevel &lt;- addAggregate(Groceries, "level2")
summary(Groceries_multilevel)
inspect(head(Groceries_multilevel))

rules &lt;- apriori(Groceries_multilevel,
  parameter = list(support = 0.01, conf = .9))
inspect(head(rules, by = "lift"))
## Note that this contains many spurious rules of type 'item X =&gt; aggregate of item X'
## with a confidence of 1 and high lift. We can filter spurious rules resulting from
## the aggregation
rules &lt;- filterAggregate(rules)
inspect(head(rules, by = "lift"))
</code></pre>


</div>