<div class="container">

<table style="width: 100%;"><tr>
<td>keyword_merge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Merge keywords that supposed to have same meanings</h2>

<h3>Description</h3>

<p>Merge keywords that have common stem or lemma, and return the majority form of the word. This function
recieves a tidy table (data.frame) with document ID and keyword waiting to be merged.
</p>


<h3>Usage</h3>

<pre><code class="language-R">keyword_merge(
  dt,
  id = "id",
  keyword = "keyword",
  reduce_form = "lemma",
  lemmatize_dict = NULL,
  stem_lang = "porter"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A data.frame containing at least two columns with document ID and keyword.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Quoted characters specifying the column name of document ID.Default uses "id".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keyword</code></td>
<td>
<p>Quoted characters specifying the column name of keyword.Default uses "keyword".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce_form</code></td>
<td>
<p>Merge keywords with the same stem("stem") or lemma("lemma"). See details.
Default uses "lemma". Another advanced option is "partof". If a non-unigram (A) is part (subset) of
another non-unigram (B), then the longer one(B) would be replaced by the shorter one(A).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lemmatize_dict</code></td>
<td>
<p>A dictionary of base terms and lemmas to use for replacement.
Only used when the <b>lemmatize</b> parameter is <code>TRUE</code>.
The first column should be the full word form in lower case
while the second column is the corresponding replacement lemma.
Default uses <code>NULL</code>, this would apply the default dictionary used in
<code>lemmatize_strings</code> function. Applicable when <b>reduce_form</b> takes "lemma".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stem_lang</code></td>
<td>
<p>The name of a recognized language.
The list of supported languages could be found at <code>getStemLanguages</code>.
Applicable when <b>reduce_form</b> takes "stem".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>While <code>keyword_clean</code> has provided a robust way to lemmatize the keywords, the returned token
might not be the most common way to use.This function first gets the stem or lemma of
every keyword using <code>stem_strings</code> or <code>lemmatize_strings</code> from <span class="pkg">textstem</span> package,
then find the most frequent form (if more than 1,randomly select one)
for each stem or lemma. Last, every keyword
would be replaced by the most frequent keyword which share the same stem or lemma with it.
</p>
<p>When the 'reduce_form' is set to "partof", then for non-unigrams in the same document,
if one non-unigram is the subset of another, then they would be merged into the shorter one,
which is considered to be more general (e.g. "time series" and "time series analysis" would be
merged into "time series" if they co-occur in the same document). This could reduce the redundant
information. This is only applied to multi-word phrases, because using it for one word would
oversimplify the token and cause information loss (therefore, "time series" and "time" would not be
merged into "time"). This is an advanced option that should be used with caution (A trade-off between
information generalization and detailed information retention).
</p>


<h3>Value</h3>

<p>A tbl, namely a tidy table with document ID and merged keyword.
</p>


<h3>See Also</h3>

<p><code>stem_strings</code>, <code>lemmatize_strings</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(akc)


bibli_data_table %&gt;%
  keyword_clean(lemmatize = FALSE) %&gt;%
  keyword_merge(reduce_form = "stem")

bibli_data_table %&gt;%
  keyword_clean(lemmatize = FALSE) %&gt;%
  keyword_merge(reduce_form = "lemma")


</code></pre>


</div>