<div class="container">

<table style="width: 100%;"><tr>
<td>fit.pfc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a high-dimensional principal fitted components model 
using the method of Cook, Forzani, and Rothman (2012).
</h2>

<h3>Description</h3>

<p>Let <code class="reqn">(x_1, y_1), \ldots, (x_n, y_n)</code> denote the <code class="reqn">n</code> measurements of
the predictor and response, where <code class="reqn">x_i\in R^p</code> and <code class="reqn">y_i \in R</code>.
The model assumes that these measurements 
are a realization
of <code class="reqn">n</code> independent copies of 
the random vector <code class="reqn">(X,Y)'</code>, where
</p>
<p style="text-align: center;"><code class="reqn">
X = \mu_X + \Gamma \beta\{f(Y) - \mu_f\}+ \epsilon,
</code>
</p>

<p><code class="reqn">\mu_X\in R^p</code>; <code class="reqn">\Gamma\in R^{p\times d}</code> with rank <code class="reqn">d</code>; 
<code class="reqn">\beta \in R^{d\times r}</code> with rank <code class="reqn">d</code>; <code class="reqn">f: R \rightarrow R^r</code> is a known
vector valued function; <code class="reqn">\mu_f = E\{f(Y)\}</code>;  
<code class="reqn">\epsilon \sim N_p(0, \Delta)</code>; and <code class="reqn">Y</code> is independent of <code class="reqn">\epsilon</code>.
The central subspace is <code class="reqn">\Delta^{-1} {\rm span}(\Gamma)</code>.
</p>
<p>This function computes estimates of these model parameters
by imposing constraints for identifiability.
The mean parameters <code class="reqn">\mu_X</code> and <code class="reqn">\mu_f</code>
are estimated with <code class="reqn">\bar x = n^{-1}\sum_{i=1}^n x_i</code> and
<code class="reqn">\bar f = n^{-1} \sum_{i=1}^n f(y_i)</code>.
Let <code class="reqn">\widehat\Phi = n^{-1}\sum_{i=1}^{n} \{f(y_i) - \bar f\}\{f(y_i) - \bar f\}'</code>,
which we require to be positive definite.
Given a user-specified weight matrix <code class="reqn">\widehat W</code>, 
let
</p>
<p style="text-align: center;"><code class="reqn">
(\widehat\Gamma, \widehat\beta) = 
\arg\min_{G\in R^{p\times d}, B \in R^{d\times r}}  \sum_{i=1}^n [x_i - \bar x - GB\{f(y_i) - \bar f\}]'\widehat W [x_i - \bar x - GB\{f(y_i) - \bar f\}],
</code>
</p>
 
<p>subject to the constraints that <code class="reqn">G'\widehat W G</code> is diagonal and 
<code class="reqn">B \widehat\Phi B' = I</code>.  The sufficient reduction estimate <code class="reqn">\widehat R: R^p \rightarrow R^d</code>
is defined by
</p>
<p style="text-align: center;"><code class="reqn">
\widehat R(x) =  (\widehat\Gamma'\widehat W \widehat\Gamma)^{-1} \widehat\Gamma' \widehat W(x - \bar x).
</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">fit.pfc(X, y, r=4, d=NULL, F.user=NULL, weight.type=c("sample", "diag", "L1"), 
        lam.vec=NULL, kfold=5, silent=TRUE, qrtol=1e-10, cov.tol=1e-4, 
        cov.maxit=1e3, NPERM=1e3, level=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>The predictor matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns. The <code class="reqn">i</code>th row is <code class="reqn">x_i</code> defined above.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>The vector of measured responses with <code class="reqn">n</code> entries.  The <code class="reqn">i</code>th entry is <code class="reqn">y_i</code> defined above. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>When polynomial basis functions are used (which is the case when <code>F.user=NULL</code>), <code>r</code> is the polynomial 
order, i.e, 
<code class="reqn">f(y) = (y, y^2, \ldots, y^r)'</code>.  The default is <code>r=4</code>.  This argument is not used
when <code>F.user</code> is specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The dimension of the central subspace defined above.  This must be specified by the user
when <code>weight.type="L1"</code>.
If unspecified by the user this function will use the sequential permutation testing procedure, described in Section 8.2
of Cook, Forzani, and Rothman (2012), to select <code>d</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F.user</code></td>
<td>

<p>A matrix with <code class="reqn">n</code> rows and <code class="reqn">r</code> columns, where the <code class="reqn">i</code>th row is <code class="reqn">f(y_i)</code> defined above. 
This argument is optional, and will typically be used when polynomial basis functions are not desired.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.type</code></td>
<td>

<p>The type of weight matrix estimate <code class="reqn">\widehat W</code> to use.  
Let <code class="reqn">\widehat\Delta</code> be the observed residual sample covariance matrix for the multivariate
regression of <code>X</code> on <code class="reqn">f</code><code>(Y)</code> with <code class="reqn">n-r-1</code> scaling.
There are three options for <code class="reqn">\widehat W</code>: 
</p>

<ul>
<li> <p><code>weight.type="sample"</code> uses a Moore-Penrose generalized inverse of <code class="reqn">\widehat\Delta</code> for <code class="reqn">\widehat W</code>,
when <code class="reqn">p \leq n-r-1</code> this becomes the inverse of <code class="reqn">\widehat\Delta</code>;
</p>
</li>
<li> <p><code>weight.type="diag"</code> uses the inverse of the diagonal matrix with the same diagonal as <code class="reqn">\widehat\Delta</code>
for <code class="reqn">\widehat W</code>;
</p>
</li>
<li> <p><code>weight.type="L1"</code> uses the L1-penalized inverse of <code class="reqn">\widehat\Delta</code> described in equation (5.4) of Cook, Forzani,
and Rothman (2012).  In this case, <code>lam.vec</code> and <code>d</code> must be specified by the user.
The glasso algorithm of Friedman et al. (2008) is used through the R package <code>glasso</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam.vec</code></td>
<td>

<p>A vector of candidate tuning parameter values to use when <code>weight.type="L1"</code>.  If this vector has more than one entry,
then <code>kfold</code> cross validation will be performed to select the optimal tuning parameter value.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kfold</code></td>
<td>

<p>The number of folds to use in cross-validation to select the optimal tuning parameter when  <code>weight.type="L1"</code>.
Only used if <code>lam.vec</code> has more than one entry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>

<p>Logical. When <code>silent=FALSE</code>, progress updates are printed.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qrtol</code></td>
<td>

<p>The tolerance for calls to <code>qr.solve()</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.tol</code></td>
<td>

<p>The convergence tolerance for the QUIC algorithm used when <code>weight.type="L1"</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.maxit</code></td>
<td>

<p>The maximum number of iterations allowed for the QUIC algorithm used when <code>weight.type="L1"</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NPERM</code></td>
<td>

<p>The number of permutations to used in the sequential permutation testing procedure to select <code class="reqn">d</code>. 
Only used when <code>d</code> is unspecified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>

<p>The significance level to use to terminate the sequential permutation testing procedure to select <code class="reqn">d</code>. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See Cook, Forzani, and Rothman (2012) more information.
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Gamhat</code></td>
<td>
<p>this is <code class="reqn">\widehat\Gamma</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bhat</code></td>
<td>
<p>this is <code class="reqn">\widehat\beta</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rmat</code></td>
<td>
<p>this is <code class="reqn">\widehat W\widehat\Gamma(\widehat\Gamma'\widehat W \widehat\Gamma)^{-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>What</code></td>
<td>
<p>this is <code class="reqn">\widehat W</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>this is <code class="reqn">d</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>this is <code class="reqn">r</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GWG</code></td>
<td>
<p>this is <code class="reqn">\widehat\Gamma'\widehat W \widehat\Gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fc</code></td>
<td>
<p>a matrix with <code class="reqn">n</code> rows and <code class="reqn">r</code> columns where the <code class="reqn">i</code>th row is <code class="reqn">f(y_i) - \bar f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xc</code></td>
<td>
<p>a matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns where the <code class="reqn">i</code>th row is <code class="reqn">x_i - \bar x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the vector of <code class="reqn">n</code> response measurements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mx</code></td>
<td>
<p>this is <code class="reqn">\bar x</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mf</code></td>
<td>
<p>this is <code class="reqn">\bar f</code> described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.lam</code></td>
<td>
<p>this is selected tuning parameter value used when <code>weight.type="L1"</code>, will be <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam.vec</code></td>
<td>
<p>this is the vector of candidate tuning parameter values used when 
<code>weight.type="L1"</code>, will be <code>NULL</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.vec</code></td>
<td>
<p>this is the vector of validation errors from cross validation, one error for each entry in <code>lam.vec</code>.
Will be <code>NULL</code> unless <code>weight.type="L1"</code> and <code>lam.vec</code> has more than one entry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.info</code></td>
<td>
<p>a dataframe that summarizes the results from the sequential testing procedure.  Will be <code>NULL</code>
unless <code>d</code> is unspecified.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam J. Rothman
</p>


<h3>References</h3>

<p>Cook, R. D., Forzani, L., and Rothman, A. J. (2012).  
Estimating sufficient reductions of the predictors in abundant high-dimensional regressions. 
Annals of Statistics 40(1), 353-384.
</p>
<p>Friedman, J.,  Hastie, T., and Tibshirani R. (2008). 
Sparse inverse covariance estimation with the lasso. 
Biostatistics 9(3), 432-441.
</p>


<h3>See Also</h3>

<p><code>pred.response</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n=20
p=30
d=2
y=sqrt(12)*runif(n)
Gam=matrix(rnorm(p*d), nrow=p, ncol=d)
beta=diag(2)
E=matrix(0.5*rnorm(n*p), nrow=n, ncol=p)
V=matrix(c(1, sqrt(12), sqrt(12), 12.8), nrow=2, ncol=2)
tmp=eigen(V, symmetric=TRUE)
V.msqrt=tcrossprod(tmp$vec*rep(tmp$val^(-0.5), each=2), tmp$vec)
Fyc=cbind(y-sqrt(3),y^2-4)%*%V.msqrt
X=0+Fyc%*%t(beta)%*%t(Gam) + E

fit=fit.pfc(X=X, y=y, r=3, weight.type="sample")
## display hypothesis testing information for selecting d
fit$test.info
##  make a response versus fitted values plot
plot(pred.response(fit), y)
</code></pre>


</div>