<div class="container">

<table style="width: 100%;"><tr>
<td>async-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The async package.</h2>

<h3>Description</h3>

<p>The <code>async</code> package allows you to write sequential-looking code
that can pause, return control to R, then pick up where it left
off.  Async constructs include generators, async/await blocks, and
streams (experimental as of async 0.3).
</p>


<h3>Details</h3>

<p>A generator runs until it yields a value and then stops, returning
control to R until another value is requested. An async block can
pause and return control to R until some data is available, then
resume. Generators implement the iteror interface (which is
back-compatible with iterator
package.) Async blocks implement the promise
interface. The new stream construct implements the channel
interface, which is defined in this package.
</p>

<ul>
<li> <p><code>gen(...)</code> creates a generator (an iterator); within a generator use
<code>yield(x)</code> to return a value.
</p>
</li>
<li> <p><code>async(...)</code> creates an async block (a promise); within the <code>async</code>
write <code>await(x)</code> to pause on <code>x</code> (another promise).
</p>
</li>
<li> <p><code>stream(...)</code> creates a stream (an asynchronous iterator or
channel); in writing a <code>stream</code> you can use both <code>await</code> and <code>yield</code>.)
</p>
</li>
</ul>
<p>Theare are some global package options:
</p>
<p><code>async.verbose</code>: (default FALSE) if TRUE, coroutines will print an extremely
chatty play-by-play of what they are doing.
<code>async.compileLevel</code>: (0) Default compile level for new coroutines. See
description of levels under gen.
<code>async.paranoid</code>: (FALSE) If true, perform various time-consuming integrity
checks on the results of compilation. Meant to be enabled during certain
package tests.
<code>async.destructive</code>: (TRUE) If true, tear down interpreted coroutines
while building compiled replacements.
<code>async.sendLater</code>: (TRUE) If true, channels will send messages to listeners
in the event loop. If false, messages are sent immediately, which may be
faster but may have a higher risk of stack overflow, as well as expose
different sorts of bugs in your code.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://crowding.github.io/async/">https://crowding.github.io/async/</a>
</p>
</li>
<li> <p><a href="https://github.com/crowding/async/">https://github.com/crowding/async/</a>
</p>
</li>
<li>
<p> Report bugs at <a href="https://github.com/crowding/async/issues">https://github.com/crowding/async/issues</a>
</p>
</li>
</ul>
</div>