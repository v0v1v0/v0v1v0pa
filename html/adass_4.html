<div class="container">

<table style="width: 100%;"><tr>
<td>adass.fr_eaass</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evolutionary algorithm for the adaptive smoothing spline estimator (EAASS).</h2>

<h3>Description</h3>

<p>EAASS algorithm to choose the tuning parameters for the AdaSS estimator (Centofanti et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class="language-R">adass.fr_eaass(
  Y_fd,
  X_fd,
  basis_s,
  basis_t,
  beta_ders = NULL,
  beta_dert = NULL,
  grid_eval_ders = NULL,
  grid_eval_dert = NULL,
  rand_search_par = list(c(-4, 4), c(-4, 4), c(0, 1, 5, 10, 15), c(0, 1, 2, 3, 4), c(0,
    1, 5, 10, 15), c(0, 1, 2, 3, 4)),
  popul_size = 12,
  iter_num = 10,
  r = 0.2,
  pert_vec = c(0.8, 1.2),
  X_fd_test = NULL,
  Y_fd_test = NULL,
  progress = TRUE,
  ncores = 1,
  K = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y_fd</code></td>
<td>
<p>An object of class fd corresponding to the response functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_fd</code></td>
<td>
<p>An object of class fd corresponding to the covariate functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis_s</code></td>
<td>
<p>B-splines basis along the <code>s</code>-direction of class basisfd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis_t</code></td>
<td>
<p>B-splines basis along the <code>t</code>-direction of class basisfd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_ders</code></td>
<td>
<p>Initial estimate of the partial derivative of the coefficient function along the <code>s</code>-direction.
Either a matrix or a class basisfd object. If NULL no adaptive penalty is  used along the <code>s</code>-direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_dert</code></td>
<td>
<p>Initial estimate of the partial derivative of the coefficient function along the <code>t</code>-direction.
Either a matrix or a class basisfd object. If NULL no adaptive penalty is used along the <code>t</code>-direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_eval_ders</code></td>
<td>
<p>Grid of evaluation of the partial derivatives along the <code>s</code>-direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_eval_dert</code></td>
<td>
<p>Grid of evaluation of the partial derivatives along the <code>t</code>-direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand_search_par</code></td>
<td>
<p>List containing the initial population ranges for the tuning parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popul_size</code></td>
<td>
<p>Initial population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_num</code></td>
<td>
<p>Algorithm iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Truncation parameter in the exploitation phase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pert_vec</code></td>
<td>
<p>Perturbation parameters in the exploration phase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_fd_test</code></td>
<td>
<p>Test set covariate functions. Default is NULL.
If <code>X_fd_test</code> and <code>Y_fd_test</code> are both provided the prediction error on the test set is used as performance metric in place of the cross-validation prediction error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y_fd_test</code></td>
<td>
<p>Test set response functions. Default is NULL.
If <code>X_fd_test</code> and <code>Y_fd_test</code> are both provided the prediction error on the test set is used as performance metric in place of the cross-validation prediction error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>If TRUE a progress bar is printed. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>If <code>ncores</code>&gt;1, then parallel computing is used, with <code>ncores</code> cores. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of folds. Default is 10.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following arguments:
</p>

<ul>
<li> <p><code>tun_par_opt</code>: Vector of optimal tuning parameters.
</p>
</li>
<li> <p><code>CV</code>:  Estimated prediction errors.
</p>
</li>
<li> <p><code>CV_sd</code>:  Standard errors of the estimated prediction errors.
</p>
</li>
<li> <p><code>comb_list</code>: The combinations of tuning parameters explored.
</p>
</li>
<li> <p><code>Y_fd</code>: The response functions.
</p>
</li>
<li> <p><code>X_fd</code>: The covariate functions.
</p>
</li>
</ul>
<h3>References</h3>

<p>Centofanti, F., Lepore, A., Menafoglio, A., Palumbo, B., Vantini, S. (2023).
Adaptive Smoothing Spline Estimator for the Function-on-Function Linear Regression Model.
<em>Computational Statistics 38(1), 191â€“216</em>.
</p>


<h3>See Also</h3>

<p><code>adass.fr_eaass</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(adass)
data&lt;-simulate_data("Scenario HAT",n_obs=100)
X_fd=data$X_fd
Y_fd=data$Y_fd
basis_s &lt;- fda::create.bspline.basis(c(0,1),nbasis = 5,norder = 4)
basis_t &lt;- fda::create.bspline.basis(c(0,1),nbasis = 5,norder = 4)
mod_smooth &lt;-adass.fr(Y_fd,X_fd,basis_s = basis_s,basis_t = basis_t,tun_par=c(10^-6,10^-6,0,0,0,0))
grid_s&lt;-seq(0,1,length.out = 5)
grid_t&lt;-seq(0,1,length.out = 5)
beta_der_eval_s&lt;-fda::eval.bifd(grid_s,grid_t,mod_smooth$Beta_hat_fd,sLfdobj = 2)
beta_der_eval_t&lt;-fda::eval.bifd(grid_s,grid_t,mod_smooth$Beta_hat_fd,tLfdobj = 2)
mod_adsm&lt;-adass.fr_eaass(Y_fd,X_fd,basis_s,basis_t,
                        beta_ders=beta_der_eval_s, beta_dert=beta_der_eval_t,
                        rand_search_par=list(c(-8,4),c(-8,4),c(0,0.1),c(0,4),c(0,0.1),c(0,4)),
                        grid_eval_ders=grid_s, grid_eval_dert=grid_t,
                        popul_size = 1,ncores=1,iter_num=1)

</code></pre>


</div>