<div class="container">

<table style="width: 100%;"><tr>
<td>aceglm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Approximate Coordinate Exchange (ACE) Algorithm for Generalised Linear Models
</h2>

<h3>Description</h3>

<p>Functions implementing the approximate coordinate exchange (ACE) algorithm (Overstall &amp; Woods, 2017) for finding Bayesian optimal experimental designs for generalised linear models (GLMs).
</p>


<h3>Usage</h3>

<pre><code class="language-R">aceglm(formula, start.d, family, prior, B, 
criterion = c("D", "A", "E", "SIG", "NSEL", "SIG-Norm", "NSEL-Norm"),
method = c("quadrature", "MC"), Q = 20, N1 = 20, N2 = 100, lower = -1, 
upper = 1, progress = FALSE, limits = NULL)

paceglm(formula, start.d, family, prior, B, 
criterion = c("D", "A", "E", "SIG", "NSEL", "SIG-Norm", "NSEL-Norm"),
method = c("quadrature", "MC"), Q = 20, N1 = 20, N2 = 100, lower = -1, 
upper = 1, limits = NULL, mc.cores = 1, n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>An object of class <code>"formula"</code>: a symbolic description of the model. The terms should correspond to the column names of the argument <code>start.d</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>For <code>aceglm</code>, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for the ACE algorithm.
</p>
<p>For <code>paceglm</code>, a list with each element being an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for each repetition of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>A description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code>family</code> for details of family functions.)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>An argument specifying the prior distribution.  	
</p>
<p>For <code>method = "MC"</code>, a function with one argument: <code>B</code>; a scalar integer. This function should return a <code>B</code> by <code>p</code> matrix, with <code>p</code> the number of model parameters, containing a random sample from the prior distribution of the parameters. The value of <code>p</code> should correspond to the number of terms specified by the <code>formula</code> argument.
</p>
<p>For <code>method = "quadrature"</code>, a list specifying a normal or uniform prior for the model parameters. For a normal prior distribution, the list should have named entries <code>mu</code> and <code>sigma2</code> specifying the prior mean and variance-covariance matrix. The prior mean may be specified as a scalar, which will then be replicated to form an vector of common prior means, or a vector of length <code>p</code>. The prior variance-covariance matrix may be specified as either a scalar common variance or a vector of length <code>p</code> of variances (for independent prior distributions) or as a <code>p</code> by <code>p</code> matrix. For a uniform prior distribution, the list should have a named entry <code>support</code>, a <code>2</code> by <code>p</code> matrix with each column giving the lower and upper limits of the support of the independent continuous uniform distribution for the corresponding parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>An optional argument for controlling the approximation to the expected utility. It should be a vector of length two. 
</p>
<p>For <code>method = "MC"</code>, it specifies the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If left unspecified, the default value is <code>c(20000,1000)</code>.
</p>
<p>For <code>method = "quadrature"</code>, it specifies the tuning parameters (numbers of radial abscissas and random rotations) for the implemented quadrature method; see <b>Details</b> for more information. If left unspecified, the default value is <code>c(2, 8)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>An optional character argument specifying the utility function. There are currently seven utility functions implemented as follows:
</p>

<ol>
<li>
<p><b>pseudo-Bayesian D-optimality</b> (<code>criterion = "D"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian A-optimality</b> (<code>criterion = "A"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian E-optimality</b> (<code>criterion = "E"</code>).
</p>
</li>
<li>
<p><b>Shannon information gain</b> with Monte Carlo (MC) approximation to marginal likelihood (<code>criterion = "SIG"</code>);
</p>
</li>
<li>
<p><b>Shannon information gain</b> with normal-based Laplace approximation to marginal likelihood (<code>criterion = "SIG-Norm"</code>);
</p>
</li>
<li>
<p><b>negative squared error loss</b> with importance sampling approximation to posterior mean (<code>criterion = "NSEL"</code>);
</p>
</li>
<li>
<p><b>negative squared error loss</b> with normal-based approximation to posterior mean (<code>criterion = "NSEL-Norm"</code>);
</p>
</li>
</ol>
<p>If left unspecified, the default is <code>"D"</code> denoting pseudo-Bayesian D-optimality. See <b>Details</b> for more information. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>An optional character argument specifying the method of approximating the expected utility function. Current choices are <code>method = "quadrature"</code> for a deterministic quadrature approximation and <code>method = "MC"</code> for a stochastic Monte Carlo approximation. The first of these choices is <b>only</b> available when the argument <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code>. The second choice is available for all possible values of the argument <code>criterion</code>. If left unspecified, the argument defaults to <code>"quadrature"</code> for <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code> and to <code>"MC"</code> otherwise. See <b>Details</b> for more information. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number and other information detailing the progress of the algorithm should be printed. The default value is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code>mclapply</code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.assess</code></td>
<td>

<p>If <code>method = "MC"</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>aceglm</code> function implements the ACE algorithm to find designs for the class of generalised linear models (GLMs) for certain cases of utility function meaning the user does not have to write their own utility function.
</p>
<p>Two utility functions are implemented.
</p>

<ol>
<li>
<p><b>Shannon information gain (SIG)</b> 
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{SIG}(d) = \pi(\theta|y,d) - \pi(\theta),</code>
</p>

<p>where <code class="reqn">\pi(\theta|y,d)</code> and <code class="reqn">\pi(\theta)</code> denote the posterior and prior densities of the parameters <code class="reqn">\theta</code>, respectively.
</p>
</li>
<li>
<p><b>Negative squared error loss (NSEL)</b>
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{NSEL}(d) = - \left(\theta - E(\theta |y,d)\right)^T \left(\theta - E(\theta |y,d)\right),</code>
</p>

<p>where <code class="reqn">E(\theta | y,d)</code> denotes the posterior mean of <code class="reqn">\theta</code>.
</p>
</li>
</ol>
<p>In both cases the utility function is not available in closed form due to the analytical intractability of either the posterior distribution (for SIG) or the posterior mean (for NSEL). The <code>acebayes</code> package implements two approximations to both utility functions. If <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code> then sampling-based Monte Carlo or importance sampling approximations will be employed. This was the original approach used by Overstall &amp; Woods (2017). If <code>criterion = "SIG-Norm"</code> or <code>criterion = "NSEL-Norm"</code> then approximations based on approximate normality of the posterior (Overstall et al., 2017) will be used.
</p>
<p>The normal approximation to the posterior can be taken further leading to the approximation by some scalar function of the Fisher information matrix, <code class="reqn">\mathcal{I} (\theta;d)</code>, which only depends on <code class="reqn">\theta</code> (Chaloner &amp; Verdinelli, 1995). In the case of SIG, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^{D}(d) = \log \vert \mathcal{I} (\theta;d) \vert,</code>
</p>

<p>and the resulting design is typically called pseudo-Bayesian D-optimal. For NSEL, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^A(d) = - \mathrm{tr} \left\{ \mathcal{I} (\theta;d)^{-1} \right\} </code>
</p>

<p>with the resulting design termed pseudo-Bayesian A-optimal. These designs are often used under the frequentist approach to optimal experimental design and so to complete the usual set, the following utility for finding a pseudo-Bayesian E-optimal design is also implemented:
</p>
<p style="text-align: center;"><code class="reqn">u^E(d) = \mathrm{min} \mbox{ } e\left(\mathcal{I} (\theta;d) \right),</code>
</p>

<p>where <code class="reqn">e()</code> denotes the function that calculates the eigenvalues of its argument.
</p>
<p>The expected utilities can be approximated using Monte Carlo methods (<code>method = "MC"</code> for all criteria) or using a deterministic quadrature method (<code>method = "quadrature"</code>, implemented for the D, A and E criteria). The former approach approximates the expected utility via sampling from the prior. The latter approach uses a radial-spherical integration rule (Monahan and Genz, 1997) and <code>B[1]</code> specifies the number, <code class="reqn">n_r</code>, of radial abscissas and <code>B[2]</code> specifies the number,  <code class="reqn">n_q</code>, of random rotations. Larger values of  <code class="reqn">n_r</code> will produce more accurate, but also more computationally expensive, approximations. See Gotwalt et al. (2009) for further details.   
</p>
<p>Note that the utility functions for SIG and NSEL are currently only implemented for logistic regression, i.e. <code>family = binomial</code>, or Poisson regression, i.e. <code>family = poisson(link="log")</code>, whereas the utility functions for pseudo-Bayesian designs are implemented for generic GLM families.
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>paceglm</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>paceglm</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for <code>aceglm</code>) or <code>"pace"</code> (for <code>paceglm</code>)  which is a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>utility</code></td>
<td>

<p>The utility function resulting from the choice of arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlm</code></td>
<td>

<p>This will be <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>criterion</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>method</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>prior</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>family</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>formula</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>. Will be <code>FALSE</code> for the utility functions currently implemented.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The terminal design (<code>paceglm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval</code></td>
<td>

<p>If <code>deterministic = "MC"</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>paceglm</code> only).
</p>
<p>If <code>deterministic = "quadrature"</code>, a scalar giving the approximate expected utility for the terminal design (<code>paceglm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>paceglm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>paceglm</code> only).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>These are wrapper functions for <code>ace</code> and <code>pace</code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian experimental design: a review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C. M., Jones, B. A.  &amp; Steinberg, D. M. (2009). Fast computation of designs robust to parameter uncertainty for nonlinear settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The coordinate exchange algorithm for constructing exact
optimal experimental designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Monahan, J. and Genz, A. (1997). Spherical-radial integration rules for
Bayesian computation,” Journal of the American Statistical Association, 92, 664–674.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Overstall, A.M., McGree, J.M. &amp; Drovandi, C.C. (2018). An approach for finding fully Bayesian optimal designs using normal-based approximations to loss functions. <em>Statistics and Computing</em>, <b>28</b>(2), 343-358.
</p>


<h3>See Also</h3>

<p><code>ace</code>, <code>acenlm</code>, <code>pace</code>, <code>pacenlm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## This example uses aceglm to find a Bayesian D-optimal design for a 
## first order logistic regression model with 6 runs 4 factors. The priors are 
## those used by Overstall &amp; Woods (2017), with each of the five
## parameters having a uniform prior. The design space for each coordinate is [-1, 1].

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix(2 * randomLHS(n = n,k = 4) - 1,nrow = n,ncol = 4,
dimnames = list(as.character(1:n), c("x1", "x2", "x3", "x4")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

low&lt;-c(-3, 4, 5, -6, -2.5)
upp&lt;-c(3, 10, 11, 0, 3.5)
## Lower and upper limits of the uniform prior distributions.

prior&lt;-function(B){
t(t(6*matrix(runif(n = 5 * B),ncol = 5)) + low)}
## Create a function which specifies the prior. This function will return a 
## B by 5 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

example1&lt;-aceglm(formula=~x1+x2+x3+x4, start.d = start.d, family = binomial, 
prior = prior, method = "MC", N1 = 1, N2 = 0, B = c(1000, 1000))
## Call the aceglm function which implements the ACE algorithm requesting 
## only one iteration of Phase I and zero iterations of Phase II. The Monte
## Carlo sample size for the comparison procedure (B[1]) is set to 100.

example1
## Print out a short summary.

#Generalised Linear Model 
#Criterion = Bayesian D-optimality 
#Formula: ~x1 + x2 + x3 + x4
#
#Family: binomial 
#Link function: logit 
#
#Method:  MC 
#
#B:  1000 1000 
#
#Number of runs = 6
#
#Number of factors = 4
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 0
#
#Computer time = 00:00:01

example1$phase2.d
## Look at the final design.

#          x1          x2          x3         x4
#1 -0.4735783  0.12870470 -0.75064318  1.0000000
#2 -0.7546841  0.78864527  0.58689270  0.2946728
#3 -0.7463834  0.33548985 -0.93497463 -0.9573198
#4  0.4446617 -0.29735212  0.74040030  0.2182800
#5  0.8459424 -0.41734194 -0.07235575 -0.4823212
#6  0.6731941  0.05742842  1.00000000 -0.1742566

prior2 &lt;- list(support = rbind(low, upp))
## A list specifying the parameters of the uniform prior distribution

example2&lt;-aceglm(formula = ~ x1 +x2 + x3 + x4, start.d = start.d, family = binomial, 
prior = prior2, N1 = 1, N2 = 0)
## Call the aceglm function with the default method of "quadrature"

example2$phase2.d
## Final design

#          x1          x2          x3         x4
#1 -0.4647271  0.07880018 -0.94648750  1.0000000
#2 -0.7102715  0.79827332  0.59848578  0.5564422
#3 -0.7645090  0.39778176 -0.74342036 -1.0000000
#4  0.4514632 -0.33687477  0.55066110  0.3994593
#5  0.7913559 -0.41856994  0.01321035 -0.8848135
#6  0.6337306  0.11578522  1.00000000  1.0000000

mean(example1$utility(d = example1$phase2.d, B = 20000))
#[1] -11.61105
mean(example2$utility(d = example2$phase2.d, B = 20000))
#[1] -11.19737
## Compare the two designs using the Monte Carlo approximation
</code></pre>


</div>