<div class="container">

<table style="width: 100%;"><tr>
<td>network_swap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Perform one (or more) random swap
</h2>

<h3>Description</h3>

<p>Performs one (or more) random swap on the data and re-calculates network, returning both the new network and the data stream
</p>


<h3>Usage</h3>

<pre><code class="language-R">network_swap(association_data, data_format = "GBI", swaps = 1, 
	association_index = "SRI", association_matrix = NULL, 
	identities = NULL, which_identities = NULL, times = NULL, 
	occurrences = NULL, locations = NULL, which_locations = NULL, 
	start_time = NULL, end_time = NULL, classes = NULL, 
	which_classes = NULL, days = NULL, within_day = FALSE, 
	within_location = FALSE, within_class = FALSE, symmetric=TRUE,
	trialSwap=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>association_data</code></td>
<td>

<p>a <code>K x N</code> matrix of K groups (observations, gathering events, etc.) and N individuals (all individuals that are present in at least one group) OR a <code>K x N x N</code> array of sampling periods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_format</code></td>
<td>

<p><code>"GBI"</code> expect a group by individual matrix, <code>"SP"</code> Expect a sampling periods array
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swaps</code></td>
<td>

<p>number of swaps (default = 1000)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>association_index</code></td>
<td>

<p><code>"SRI"</code> Simple ratio index, <code>"HWI"</code> Half-weight index (more to come)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>association_matrix</code></td>
<td>

<p>provide a starting association matrix (see details)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identities</code></td>
<td>

<p>N vector of identifiers for each individual (column) in the group by individual matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_identities</code></td>
<td>

<p>vector of identities to include in the network (subset of identities)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>

<p>K vector of times defining the middle of each group/event
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>occurrences</code></td>
<td>

<p>N x S matrix with the occurrence of each individual in each sampling period (see details) containing only 0s and 1s
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locations</code></td>
<td>

<p>K vector of locations defining the location of each group/event
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_locations</code></td>
<td>

<p>vector of locations to include in the network (subset of locations)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_time</code></td>
<td>

<p>element describing the starting time for inclusion in the network (useful for temporal analysis)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_time</code></td>
<td>

<p>element describing the ending time for inclusion in the network (useful for temporal analysis)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>

<p>N vector of types or class of each individual (column) in the group by individual matrix (for subsetting)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_classes</code></td>
<td>

<p>vector of class(es)/type(s) to include in the network (subset of classes)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>days</code></td>
<td>

<p>K vector of day stamp for each event (can be integer or string representing any period of time)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within_day</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the time periods
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within_location</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given locations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within_class</code></td>
<td>

<p>if <code>TRUE</code> then permutations will be done within the given classes
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>

<p>Boolean to ensure that permutations maintain symmetry within sampling periods if using <code>data_format="SP"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trialSwap</code></td>
<td>

<p>Boolean to include trial swaps (if TRUE, then every attempted permutation is returned)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs one or more permutation swaps on the group by individual matrix as given by Whitehead (2008).  In order to save on memory use, this function computers the number of swaps and returns the association matrix and the data stream resulting from these, thus not needing to create a large stack of networks to store each permutation. This can then be implemented in a loop as shown in the example below. Note that this method is quite a bit slower than the network_permutation function.
</p>
<p>This implementation allows permutations (swaps) to be restricted to within any of three classes.  Though each class is labelled, the function is flexible.  Hence, days can represent any time period (months, hours, etc.). However, unlike the network_permutation, the subsetting of the data must be done outside of this function (for reasons that might be obvious) - see the example below.
</p>
<p>Trial swaps are implemented following Miklos and Podani (2004). Every permutation, a candidate swap is selected. If the selected portions of the data satisfy the baseline rules (e.g. the checkerboard pattern), then either the selection is attempted again <code>trialSwap = FALSE</code> or not <code>trialSwap = TRUE</code>. This should be set to TRUE, but the option for FALSE is provided for legacy analyses.
</p>


<h3>Value</h3>

<p>Returns a list containing an <code>N x N</code> matrix with the dyadic association rates of each pair of individuals after performing the swaps, and the <code>N x N</code> data stream post-swap, as two list elements.
</p>


<h3>Author(s)</h3>

<p>Damien R. Farine
</p>


<h3>References</h3>

<p>Whitehead (2008) <em>Analyzing Animal Societies</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# load data
data("group_by_individual")
data("times")

# subset GBI (to reduce run time of the example)
gbi &lt;- gbi[,1:80]

# calculate network for data based on morning associations
network &lt;- get_network(gbi, association_index="SRI", 
	times=times, start_time=0, end_time=max(times)/2)

# perform 100 permutations and calculate the coefficient
# of variance after each permutation.
# note that the subsetting is done outside of the function
library(raster)
cvs &lt;- rep(NA,100)
network_perm = list(network,gbi[which(times &lt;= max(times)/2),])
hours &lt;- floor(times/3600)[which(times &lt;= max(times)/2)]
for (i in 1:100) {
	network_perm &lt;- network_swap(network_perm[[2]], swaps=1, 
		association_matrix=network_perm[[1]], days=hours, 
		within_day=TRUE)
	cvs[i] &lt;- cv(network_perm[[1]])
}

# plot the results with the original network as a red dot
plot(cvs,pch=20,cex=0.5)
points(0,cv(network),cex=1,pch=20,col="red")

</code></pre>


</div>