<div class="container">

<table style="width: 100%;"><tr>
<td>extractX</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Extract Predictors from Candidate Model List
</h2>

<h3>Description</h3>

<p>This function extracts the predictors used in candidate models.  The
function is currently implemented for <code>glm</code>, <code>glmmTMB</code>,
<code>gls</code>, <code>lm</code>, <code>lme</code>, <code>merMod</code>,
<code>lmerModLmerTest</code>, <code>rlm</code>, <code>survreg</code> object classes that
are stored in a list as well as various models of <code>unmarkedFit</code>
classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">extractX(cand.set, ...)

## S3 method for class 'AICaov.lm'
extractX(cand.set, ...) 

## S3 method for class 'AICglm.lm'
extractX(cand.set, ...)

## S3 method for class 'AICglmmTMB'
extractX(cand.set, ...)

## S3 method for class 'AIClm'
extractX(cand.set, ...) 

## S3 method for class 'AICgls'
extractX(cand.set, ...) 

## S3 method for class 'AIClme'
extractX(cand.set, ...)

## S3 method for class 'AICglmerMod'
extractX(cand.set, ...)

## S3 method for class 'AIClmerMod'
extractX(cand.set, ...)

## S3 method for class 'AIClmerModLmerTest'
extractX(cand.set, ...)

## S3 method for class 'AICrlm.lm'
extractX(cand.set, ...) 

## S3 method for class 'AICsurvreg'
extractX(cand.set, ...) 

## S3 method for class 'AICunmarkedFitOccu'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
extractX(cand.set,
        parm.type = NULL, ...)  

## S3 method for class 'AICunmarkedFitOccuRN'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
extractX(cand.set,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitPCO'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
extractX(cand.set,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitGDS'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
extractX(cand.set,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
extractX(cand.set,
        parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
<p>this argument specifies the parameter type on which
the predictors will be extracted and is only relevant for models of
<code>unmarkedFit</code> classes.  The character strings supported
vary with the type of model fitted.  For <code>unmarkedFitOccu</code> and
<code>unmarkedFitOccuMulti</code> objects, either <code>psi</code> or
<code>detect</code> can be supplied to indicate whether the parameter is
on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> and <code>unmarkedFitOccuTTD</code>, possible
values  are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and detectability, respectively.  For
<code>unmarkedFitOccuFP</code> objects, one can specify <code>psi</code>,
<code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for occupancy,
detectability, probability of assigning false-positives, and
probability detections are certain, respectively.  For
<code>unmarkedFitOccuMS</code> objects, possible values are <code>psi</code>,
<code>phi</code>, or <code>detect</code>, denoting occupancy, transition, and
detection probabilities, respectively.  For <code>unmarkedFitOccuRN</code>
objects, either <code>lambda</code> or <code>detect</code> can be entered for
abundance and detectability parameters, respectively.  For
<code>unmarkedFitPCount</code> and <code>unmarkedFitMPois</code> objects,
<code>lambda</code> or <code>detect</code> denote parameters on abundance and
detectability, respectively.  For <code>unmarkedFitPCO</code>,
<code>unmarkedFitMMO</code>, and <code>unmarkedFitDSO</code> objects, one can
enter <code>lambda</code>, <code>gamma</code>, <code>omega</code>, <code>iota</code>, or
<code>detect</code>, to specify parameters on abundance, recruitment,
apparent survival, immigration, and detectability, respectively.
For <code>unmarkedFitDS</code> objects, <code>lambda</code> and <code>detect</code>
are supported.  For <code>unmarkedFitGDS</code>, <code>lambda</code>,
<code>phi</code>, and <code>detect</code> denote abundance, availability, and
detection probability, respectively.  For <code>unmarkedFitGMM</code> and
<code>unmarkedFitGPC</code> objects, <code>lambda</code>, <code>phi</code>, and
<code>detect</code> denote abundance, availability, and detectability,
respectively. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The candidate models must be stored in a list.  The results of
<code>extractX</code> are useful in preparing a <code>newdata</code>
data frame to use in computing model-averaged predictions with
<code>modavgPred</code> or differences between groups with
<code>modavgEffect</code> (Burnham and Anderson 2002, Anderson 2008, Burnham
et al. 2011).
</p>


<h3>Value</h3>

<p><code>extractX</code> returns an object of class <code>extractX</code> with the 
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>predictors</code></td>
<td>

<p>a character vector of the names of the predictors included in the
model, excluding the intercept term. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>a data frame or, in the case of <code>unmarkedFit</code> objects, a list of
data frames (e.g., obsCovs, siteCovs, yearlySiteCovs).
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.  
</p>
<p>Burnham, K. P., Anderson, D. R., Huyvaert, K. P. (2011) AIC model
selection and multimodel inference in behaviorial ecology: some
background, observations and comparisons. <em>Behavioral Ecology and 
Sociobiology</em> <b>65</b>, 23–25.
</p>
<p>Mazerolle, M. J. (2006) Improving data analysis in herpetology: using
Akaike's Information Criterion (AIC) to assess the strength of
biological hypotheses. <em>Amphibia-Reptilia</em> <b>27</b>, 169–180.
</p>
<p>Pinheiro, J. C., Bates, D. M. (2000). <em>Mixed-effects Models in S and
S-PLUS</em>. Springer Verlag: New York.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>


<h3>See Also</h3>

<p><code>extractCN</code>, <code>extractSE</code>,
<code>modavgPred</code>, <code>modavgCustom</code>,
<code>modavgEffect</code>, <code>predict</code>,
<code>predictSE</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##example from subset of models in Table 1 in Mazerolle (2006)
data(dry.frog)

Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                           cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                           cent_Initial_mass + Initial_mass2 +
                           Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                           Initial_mass2, data = dry.frog)
##assign names
names(Cand.models) &lt;- paste(1:length(Cand.models))

##extract predictors from candidate model set
orig.data &lt;- extractX(cand.set = Cand.models)
orig.data
str(orig.data)

## Not run: 
##model-averaged prediction with original variables
modavgPred(Cand.models, newdata = orig.data$data)

## End(Not run)


##example of model-averaged predictions from N-mixture model (e.g., Royle 2004)
##modified from ?pcount
##each variable appears twice on lambda in the models
## Not run: 
require(unmarked)    
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)
fm.mall.four &lt;- pcount(~ ivel + date  ~ 1, mallardUMF, K = 30)

##model list
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three, fm.mall.four)
names(Cands) &lt;- c("length + forest", "elev + forest", "length + elev",
                  "null")

##extract predictors on lambda
lam.dat &lt;- extractX(cand.set = Cands, parm.type = "lambda")
lam.dat
str(lam.dat)

##extract predictors on detectability
extractX(cand.set = Cands, parm.type = "detect")

##model-averaged predictions on lambda
##extract data
siteCovs &lt;- lam.dat$data$siteCovs
##create vector of forest values
forest &lt;- seq(min(siteCovs$forest),
              max(siteCovs$forest),
              length.out = 40)
dframe &lt;- data.frame(forest = forest,
                     length = mean(siteCovs$length),
                     elev = mean(siteCovs$elev))
modavgPred(Cands, parm.type = "lambda",
           newdata = dframe)
detach(package:unmarked)

## End(Not run)


##example of model-averaged abundance from distance model
## Not run: 
require(unmarked)
data(linetran) #example from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line",
                  unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and and detection.
fm2 &lt;- distsamp(~area + habitat ~ habitat, ltUMF)

## Hazard function. Covariates affecting both density and and detection.
fm3 &lt;- distsamp(~area + habitat ~ habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)

##model-average predictions on abundance
extractX(cand.set = Cands, parm.type = "lambda")
detach(package:unmarked)

## End(Not run)



##example using Orthodont data set from Pinheiro and Bates (2000)
## Not run: 
require(nlme)

##set up candidate models
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

m2 &lt;- gls(distance ~ 1, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

##assemble in list
Cand.models &lt;- list("age effect" = m1, "null model" = m2)

##model-averaged predictions
extractX(cand.set = Cand.models)
detach(package:nlme)

## End(Not run)
</code></pre>


</div>