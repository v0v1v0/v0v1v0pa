<div class="container">

<table style="width: 100%;"><tr>
<td>genlight-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Formal class "genlight"</h2>

<h3>Description</h3>

<p>The class <code>genlight</code> is a formal (S4) class for storing a genotypes
of binary SNPs in a compact way, using a bit-level coding scheme.
This storage is most efficient with haploid data, where the memory
taken to represent data can be reduced more than 50 times. However,
<code>genlight</code> can be used for any level of ploidy, and still remain an
efficient storage mode.
</p>
<p>A <code>genlight</code> object can be constructed from vectors of integers
giving the number of the second allele for each locus and each
individual (see 'Objects of the class genlight' below).
</p>
<p><code>genlight</code> stores multiple genotypes. Each genotype is stored
as a SNPbin object.
</p>


<h3>Details</h3>

<p>=== On the subsetting using <code>[</code> ===
</p>
<p>The function <code>[</code> accepts the following extra arguments:
</p>

<dl>
<dt>treatOther</dt>
<dd>
<p>a logical stating whether elements of the
<code>@other</code> slot should be treated as well (TRUE), or not
(FALSE). If treated, elements of the list are examined for a
possible match of length (vectors, lists) or number of rows
(matrices, data frames) with the number of individuals. Those who
match are subsetted accordingly. Others are left as is, issuing a
warning unless the argument <code>quiet</code> is set to TRUE.</p>
</dd>
<dt>quiet</dt>
<dd>
<p>a logical indicating whether warnings should be issued
when trying to subset components of the <code>@other</code> slot which
do not match the number of individuals (TRUE), or not (FALSE,
default). </p>
</dd>
<dt>...</dt>
<dd>
<p>further arguments passed to the genlight constructor.</p>
</dd>
</dl>
<h3>Objects from the class genlight</h3>

<p><code>genlight</code> objects can be created by calls to <code>new("genlight",
    ...)</code>, where '...' can be the following arguments:
</p>

<dl>
<dt><code>gen</code></dt>
<dd>
<p>input genotypes, where each genotype is coded as a
vector of numbers of the second allele. If a list, each slot of the
list correspond to an individual; if a matrix or a data.frame, rows
correspond to individuals and columns to SNPs. If individuals or
loci are named in the input, these names will we stored in the
produced object. All individuals are expected to have the same
number of SNPs. Shorter genotypes are completed with NAs, issuing a
warning.</p>
</dd>
<dt><code>ploidy</code></dt>
<dd>
<p>an optional vector of integers indicating the ploidy of the
genotypes. Genotypes can therefore have different ploidy. If not
provided, ploidy will be guessed from the data (as the
maximum number of second alleles in each individual).</p>
</dd>
<dt><code>ind.names</code></dt>
<dd>
<p>an optional vector of characters giving the labels
of the genotypes.</p>
</dd>
<dt><code>loc.names</code></dt>
<dd>
<p>an optional vector of characters giving the labels
of the SNPs.</p>
</dd>
<dt><code>loc.all</code></dt>
<dd>
<p>an optional vector of characters indicating
the alleles of each SNP; for each SNP, alleles must be coded by two
letters separated by '/', e.g. 'a/t' is valid, but 'a  t' or 'a |t'
are not.</p>
</dd>
<dt><code>chromosome</code></dt>
<dd>
<p>an optional factor indicating the
chromosome to which each SNP belongs.</p>
</dd>
<dt><code>position</code></dt>
<dd>
<p>an optional vector of integers indicating the
position of the SNPs.</p>
</dd>
<dt><code>other</code></dt>
<dd>
<p>an optional list storing miscellaneous information.</p>
</dd>
</dl>
<h3>Slots</h3>

<p>The following slots are the content of instances of the class
<code>genlight</code>; note that in most cases, it is better to retrieve
information via accessors (see below), rather than by accessing the
slots manually.
</p>

<dl>
<dt>
<code>gen</code>:</dt>
<dd>
<p>a list of genotypes stored as  SNPbin objects.</p>
</dd>
<dt>
<code>n.loc</code>:</dt>
<dd>
<p>an integer indicating the number of SNPs of the
genotype.</p>
</dd>
<dt>
<code>ind.names</code>:</dt>
<dd>
<p>a vector of characters indicating the names of
genotypes.</p>
</dd>
<dt>
<code>loc.names</code>:</dt>
<dd>
<p>a vector of characters indicating the names of
SNPs.</p>
</dd>
<dt>
<code>loc.all</code>:</dt>
<dd>
<p>a vector of characters indicating the alleles
of each SNP.</p>
</dd>
<dt>
<code>chromosome</code>:</dt>
<dd>
<p>an optional factor indicating the
chromosome to which each SNP belongs.</p>
</dd>
<dt>
<code>position</code>:</dt>
<dd>
<p>an optional vector of integers indicating the
position of the SNPs.</p>
</dd>
<dt>
<code>ploidy</code>:</dt>
<dd>
<p>a vector of integers indicating the ploidy of each individual.</p>
</dd>
<dt>
<code>pop</code>:</dt>
<dd>
<p>a factor indicating the population of each individual.</p>
</dd>
<dt>
<code>strata</code>:</dt>
<dd>
<p>a data frame containing different levels of population definition. (For methods, see <code>addStrata</code> and <code>setPop</code>)</p>
</dd>
<dt>
<code>hierarchy</code>:</dt>
<dd>
<p>a hierarchical <code>formula</code> defining the hierarchical levels in the <code>@@strata</code> slot.</p>
</dd>
<dt>
<code>other</code>:</dt>
<dd>
<p>a list containing other miscellaneous information.</p>
</dd>
</dl>
<h3>Methods</h3>

<p>Here is a list of methods available for <code>genlight</code> objects. Most of
these methods are accessors, that is, functions which are used to
retrieve the content of the object. Specific manpages can exist for
accessors with more than one argument. These are indicated by a '*'
symbol next to the method's name. This list also contains methods
for conversion from <code>genlight</code> to other classes.
</p>

<dl>
<dt>[</dt>
<dd>
<p><code>signature(x = "genlight")</code>: usual method to subset
objects in R. Is to be applied as if the object was a matrix where
genotypes were rows and SNPs were columns. Indexing can be done via
vectors of signed integers or of logicals. See details for extra
supported arguments.</p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(x = "genlight")</code>: printing of the
object.</p>
</dd>
<dt>$</dt>
<dd>
<p><code>signature(x = "genlight")</code>: similar to the @ operator;
used to access the content of slots of the object.</p>
</dd>
<dt>$&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: similar to the @ operator;
used to replace the content of slots of the object.</p>
</dd>
<dt>tab</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns a table of
allele counts (see <code>tab</code>; additional arguments are
<code>freq</code>, a logical stating if relative frequencies should be
returned (use for varying ploidy), and <code>NA.method</code>, a character
indicating if missing values should be replaced by the mean
frequency("mean"), or left as is ("asis").</p>
</dd>
<dt>nInd</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the number of
individuals in the object.</p>
</dd>
<dt>nPop</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the number of
populations in the object.</p>
</dd>
<dt>nLoc</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the number of
SNPs in the object.</p>
</dd>
<dt>dim</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the number of 
individuals and SNPs in the object, respectively.</p>
</dd>
<dt>names</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the names of
the slots of the object.</p>
</dd>
<dt>indNames</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the names of
the individuals, if provided when the object was constructed.</p>
</dd>
<dt>indNames&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the names of
the individuals using a character vector of length
<code>nInd(x)</code>.</p>
</dd>
<dt>popNames</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the names of
the populations, if provided when the object was constructed.</p>
</dd>
<dt>popNames&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the names of
the populations using a character vector of length
<code>nPop(x)</code>.</p>
</dd>
<dt>locNames</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the names of
the loci, if provided when the object was constructed.</p>
</dd>
<dt>locNames&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the names of
the SNPs using a character vector of length <code>nLoc(x)</code>.</p>
</dd>
<dt>ploidy</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the ploidy of
the genotypes.</p>
</dd>
<dt>ploidy&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the ploidy of
the individuals using a vector of integers of size <code>nInd(x)</code>;
if a single value is provided, the same ploidy is assumed for all
individuals.</p>
</dd>
<dt>NA.posi</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the indices
of missing values (NAs) as a list with one vector of integer for each individual.</p>
</dd>
<dt>alleles</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the names
of the alleles of each SNPs, if provided when the object was
constructed.</p>
</dd>
<dt>alleles&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the names
of the alleles of each SNPs using a character vector of length
<code>nLoc(x)</code>; for each SNP, two alleles must be provided,
separated by a "/", e.g. 'a/t', 'c/a', etc.</p>
</dd>
<dt>chromosome</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns a factor
indicating the chromosome of each SNPs, or NULL if the information
is missing.</p>
</dd>
<dt>chromosome&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the
chromosome to which SNPs belong using a factor of length
<code>nLoc(x)</code>.</p>
</dd>
<dt>chr</dt>
<dd>
<p><code>signature(x = "genlight")</code>: shortcut for
<code>chromosome</code>.</p>
</dd>
<dt>chr&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: shortcut for
<code>chromosome&lt;-</code>.</p>
</dd>
<dt>position</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns an integer
vector indicating the position of each SNPs, or NULL if the
information is missing.</p>
</dd>
<dt>position&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the
positions of the SNPs using an integer vector of length
<code>nLoc(x)</code>.</p>
</dd>
<dt>pop</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns a factor
indicating the population of each individual, if provided when the
object was constructed.</p>
</dd>
<dt>pop&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the population
of each individual using a factor of length <code>nInd(x)</code>.</p>
</dd>
<dt>other</dt>
<dd>
<p><code>signature(x = "genlight")</code>: returns the content of
the slot <code>@other</code>.</p>
</dd>
<dt>other&lt;-</dt>
<dd>
<p><code>signature(x = "genlight")</code>: sets the content of
the slot <code>@other</code>.</p>
</dd>
<dt>as.matrix</dt>
<dd>
<p><code>signature(x = "genlight")</code>: converts a
<code>genlight</code> object into a matrix of integers, with individuals
in rows and SNPs in columns. The S4 method 'as' can be used as
well (e.g. as(x, "matrix")).</p>
</dd>
<dt>as.data.frame</dt>
<dd>
<p><code>signature(x = "genlight")</code>: same as <code>as.matrix</code>.</p>
</dd>
<dt>as.list</dt>
<dd>
<p><code>signature(x = "genlight")</code>: converts a
<code>genlight</code> object into a list of genotypes coded as vector of
integers (numbers of second allele). The S4 method 'as' can be
used as well (e.g. as(x, "list")).</p>
</dd>
<dt>cbind</dt>
<dd>
<p><code>signature(x = "genlight")</code>: merges several
genlight objects by column, i.e. regroups data of
identical individuals genotyped for different SNPs.</p>
</dd>
<dt>rbind</dt>
<dd>
<p><code>signature(x = "genlight")</code>: merges several
genlight objects by row, i.e. regroups data of
different individuals genotyped for the same SNPs.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>)<br>
Zhian N. Kamvar (<a href="mailto:kamvarz@science.oregonstate.edu">kamvarz@science.oregonstate.edu</a>)</p>


<h3>See Also</h3>

<p>Related class:<br>
-  <code>SNPbin</code>, for storing individual genotypes of
binary SNPs<br></p>
<p>-  <code>genind</code>, for storing other types of genetic markers. <br></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## TOY EXAMPLE ##
## create and convert data
dat &lt;- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))
x &lt;- new("genlight", dat)
x

## examine the content of the object
names(x)
x@gen
x@gen[[1]]@snp # bit-level coding for first individual

## conversions
as.list(x)
as.matrix(x)

## round trips - must return TRUE
identical(x, new("genlight", as.list(x))) # list
identical(x, new("genlight", as.matrix(x))) # matrix
identical(x, new("genlight", as.data.frame(x))) # data.frame

## test subsetting
x[c(1,3)] # keep individuals 1 and 3
as.list(x[c(1,3)])
x[c(1,3), 1:2] # keep individuals 1 and 3, loci 1 and 2
as.list(x[c(1,3), 1:2])
x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)] # same, using logicals
as.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)])


## REAL-SIZE EXAMPLE ##
## 50 genotypes of 1,000,000 SNPs
dat &lt;- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))
names(dat) &lt;- paste("indiv", 1:length(dat))
print(object.size(dat), unit="aut") # size of the original data

x &lt;- new("genlight", dat) # conversion
x
print(object.size(x), unit="au") # size of the genlight object
object.size(dat)/object.size(x) # conversion efficiency



#### cbind, rbind ####
a &lt;- new("genlight", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))

ara &lt;- rbind(a,a)
ara
as.matrix(ara)

aca &lt;- cbind(a,a)
aca
as.matrix(aca)


#### subsetting @other ####
x &lt;- new("genlight", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))
x
other(x)
x[2:3]
other(x[2:3])
other(x[2:3, treatOther=FALSE])


#### seppop ####
pop(x) # no population info
pop(x) &lt;- c("pop1","pop1", "pop2") # set population memberships
pop(x)
seppop(x)

## End(Not run)
</code></pre>


</div>