<div class="container">

<table style="width: 100%;"><tr>
<td>mcsamp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function to Run ‘mcmcsamp()’ in lme4</h2>

<h3>Description</h3>

<p>The quick function for MCMC sampling for
lmer and glmer objects and convert to Bugs objects for easy display. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
mcsamp(object, n.chains=3, n.iter=1000, n.burnin=floor(n.iter/2), 
    n.thin=max(1, floor(n.chains * (n.iter - n.burnin)/1000)), 
    saveb=TRUE, deviance=TRUE, make.bugs.object=TRUE)
## S4 method for signature 'merMod'
 mcsamp(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>mer</code> objects from <code>lme4</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chains</code></td>
<td>
<p>number of MCMC chains</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>number of iteration for each MCMC chain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.burnin</code></td>
<td>
<p>number of burnin for each MCMC chain, 
Default is <code>n.iter/2</code>, that is, discarding the
first half of the simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.thin</code></td>
<td>
<p>keep every kth draw from each MCMC chain. Must be a positive integer. 
Default is <code>max(1, floor(n.chains * (n.iter-n.burnin) /
          1000))</code> which will only thin if there are at least 2000
simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveb</code></td>
<td>
<p>if 'TRUE', causes the values
of the random effects in each sample to be saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>compute deviance for <code>mer</code> objects. Only works 
for <code>lmer</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.bugs.object</code></td>
<td>
<p>tranform the output into bugs object, default is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates a sample from the posterior
distribution of the parameters of a fitted model using Markov
Chain Monte Carlo methods. It automatically simulates multiple 
sequences and allows convergence to be monitored. The function relies on
<code>mcmcsamp</code> in <code>lme4</code>.
</p>


<h3>Value</h3>

<p>An object of (S3) class '"bugs"' suitable for use with the
functions in the "R2WinBUGS" package. 
</p>


<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>; 
Yu-Sung Su <a href="mailto:ys463@columbia.edu">ys463@columbia.edu</a>
</p>


<h3>References</h3>

<p>Andrew Gelman and Jennifer Hill, 
Data Analysis Using Regression and Multilevel/Hierarchical Models, 
Cambridge University Press, 2006.
</p>
<p>Douglas Bates and Deepayan Sarkar,
lme4: Linear mixed-effects models using S4 classes.
</p>


<h3>See Also</h3>

<p><code>display</code>,
<code>lmer</code>,
<code>sim</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Here's a simple example of a model of the form, y = a + bx + error, 
## with 10 observations in each of 10 groups, and with both the intercept 
## and the slope varying by group.  First we set up the model and data.
##   
#   group &lt;- rep(1:10, rep(10,10))
#   group2 &lt;- rep(1:10, 10)
#   mu.a &lt;- 0
#   sigma.a &lt;- 2
#   mu.b &lt;- 3
#   sigma.b &lt;- 4
#   rho &lt;- 0.56
#   Sigma.ab &lt;- array (c(sigma.a^2, rho*sigma.a*sigma.b, 
#                    rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
#   sigma.y &lt;- 1
#   ab &lt;- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
#   a &lt;- ab[,1]
#   b &lt;- ab[,2]
#   d &lt;- rnorm(10)
#
#   x &lt;- rnorm (100)
#   y1 &lt;- rnorm (100, a[group] + b*x, sigma.y)
#   y2 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x))
#   y3 &lt;- rnorm (100, a[group] + b[group]*x + d[group2], sigma.y)
#   y4 &lt;- rbinom(100, 1, prob=invlogit(a[group] + b*x + d[group2]))
#
## 
## Then fit and display a simple varying-intercept model:
# 
#   M1 &lt;- lmer (y1 ~ x + (1|group))
#   display (M1)
#   M1.sim &lt;- mcsamp (M1)
#   print (M1.sim)
#   plot (M1.sim)
## 
## Then the full varying-intercept, varying-slope model:
## 
#   M2 &lt;- lmer (y1 ~ x + (1 + x |group))
#   display (M2)
#   M2.sim &lt;- mcsamp (M2)
#   print (M2.sim)
#   plot (M2.sim)
## 
## Then the full varying-intercept, logit model:
## 
#   M3 &lt;- lmer (y2 ~ x + (1|group), family=binomial(link="logit"))
#   display (M3)
#   M3.sim &lt;- mcsamp (M3)
#   print (M3.sim)
#   plot (M3.sim)
## 
## Then the full varying-intercept, varying-slope logit model:
## 
#   M4 &lt;- lmer (y2 ~ x + (1|group) + (0+x |group), 
#        family=binomial(link="logit"))
#   display (M4)
#   M4.sim &lt;- mcsamp (M4)
#   print (M4.sim)
#   plot (M4.sim)
#   
##
## Then non-nested varying-intercept, varying-slop model:
##
#   M5 &lt;- lmer (y3 ~ x + (1 + x |group) + (1|group2))
#   display(M5)
#   M5.sim &lt;- mcsamp (M5)
#   print (M5.sim)
#   plot (M5.sim)
      
 </code></pre>


</div>