<div class="container">

<table style="width: 100%;"><tr>
<td>listw.candidates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to create a list of spatial weighting matrices</h2>

<h3>Description</h3>

<p>This function is a user-friendly way to create a list of one or several spatial
weighting matrices (SWM) by selecting a set of predefined connectivity and
weighting matrices (B and A matrices, respectively).
</p>


<h3>Usage</h3>

<pre><code class="language-R">listw.candidates(
  coord,
  style = "B",
  nb = c("del", "gab", "rel", "mst", "pcnm", "dnear"),
  d1 = 0,
  d2,
  weights = c("binary", "flin", "fup", "fdown"),
  y_fdown = 5,
  y_fup = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coord</code></td>
<td>
<p>Vector, matrix, or dataframe of point coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p>Coding scheme style (see <code>nb2listw</code> of the <code>spdep</code>
package). Can take values 'W', 'B', 'C', 'U', 'minmax', and 'S'; default is
'B'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb</code></td>
<td>
<p>Defines how the B matrix (connectivity) is build:
</p>

<ul>
<li> <p><code>del</code> Delaunay triangulation
</p>
</li>
<li> <p><code>gab</code> Gabriel's graph
</p>
</li>
<li> <p><code>rel</code> Relative neighbourhood graph
</p>
</li>
<li> <p><code>mst</code> Minimum spanning tree
</p>
</li>
<li> <p><code>pcnm</code> Distance-based SWM based on the principal
coordinates of neighbour matrices (PCNM) criteria (see
'Details')
</p>
</li>
<li> <p><code>dnear</code> Distance-based
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d1</code></td>
<td>
<p>Only considered if <code>nb = "dnear"</code>. A single value defining the distance beyond which
two sites are connected (i.e., minimum distance between two neighbor sites). The default
value is 0 (no constraint on the min distance). <code>d1</code> must be smaller than <code>d2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2</code></td>
<td>
<p>Only considered if <code>nb = "dnear"</code>. It defines the connectivity
distance threshold below which two sites are connected (i.e., maximum distance between two
neighbors. It can either be a single value or a vector of values, in which case a
different SWM will be generated for each threshold value. The default value is the
minimum distance keeping all points connected (i.e., the largest edge of the minimum
spanning tree)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Defines how the A matrix (weighths) is build:
</p>

<ul>
<li> <p><code>binary</code> without weights
</p>
</li>
<li> <p><code>flin</code> Linear weighting function
</p>
</li>
<li> <p><code>fdown</code> Concave-down weighting function(see Details below)
</p>
</li>
<li> <p><code>fup</code> Concave-up weighting function (see Details below)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_fdown</code></td>
<td>
<p>Single value or vector of values of the <code>y</code> parameter
in the concave-down weighting function; default is 5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_fup</code></td>
<td>
<p>Single value or vector of values of the <code>y</code> parameter
in the concave-up weighting function; default is 0.5</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function allows constructing SWMs based on any combination
of B and A matrices. The B matrices are either graph-based or
distance-based. The function proposes the Delaunay triangulation, Gabriel
graph, relative neighbourhood graph, and the minimum spanning tree criteria
to build a graph-based B matrix. Distance-based SWMs can be built
with the principal coordinates of neighbour matrices (PCNM; Borcard and
Legendre 2002) criteria (see details below), or using another threshold
distance to define the connected site pairs. The A matrix can be based on a
binary, linear, concave-down, or concave-up function. The linear,
concave-down, and concave-up weighting functions are defined by <code class="reqn">1 -
  (D/dmax)</code>, <code class="reqn">1 - (D/dmax)^y</code>, and <code class="reqn">1 / D^y</code>, respectively, where
<code>D</code> is the euclidean distance between the two sites considered,
<code>dmax</code> is the maximum euclidean distance between two sites, and
<code>y</code> is a user-defined parametre that can either be a single value or a
vector of values. The choice <code>nb = "pcnm"</code> consists in constructing a
distance-based SWM based on the largest edge of the minimum spanning
tree as a connectivity distance threshold, and then by weighting the links
by the function <code class="reqn">1-(D/(4*t))^2</code>, where <code>D</code> is the euclidean
distance between the sites, and <code>t</code> is the distance threshold below
which two sites are considered connected (Dray et al. 2006). As optimizing
the choice of a SWM has to be done with a p-value correction depending
on the number of candidate SWMs tested (see function
<code>listw.select</code>), Bauman et al. (2018) strongly encouraged plotting the
concave-down and concave-up weighting functions with several parametre
values in order to only choose the realistic ones to build the candidate W
matrices (e.g., ranging between 0.1 and 1 for the concave-up function, as
values over 1 would make no ecological sense). First visualizing the
connectivity schemes with the <code>listw.explore</code> function may also help
choosing the B matrices to select for the <code>listw.candidates</code> function.
</p>
<p>Spatial eigenvectors can be generated from any candidate SWM obtained by
<code>listw.candidates</code> using <code>scores.listw</code>, or can be generated
and tested (recommended option for real data analysis) using
<code>mem.select</code>. If several SWMs were created, the selection of an
optimized SWM can be made using <code>listw.select</code>.
</p>


<h3>Value</h3>

<p>A list of SWMs. Each element of the list was built by
<code>nb2listw</code> (package <code>spdep</code>) and therefore is of class
<code>listw</code> and <code>nb</code>. The name of each element of the list (SWM)
is composed of the corresponding B and A matrices, followed (if any) by the
<code>y</code> parameter value of the weighting function.
</p>


<h3>Author(s)</h3>

<p>David Bauman (<a href="mailto:dbauman@ulb.ac.be">dbauman@ulb.ac.be</a> or <a href="mailto:davbauman@gmail.com">davbauman@gmail.com</a>) and Stéphane Dray
</p>


<h3>References</h3>

<p>Bauman D., Fortin M-J., Drouet T. and Dray S. (2018) Optimizing the choice of
a spatial weighting matrix in eigenvector-based methods. Ecology
</p>
<p>Borcard D. and Legendre P. (2002) All-scale spatial analysis of
ecological data by means of principal coordinates of neighbour matrices.
Ecological Modelling, 153, 51–68
</p>
<p>Dray S., Legendre P. and Peres-Neto P. R. (2006) Spatial modeling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecological Modelling, 196, 483–493
</p>


<h3>See Also</h3>

<p><code>listw.explore</code>, <code>scores.listw</code>, <code>mem.select</code>, <code>listw.select</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Create 100 random sampling locations in a squared grid of 120 x 120:
xy &lt;- matrix(nrow = 100, ncol = 2)
xy[, 1] &lt;- sample(c(1:120), 100, replace = FALSE)
xy[, 2] &lt;- sample(c(1:120), 100, replace = FALSE)
### The function listw.candidates is used to build the spatial weighting matrices that
### we want to test and compare (with the listw.select function). We test a Gabriel's graph, 
### a minimum spanning tree, and a distance-based connectivity defined by a threshold
### distance corresponding to the smallest distance keeping all sites connected (i.e., 
### the defaut value of d2). These connectivity matrices are then either not weighted 
### (binary weighting), or weighted by the linearly decreasing function:
candidates &lt;- listw.candidates(coord = xy, nb = c("gab", "mst", "dnear"), 
                               weights = c("binary", "flin"))
names(candidates)                              
plot(candidates[[1]], xy)
plot(candidates[[3]], xy)
### Construction of a different list of spatial weighting matrices. This time, the
### connexions are defined by a distance-based criterion based on the same threshold
### value, but the connections are weighted by the concave-down function with a y parameter
### varying between 2 and 5, and a concave-up function with a y parametre of 0.2.
candidates2 &lt;- listw.candidates(coord = xy, nb = "dnear", weights = c("fdown", "fup"),
                                y_fdown = 1:5, y_fup = 0.2)
### Number of spatial weighting matrices generated:
length(candidates2) 
### A single SWM can also easily be generated with listw.candidates:
lw &lt;- listw.candidates(xy, nb = "gab", weights = "bin")
plot(lw[[1]], xy)

### Generating MEM variables from an object of listw.candidates with scores.listw:
MEM &lt;- scores.listw(lw[[1]])
### See functions mem.select and listw.select for examples of how to use an object
### created by listw.candidates with these functions.


</code></pre>


</div>