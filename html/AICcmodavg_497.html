<div class="container">

<table style="width: 100%;"><tr>
<td>modavgCustom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model-averaged Parameter Estimate from User-supplied Input Based
on (Q)AIC(c)
</h2>

<h3>Description</h3>

<p>This function model-averages the estimate of a parameter of interest
among a set of candidate models, and computes the unconditional standard
error and unconditional confidence intervals as described in Buckland et
al. (1997) and Burnham and Anderson (2002). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">modavgCustom(logL, K, modnames = NULL, estimate, se, second.ord = TRUE,
             nobs = NULL, uncond.se = "revised", conf.level = 0.95,
             c.hat = 1, useBIC = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>logL</code></td>
<td>

<p>a vector of log-likelihood values for the models in the candidate
model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>a vector containing the number of estimated parameters for each
model in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table.  If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>

<p>a vector of estimates for each of the models in the candidate model
set.  Estimates can be either beta estimates for a parameter of
interest or a single prediction from each model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>

<p>a vector of standard errors for each of the estimates appearing in the
<code>estimate</code> vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).  This argument is ignored if
<code>useBIC = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>the sample size required to compute the AICc, QAICc, BIC, or QBIC.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>

<p>either, <code>"old"</code>, or <code>"revised"</code>, specifying the equation
used to compute the unconditional standard error of a model-averaged
estimate.  With <code>uncond.se = "old"</code>, computations are based on
equation 4.9 of Burnham and Anderson (2002), which was the former way
to compute unconditional standard errors.  With <code>uncond.se =
  "revised"</code>, equation 6.12 of Burnham and Anderson (2002) is used.
Anderson (2008, p. 111) recommends use of the revised version for the
computation of unconditional standard errors and it is now the
default.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011), or capture-mark-recapture models (e.g., Lebreton et al. 1992).
If <code>c.hat</code> &gt; 1, <code>modavgCustom</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useBIC</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the Bayesian information
criterion (BIC) when <code>c.hat = 1</code> or the quasi-likelihood BIC (QBIC)
when <code>c.hat &gt; 1</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>modavgCustom</code> computes a model-averaged estimate from the vector
of parameter estimates specified in <code>estimate</code>.  Estimates and
their associated standard errors must be specified in the same order as
the log-likelihood, number of estimated parameters, and model names.
Estimates provided may be for a parameter of interest (i.e., beta
estimates) or predictions from each model.  This function is most useful
when model input is imported into R from other software (e.g., Program
MARK, PRESENCE) or for model classes that are not yet supported by the
other model averaging functions such as <code>modavg</code> or
<code>modavgPred</code>.
</p>


<h3>Value</h3>

<p><code>modavgCustom</code> creates an object of class <code>modavgCustom</code> with
the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Mod.avg.table</code></td>
<td>
<p>the model selection table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mod.avg.est</code></td>
<td>
<p>the model-averaged estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Uncond.SE</code></td>
<td>
<p>the unconditional standard error for the model-averaged
estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Conf.level</code></td>
<td>
<p>the confidence level used to compute the confidence
interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lower.CL</code></td>
<td>
<p>the lower confidence limit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upper.CL</code></td>
<td>
<p>the upper confidence limit</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Buckland, S. T., Burnham, K. P., Augustin, N. H. (1997) Model selection:
an integral part of inference. <em>Biometrics</em> <b>53</b>, 603–618.  
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., Anderson, D. R. (1992)
Modeling survival and testing biological hypotheses using marked
animals: a unified approach with case-studies. <em>Ecological
Monographs</em> <b>62</b>, 67–118. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>


<h3>See Also</h3>

<p><code>AICcCustom</code>, <code>aictabCustom</code>,
<code>bictabCustom</code>, <code>modavg</code>,
<code>modavgIC</code>, <code>modavgShrink</code>,
<code>modavgPred</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##model averaging parameter estimate (natural average)
##vector with model LL's
LL &lt;- c(-38.8876, -35.1783, -64.8970)

##vector with number of parameters
Ks &lt;- c(7, 9, 4)

##create a vector of names to trace back models in set
Modnames &lt;- c("Cm1", "Cm2", "Cm3")

##vector of beta estimates for a parameter of interest
model.ests &lt;- c(0.0478, 0.0480, 0.0478)

##vector of SE's of beta estimates for a parameter of interest
model.se.ests &lt;- c(0.0028, 0.0028, 0.0034)

##compute model-averaged estimate and unconditional SE based on AICc
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121)
##compute model-averaged estimate and unconditional SE based on BIC
modavgCustom(logL = LL, K = Ks, modnames = Modnames, 
             estimate = model.ests, se = model.se.ests, nobs = 121,
             useBIC = TRUE)


##model-averaging with shrinkage based on AICc
##set up candidate models
data(min.trap)
Cand.mod &lt;- list( )
##global model          
Cand.mod[[1]] &lt;- glm(Num_anura ~ Type + log.Perimeter,
                     family = poisson, offset = log(Effort),
                     data = min.trap) 
Cand.mod[[2]] &lt;- glm(Num_anura ~ Type + Num_ranatra, family = poisson,
                     offset = log(Effort), data = min.trap) 
Cand.mod[[3]] &lt;- glm(Num_anura ~ log.Perimeter + Num_ranatra,
                     family = poisson, offset = log(Effort), data = min.trap)
Model.names &lt;- c("Type + log.Perimeter", "Type + Num_ranatra",
                 "log.Perimeter + Num_ranatra")
##model-averaged estimate with shrinkage (glm model type is already supported)
modavgShrink(cand.set = Cand.mod, modnames = Model.names,
             parm = "log.Perimeter")

##equivalent manual version of model-averaging with shrinkage
##this is especially useful when model classes are not supported
##extract vector of LL
LLs &lt;- sapply(Cand.mod, FUN = function(i) logLik(i)[1])
##extract vector of K
Ks &lt;- sapply(Cand.mod, FUN = function(i) attr(logLik(i), "df"))
##extract betas
betas &lt;- sapply(Cand.mod, FUN = function(i) coef(i)["log.Perimeter"])
##second model does not include log.Perimeter
betas[2] &lt;- 0
##extract SE's
ses &lt;- sapply(Cand.mod, FUN = function(i) sqrt(diag(vcov(i))["log.Perimeter"]))
ses[2] &lt;- 0
##model-averaging with shrinkage based on AICc
modavgCustom(logL = LLs, K = Ks, modnames = Model.names,
             nobs = nrow(min.trap), estimate = betas, se = ses)
##model-averaging with shrinkage based on BIC
modavgCustom(logL = LLs, K = Ks, modnames = Model.names,
             nobs = nrow(min.trap), estimate = betas, se = ses,
             useBIC = TRUE)

## End(Not run)
</code></pre>


</div>