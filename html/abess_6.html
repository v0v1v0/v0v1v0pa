<div class="container">

<table style="width: 100%;"><tr>
<td>abessrpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive best subset selection for robust principal component analysis</h2>

<h3>Description</h3>

<p>Decompose a matrix into the summation of
low-rank matrix and sparse matrix via the best subset selection approach
</p>


<h3>Usage</h3>

<pre><code class="language-R">abessrpca(
  x,
  rank,
  support.size = NULL,
  tune.path = c("sequence", "gsection"),
  gs.range = NULL,
  tune.type = c("gic", "aic", "bic", "ebic"),
  ic.scale = 1,
  lambda = 0,
  always.include = NULL,
  group.index = NULL,
  c.max = NULL,
  splicing.type = 2,
  max.splicing.iter = 1,
  warm.start = TRUE,
  important.search = NULL,
  max.newton.iter = 1,
  newton.thresh = 0.001,
  num.threads = 0,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>A positive integer value specify the rank of the low-rank matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support.size</code></td>
<td>
<p>An integer vector representing the alternative support sizes. 
Only used for <code>tune.path = "sequence"</code>. 
Strongly suggest its minimum value larger than <code>min(dim(x))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.path</code></td>
<td>
<p>The method to be used to select the optimal support size. For
<code>tune.path = "sequence"</code>, we solve the best subset selection problem for each size in <code>support.size</code>.
For <code>tune.path = "gsection"</code>, we solve the best subset selection problem with support size ranged in <code>gs.range</code>,
where the specific support size to be considered is determined by golden section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gs.range</code></td>
<td>
<p>A integer vector with two elements.
The first element is the minimum model size considered by golden-section,
the later one is the maximum one. Default is <code>gs.range = c(1, min(n, round(n/(log(log(n))log(p)))))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.type</code></td>
<td>
<p>The type of criterion for choosing the support size. 
Available options are "gic", "ebic", "bic" and "aic". 
Default is "gic".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic.scale</code></td>
<td>
<p>A non-negative value used for multiplying the penalty term
in information criterion. Default: <code>ic.scale = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A single lambda value for regularized best subset selection. Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>always.include</code></td>
<td>
<p>An integer vector containing the indexes of variables that should always be included in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.index</code></td>
<td>
<p>A vector of integers indicating the which group each variable is in.
For variables in the same group, they should be located in adjacent columns of <code>x</code>
and their corresponding index in <code>group.index</code> should be the same.
Denote the first group as <code>1</code>, the second <code>2</code>, etc.
If you do not fit a model with a group structure,
please set <code>group.index = NULL</code> (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.max</code></td>
<td>
<p>an integer splicing size. Default is: <code>c.max = 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splicing.type</code></td>
<td>
<p>Optional type for splicing.
If <code>splicing.type = 1</code>, the number of variables to be spliced is
<code>c.max</code>, ..., <code>1</code>; if <code>splicing.type = 2</code>,
the number of variables to be spliced is <code>c.max</code>, <code>c.max/2</code>, ..., <code>1</code>.
(Default: <code>splicing.type = 2</code>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.splicing.iter</code></td>
<td>
<p>The maximum number of performing splicing algorithm.
In most of the case, only a few times of splicing iteration can guarantee the convergence.
Default is <code>max.splicing.iter = 20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm.start</code></td>
<td>
<p>Whether to use the last solution as a warm start. Default is <code>warm.start = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>important.search</code></td>
<td>
<p>An integer number indicating the number of
important variables to be splicing.
When <code>important.search</code> <code class="reqn">\ll</code> <code>p</code> variables,
it would greatly reduce runtimes. Default: <code>important.search = 128</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.newton.iter</code></td>
<td>
<p>a integer giving the maximal number of Newton's iteration iterations.
Default is <code>max.newton.iter = 10</code> if <code>newton = "exact"</code>, and <code>max.newton.iter = 60</code> if <code>newton = "approx"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newton.thresh</code></td>
<td>
<p>a numeric value for controlling positive convergence tolerance.
The Newton's iterations converge when <code class="reqn">|dev - dev_{old}|/(|dev| + 0.1)&lt;</code> <code>newton.thresh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.threads</code></td>
<td>
<p>An integer decide the number of threads to be
concurrently used for cross-validation (i.e., <code>tune.type = "cv"</code>).
If <code>num.threads = 0</code>, then all of available cores will be used.
Default: <code>num.threads = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed to be used to divide the sample into cross-validation folds.
Default is <code>seed = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Adaptive best subset selection for robust principal component analysis aim to find two latent matrices <code class="reqn">L</code> and <code class="reqn">S</code> such that the original matrix <code class="reqn">X</code> can be appropriately approximated:
</p>
<p style="text-align: center;"><code class="reqn">x = L + S + N,</code>
</p>
 
<p>where <code class="reqn">L</code> is a low-rank matrix, <code class="reqn">S</code> is a sparse matrix, <code class="reqn">N</code> is a dense noise matrix. 
Generic splicing technique can be employed to solve this problem by iteratively improve the quality of the estimation of <code class="reqn">S</code>. 
</p>
<p>For a given support set <code class="reqn">\Omega</code>, the optimization problem: 
</p>
<p style="text-align: center;"><code class="reqn">\min_S \| x - L - S\|_F^2 \;\;{\rm s.t.}\;\; S_{ij} = 0 {\rm for } (i, j) \in \Omega^c,</code>
</p>

<p>still a non-convex optimization problem. We use the hard-impute algorithm proposed in one of the reference to solve this problem. 
The hard-impute algorithm is an iterative algorithm, people can set <code>max.newton.iter</code> and <code>newton.thresh</code> to 
control the solution precision of the optimization problem. 
(Here, the name of the two parameters are somehow abused to make the parameters cross functions have an unified name.) 
According to our experiments, 
we assign properly parameters to the two parameter as the default such that the precision and runtime are well balanced, 
we suggest users keep the default values unchanged.
</p>


<h3>Value</h3>

<p>A S3 <code>abessrpca</code> class object, which is a <code>list</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>A list with <code>length(support.size)</code> elements,
each of which is a sparse matrix estimation;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>The low rank matrix estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>The number of sample used for training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvars</code></td>
<td>
<p>The number of variables used for training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>The rank of matrix <code>L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>The loss of objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.value</code></td>
<td>
<p>A value of tuning criterion of length <code>length(support.size)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support.size</code></td>
<td>
<p>The actual support.size values used.
Note that it is not necessary the same as the input if the later have non-integer values or duplicated values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.type</code></td>
<td>
<p>The criterion type for tuning parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The original call to <code>abessrpca</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Some parameters not described in the Details Section is explained in the document for <code>abess</code> 
because the meaning of these parameters are very similar. 
</p>
<p>At present, <code class="reqn">l_2</code> regularization and group selection are not support, 
and thus, set <code>lambda</code> and <code>group.index</code> have no influence on the output. 
This feature will coming soon.
</p>


<h3>References</h3>

<p>A polynomial algorithm for best-subset selection problem. Junxian Zhu, Canhong Wen, Jin Zhu, Heping Zhang, Xueqin Wang. Proceedings of the National Academy of Sciences Dec 2020, 117 (52) 33117-33123; <a href="https://doi.org/10.1073/pnas.2014241117">doi:10.1073/pnas.2014241117</a>
</p>
<p>Emmanuel J. Candès, Xiaodong Li, Yi Ma, and John Wright. 2011. Robust principal component analysis? Journal of the ACM. 58, 3, Article 11 (May 2011), 37 pages. <a href="https://doi.org/10.1145/1970392.1970395">doi:10.1145/1970392.1970395</a>
</p>
<p>Mazumder, Rahul, Trevor Hastie, and Robert Tibshirani. Spectral regularization algorithms for learning large incomplete matrices. The Journal of Machine Learning Research 11 (2010): 2287-2322.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(abess)
Sys.setenv("OMP_THREAD_LIMIT" = 2)
n &lt;- 30
p &lt;- 30
true_S_size &lt;- 60
true_L_rank &lt;- 2
dataset &lt;- generate.matrix(n, p, support.size = true_S_size, rank = true_L_rank)
res &lt;- abessrpca(dataset[["x"]], rank = true_L_rank, support.size = 50:70)
print(res)
coef(res)
plot(res, type = "tune")
plot(res, type = "loss")
plot(res, type = "S")

</code></pre>


</div>