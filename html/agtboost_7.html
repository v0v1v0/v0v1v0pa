<div class="container">

<table style="width: 100%;"><tr>
<td>gbt.ksval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kolmogorov-Smirnov validation of model</h2>

<h3>Description</h3>

<p><code>gbt.ksval</code> transforms observations to U(0,1) if the model
is correct and performs a Kolmogorov-Smirnov test for uniformity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gbt.ksval(object, y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object or pointer to object of class <code>ENSEMBLE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Observations to be tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>design matrix for training. Must be of type <code>matrix</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Model validation of model passed as <code>object</code> using observations <code>y</code>.
Assuming the loss is a negative log-likelihood and thus a probabilistic model, 
the transformation 
</p>
<p style="text-align: center;"><code class="reqn">u = F_Y(y;x,\theta) \sim U(0,1),</code>
</p>

<p>is usually valid. 
One parameter, <code class="reqn">\mu=g^{-1}(f(x))</code>, is given by the model. Remaining parameters 
are estimated globally over feature space, assuming they are constant.
This then allow the above transformation to be exploited, so that the 
Kolmogorov-Smirnov test for uniformity can be performed.
</p>
<p>If the response is a count model (<code>poisson</code> or <code>negbinom</code>), the transformation
</p>
<p style="text-align: center;"><code class="reqn">u_i = F_Y(y_i-1;x,\theta) + Uf_Y(y_i,x,\theta), ~ U \sim U(0,1)</code>
</p>

<p>is used to obtain a continuous transformation to the unit interval, which, if the model is
correct, will give standard uniform random variables.
</p>


<h3>Value</h3>

<p>Kolmogorov-Smirnov test of model
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Gaussian regression:
x_tr &lt;- as.matrix(runif(500, 0, 4))
y_tr &lt;- rnorm(500, x_tr, 1)
x_te &lt;- as.matrix(runif(500, 0, 4))
y_te &lt;- rnorm(500, x_te, 1)
mod &lt;- gbt.train(y_tr, x_tr)
gbt.ksval(mod, y_te, x_te)

</code></pre>


</div>