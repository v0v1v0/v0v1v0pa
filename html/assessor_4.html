<div class="container">

<table style="width: 100%;"><tr>
<td>resid_2pm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Residuals for regression models with two-part outcomes</h2>

<h3>Description</h3>

<p>Calculates DPIT proposed residuals for model for semi-continuous outcomes.
<code>resid_2pm</code> can be used either with <code>model0</code> and <code>model1</code> or with <code>part0</code> and <code>part1</code> as arguments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">resid_2pm(model0, model1, y, part0, part1, plot=TRUE, scale = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model0</code></td>
<td>
<p>Model object for 0 outcomes (e.g., logistic regression)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model1</code></td>
<td>
<p>Model object for the continuous part (gamma regression)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Semicontinuous outcome variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>part0</code></td>
<td>
<p>Alternative argument to <code>model0</code>. One can supply the sequence of probabilities <code class="reqn">P(Y_i=0),~i=1,\ldots,n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>part1</code></td>
<td>
<p>Alternative argument to <code>model1</code>. One can fit a regression model on the positive data and supply their probability integral transform. Note that the length of <code>part1</code> is the number of positive values in <code>y</code> and can be shorter than <code>part0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>A logical value indicating whether or not to return QQ-plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>You can choose the scale of the residuals among <code>normal</code> and <code>uniform</code> scales. The default scale is <code>normal</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The DPIT residuals for regression models with semi-continuous outcomes are </p>
<p style="text-align: center;"><code class="reqn">\hat{r}_i=\frac{\hat{F}(Y_i|\mathbf{X}_i)}{n}\sum_{j=1}^n1\left(\hat{p}_0(\mathbf{X}_j)\leq \hat{F}(Y_i|\mathbf{X}_i)\right), i=1,\ldots,n,</code>
</p>

<p>where <code class="reqn">\hat{p}_0(\mathbf{X}_i)</code> is the fitted probability of zero, and <code class="reqn">\hat{F}(\cdot|\mathbf{X}_i)</code> is the  fitted cumulative distribution function for the <code class="reqn">i</code>th observation. Furthermore, </p>
<p style="text-align: center;"><code class="reqn">\hat{F}(y|\mathbf{x})=\hat{p}_0(\mathbf{x})+\left(1-\hat{p}_0(\mathbf{x})\right)\hat{G}(y|\mathbf{x})</code>
</p>

<p>where <code class="reqn">\hat{G}</code> is the fitted cumulative distribution for the positive data.
</p>
<p>In two-part models, the probability of zero can be modeled using a logistic regression, <code>model0</code>,
while the positive observations can be modeled using a gamma regression, <code>model1.</code>
Users can choose to use different models and supply the resulting probability transforms.
<code>part0</code> should be the sequence of fitted probabilities of zeros <code class="reqn">\hat{p}_0(\mathbf{X}_i) ,~i=1,\ldots,n</code>.
<code>part1</code> should be the probability integral transform of the positive part <code class="reqn">\hat{G}(Y_i|\mathbf{X}_i)</code>.
Note that the length of <code>part1</code> is the number of positive values in <code>y</code> and can be shorter than <code>part0</code>.
</p>


<h3>Value</h3>

<p>Residuals. If plot=TRUE, also produces a QQ plot.
</p>


<h3>See Also</h3>

<p><code>resid_semiconti()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(MASS)
n &lt;- 500
beta10 &lt;- 1
beta11 &lt;- -2
beta12 &lt;- -1
beta13 &lt;- -1
beta14 &lt;- -1
beta15 &lt;- -2
x11 &lt;- rnorm(n)
x12 &lt;- rbinom(n, size = 1, prob = 0.4)

p1 &lt;- 1 / (1 + exp(-(beta10 + x11 * beta11 + x12 * beta12)))
lambda1 &lt;- exp(beta13 + beta14 * x11 + beta15 * x12)
y2 &lt;- rgamma(n, scale = lambda1 / 2, shape = 2)
y &lt;- rep(0, n)
u &lt;- runif(n, 0, 1)
ind1 &lt;- which(u &gt;= p1)
y[ind1] &lt;- y2[ind1]

# models as input
mgamma &lt;- glm(y[ind1] ~ x11[ind1] + x12[ind1], family = Gamma(link = "log"))
m10 &lt;- glm(y == 0 ~ x12 + x11, family = binomial(link = "logit"))
resid.model &lt;- resid_2pm(model0 = m10, model1 = mgamma, y = y)

# PIT as input
cdfgamma &lt;- pgamma(y[ind1],
  scale = mgamma$fitted.values * gamma.dispersion(mgamma),
  shape = 1 / gamma.dispersion(mgamma)
)
p1f &lt;- m10$fitted.values
resid.pit &lt;- resid_2pm(y = y, part0 = p1f, part1 = cdfgamma)
</code></pre>


</div>