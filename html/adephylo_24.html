<div class="container">

<table style="width: 100%;"><tr>
<td>proxTips</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute some phylogenetic proximities between tips</h2>

<h3>Description</h3>

<p>The function <code>proxTips</code> computes a given proximity between a set of
tips of a phylogeny. A vector of tips is supplied: proximities between all
possible pairs of these tips are computed.  The proximities are computed
from the shortest path between the tips. <br></p>


<h3>Usage</h3>

<pre><code class="language-R">proxTips(
  x,
  tips = "all",
  method = c("patristic", "nNodes", "oriAbouheif", "Abouheif", "sumDD"),
  f = function(x) {
     1/x
 },
  normalize = c("row", "col", "none"),
  symmetric = TRUE,
  useC = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a tree of class <code>phylo</code>,
phylo4 or phylo4d.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tips</code></td>
<td>
<p>A vector of integers identifying tips by their numbers, or a
vector of characters identifying tips by their names. Distances will be
computed between all possible pairs of tips.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string (full or abbreviated without ambiguity)
specifying the method used to compute proximities; possible values are:<br> -
<code>patristic</code>: (inversed sum of) branch length <br> - <code>nNodes</code>:
(inversed) number of nodes on the path between the nodes <br> -
<code>oriAbouheif</code>: original Abouheif's proximity, with diagonal (see
details) <br> - <code>Abouheif</code>: Abouheif's proximity without diagonal (see
details) <br> - <code>sumDD</code>: (inversed) sum of direct descendants of all
nodes on the path (see details) <br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a function to change a distance into a proximity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>a character string specifying whether the matrix must be
normalized by row (<code>row</code>), column (<code>col</code>), or not (<code>none</code>).
Normalization amounts to dividing each row (or column) so that the marginal
sum is 1. Hence, default is matrix with each row summing to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>a logical stating whether M must be coerced to be symmetric
(TRUE, default) or not. This is achieved by taking (denoting N the matrix of
proximities before re-symmetrization): </p>
<p style="text-align: center;"><code class="reqn">M = 0.5 * (N + N^{T})</code>
</p>
<p> Note
that <code class="reqn">x^{T}Ny = x^{T}My</code>, but the latter has the advantage of using a
bilinear symmetric form (more appropriate for optimization purposes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useC</code></td>
<td>
<p>a logical indicating whether computations of distances (before
transformation into proximities) should be performed using compiled C code
(TRUE, default), or using a pure R version (FALSE). C version is several
orders of magnitude faster, and R version is kept for backward
compatibility.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Proximities are computed as the inverse (to the power <code>a</code>) of a
phylogenetic distance (computed by <code>distTips</code>. Denoting
<code class="reqn">D=[d_{ij}]</code> a matrix of phylogenetic distances, the proximity matrix
<code class="reqn">M=[m_{ij}]</code> is computed as: </p>
<p style="text-align: center;"><code class="reqn">m_{ij} = \frac{1}{d_{ij}^a} \forall i
\neq j</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">m_{ii}
= 0</code>
</p>

<p>Several distances can be used, defaulting to the sum of branch lengths (see
argument <code>method</code>).  Proximities are not true similarity measures,
since the proximity of a tip with itself is always set to zero.<br></p>
<p>The obtained matrix of phylogenetic proximities (M) defines a bilinear
symmetric form when M is symmetric (default):<br></p>
<p style="text-align: center;"><code class="reqn">f(x,y) = x^{T}My</code>
</p>

<p>In general, M is not a metric because it is not positive-definite.  Such a
matrice can be used to measure phylogenetic autocorrelation (using Moran's
index): </p>
<p style="text-align: center;"><code class="reqn">I(x) = \frac{x^TMx}{var(x)}</code>
</p>

<p>or to compute lag vectors (Mx) used in autoregressive models, like: </p>
<p style="text-align: center;"><code class="reqn">x
= Mx + ... + e</code>
</p>
<p> where '...' is the non-autoregressive part of the model, and
'e' are residuals.
</p>
<p><code>Abouheif</code> proximity refers to the phylogenetic proximity underlying
the test of Abouheif (see references). Let P be the set of all the nodes in
the path going from <code>node1</code> to <code>node2</code>. Let DDP be the number of
direct descendants from each node in P. Then, the so-called 'Abouheif'
distance is the inverse of the product of all terms in DDP.
<code>oriAbouheif</code> returns a matrix with non-null diagonal elements, as
formulated in Pavoine <em>et al.</em> (2008). This matrix is bistochastic (all
marginal sums equal 1), but this bilinear symmetric form does not give rise
to a Moran's index, since it requires a null diagonal. <code>Abouheif</code>
contains Abouheif's proximities but has a null diagonal, giving rise to a
Moran's index.<br></p>
<p><code>sumDD</code> refers to a phylogenetic proximity quite similar to that of
Abouheif. We consider the same sets P and DDP. But instead of taking the
inverse of the product of all terms in DDP, this proximity computes the
inverse of the sum of all terms in DDP. This matrix was denoted 'M' in
Pavoine <em>et al.</em> (2008), who reported that it is related to May's index
(May, 1990).
</p>


<h3>Value</h3>

<p>A matrix of phylogenetic proximities.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:tjombart@imperial.ac.uk">tjombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>== About Moran's index with various proximities == <br> Pavoine,
S.; Ollier, S.; Pontier, D.; Chessel, D. (2008) Testing for phylogenetic
signal in life history variable: Abouheif's test revisited.
<em>Theoretical Population Biology</em>: <b>73</b>, 79-91.<br></p>
<p>== About regression on phylogenetic lag vector == <br> Cheverud, J. M.; Dow,
M. M.; Leutenegger, W. (1985) The quantitative assessment of phylogentic
constaints in comparative analyses: sexual dimorphism in body weights among
primates. <em>Evolution</em> <b>39</b>, 1335-1351.<br></p>
<p>Cheverud, J. M.; Dow, M. M. (1985) An autocorrelation analysis of genetic
variation due to lineal fission in social groups of Rhesus macaques.
<em>American Journal of Phyisical Anthropology</em> <b>67</b>, 113-121.<br></p>
<p>== Abouheif's original paper ==<br> Abouheif, E. (1999) A method for testing
the assumption of phylogenetic independence in comparative data.
<em>Evolutionary Ecology Research</em>, <b>1</b>, 895-909.<br></p>
<p>== May's index ==<br> May, R.M. (1990) Taxonomy as destiny. <em>Nature</em>
<b>347</b>, 129-130.
</p>


<h3>See Also</h3>

<p><code>distTips</code> which computes several phylogenetic
distances between tips.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if(require(ape) &amp; require(phylobase)){
## make a tree
x &lt;- as(rtree(10),"phylo4")
plot(x, show.node=TRUE)
axisPhylo()
## compute different distances
proxTips(x, 1:5)
proxTips(x, 1:5, "nNodes")
proxTips(x, 1:5, "Abouheif")
proxTips(x, , "sumDD")

## see what one proximity looks like
M &lt;- proxTips(x)
obj &lt;- phylo4d(x,as.data.frame(M))
table.phylo4d(obj,symbol="sq")
}

</code></pre>


</div>