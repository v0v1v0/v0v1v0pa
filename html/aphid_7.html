<div class="container">

<table style="width: 100%;"><tr>
<td>backward</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The backward algorithm.</h2>

<h3>Description</h3>

<p>This function calculates the full (log) probability or odds
of a sequence given a hidden Markov model or profile HMM using the
backward dynamic programming algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">backward(x, y, ...)

## S3 method for class 'PHMM'
backward(
  x,
  y,
  qe = NULL,
  logspace = "autodetect",
  odds = TRUE,
  windowspace = "all",
  DI = FALSE,
  ID = FALSE,
  cpp = TRUE,
  ...
)

## S3 method for class 'HMM'
backward(x, y, logspace = "autodetect", cpp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>PHMM</code> or <code>HMM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a vector of mode "character" or "raw" (a "DNAbin" or "AAbin"
object) representing a single sequence hypothetically emitted by
the model in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qe</code></td>
<td>
<p>an optional named vector of background residue frequencies (only
applicable if x is a PHMM). If <code>qe = NULL</code> the function looks for
a qe vector as an attribute of the PHMM. If these are not available
equal background residue frequencies are assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odds</code></td>
<td>
<p>logical, indicates whether the returned scores
should be odds ratios (TRUE) or full logged probabilities (FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windowspace</code></td>
<td>
<p>a two-element integer vector providing the search space for
dynamic programming (see Wilbur &amp; Lipman 1983 for details). The first element
should be negative, and represent the lowermost diagonal of the
dynammic programming array, and the second element should be positive,
representing the leftmost diagonal. Alternatively, if the the character
string "all" is passed (the default setting) the entire dynamic programming
array will be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a wrapper for a compiled C++ function that recursively
fills a dynamic programming matrix with logged probabilities, and
calculates the full (logged) probability of a sequence given a HMM or
PHMM.
For a thorough explanation of the backward, forward and Viterbi
algorithms, see Durbin et al (1998) chapters 3.2 (HMMs) and 5.4 (PHMMs).
</p>


<h3>Value</h3>

<p>an object of class <code>"DPA"</code>, which is a list
containing the score and dynamic programming array.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Wilbur WJ, Lipman DJ (1983) Rapid similarity searches of nucleic acid and
protein data banks. <em>Proc Natl Acad Sci USA</em>, <strong>80</strong>, 726-730.
</p>


<h3>See Also</h3>

<p><code>forward</code>, <code>Viterbi</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  ## Backward algorithm for standard HMMs:
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  data(casino)
  backward(x, casino)
  ##
  ## Backward algorithm for profile HMMs:
  ## Small globin alignment data from Durbin et al (1998) Figure 5.3
  data(globins)
  ### Derive a profile hidden Markov model from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ### Simulate a random sequence from the model
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  simulation &lt;- generate(globins.PHMM, size = 20)
  simulation ## "F" "S" "A" "N" "N" "D" "W" "E"
  ### Calculate the full (log) probability of the sequence given the model
  x &lt;- backward(globins.PHMM, simulation, odds = FALSE)
  x # -23.0586
  ### Show dynammic programming array
  x$array
</code></pre>


</div>