<div class="container">

<table style="width: 100%;"><tr>
<td>ggplot_pca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PCA Biplot with <code>ggplot2</code>
</h2>

<h3>Description</h3>

<p>Produces a <code>ggplot2</code> variant of a so-called <a href="https://en.wikipedia.org/wiki/Biplot">biplot</a> for PCA (principal component analysis), but is more flexible and more appealing than the base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> <code>biplot()</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ggplot_pca(
  x,
  choices = 1:2,
  scale = 1,
  pc.biplot = TRUE,
  labels = NULL,
  labels_textsize = 3,
  labels_text_placement = 1.5,
  groups = NULL,
  ellipse = TRUE,
  ellipse_prob = 0.68,
  ellipse_size = 0.5,
  ellipse_alpha = 0.5,
  points_size = 2,
  points_alpha = 0.25,
  arrows = TRUE,
  arrows_colour = "darkblue",
  arrows_size = 0.5,
  arrows_textsize = 3,
  arrows_textangled = TRUE,
  arrows_alpha = 0.75,
  base_textsize = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object returned by <code>pca()</code>, <code>prcomp()</code> or <code>princomp()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choices</code></td>
<td>

<p>length 2 vector specifying the components to plot. Only the default
is a biplot in the strict sense.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>

<p>The variables are scaled by <code>lambda ^ scale</code> and the
observations are scaled by <code>lambda ^ (1-scale)</code> where
<code>lambda</code> are the singular values as computed by
<code>princomp</code>. Normally <code>0 &lt;= scale &lt;= 1</code>, and a warning
will be issued if the specified <code>scale</code> is outside this range.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc.biplot</code></td>
<td>

<p>If true, use what Gabriel (1971) refers to as a "principal component
biplot", with <code>lambda = 1</code> and observations scaled up by sqrt(n) and
variables scaled down by sqrt(n).  Then inner products between
variables approximate covariances and distances between observations
approximate Mahalanobis distance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>an optional vector of labels for the observations. If set, the labels will be placed below their respective points. When using the <code>pca()</code> function as input for <code>x</code>, this will be determined automatically based on the attribute <code>non_numeric_cols</code>, see <code>pca()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_textsize</code></td>
<td>
<p>the size of the text used for the labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_text_placement</code></td>
<td>
<p>adjustment factor the placement of the variable names (<code style="white-space: pre;">⁠&gt;=1⁠</code> means further away from the arrow head)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>an optional vector of groups for the labels, with the same length as <code>labels</code>. If set, the points and labels will be coloured according to these groups. When using the <code>pca()</code> function as input for <code>x</code>, this will be determined automatically based on the attribute <code>non_numeric_cols</code>, see <code>pca()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ellipse</code></td>
<td>
<p>a logical to indicate whether a normal data ellipse should be drawn for each group (set with <code>groups</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ellipse_prob</code></td>
<td>
<p>statistical size of the ellipse in normal probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ellipse_size</code></td>
<td>
<p>the size of the ellipse line</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ellipse_alpha</code></td>
<td>
<p>the alpha (transparency) of the ellipse line</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points_size</code></td>
<td>
<p>the size of the points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points_alpha</code></td>
<td>
<p>the alpha (transparency) of the points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows</code></td>
<td>
<p>a logical to indicate whether arrows should be drawn</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows_colour</code></td>
<td>
<p>the colour of the arrow and their text</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows_size</code></td>
<td>
<p>the size (thickness) of the arrow lines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows_textsize</code></td>
<td>
<p>the size of the text at the end of the arrows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows_textangled</code></td>
<td>
<p>a logical whether the text at the end of the arrows should be angled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows_alpha</code></td>
<td>
<p>the alpha (transparency) of the arrows and their text</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_textsize</code></td>
<td>
<p>the text size for all plot elements except the labels and arrows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed on to functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The colours for labels and points can be changed by adding another scale layer for colour, such as <code>scale_colour_viridis_d()</code> and <code>scale_colour_brewer()</code>.
</p>


<h3>Source</h3>

<p>The <code>ggplot_pca()</code> function is based on the <code>ggbiplot()</code> function from the <code>ggbiplot</code> package by Vince Vu, as found on GitHub: <a href="https://github.com/vqv/ggbiplot">https://github.com/vqv/ggbiplot</a> (retrieved: 2 March 2020, their latest commit: <a href="https://github.com/vqv/ggbiplot/commit/7325e880485bea4c07465a0304c470608fffb5d9"><code>7325e88</code></a>; 12 February 2015).
</p>
<p>As per their GPL-2 licence that demands documentation of code changes, the changes made based on the source code were:
</p>

<ol>
<li>
<p> Rewritten code to remove the dependency on packages <code>plyr</code>, <code>scales</code> and <code>grid</code>
</p>
</li>
<li>
<p> Parametrised more options, like arrow and ellipse settings
</p>
</li>
<li>
<p> Hardened all input possibilities by defining the exact type of user input for every argument
</p>
</li>
<li>
<p> Added total amount of explained variance as a caption in the plot
</p>
</li>
<li>
<p> Cleaned all syntax based on the <code>lintr</code> package, fixed grammatical errors and added integrity checks
</p>
</li>
<li>
<p> Updated documentation
</p>
</li>
</ol>
<h3>Examples</h3>

<pre><code class="language-R"># `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.


if (require("dplyr")) {
  # calculate the resistance per group first
  resistance_data &lt;- example_isolates %&gt;%
    group_by(
      order = mo_order(mo), # group on anything, like order
      genus = mo_genus(mo)
    ) %&gt;% #   and genus as we do here;
    filter(n() &gt;= 30) %&gt;% # filter on only 30 results per group
    summarise_if(is.sir, resistance) # then get resistance of all drugs

  # now conduct PCA for certain antimicrobial drugs
  pca_result &lt;- resistance_data %&gt;%
    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)

  summary(pca_result)

  # old base R plotting method:
  biplot(pca_result)

  # new ggplot2 plotting method using this package:
  if (require("ggplot2")) {
    ggplot_pca(pca_result)

    # still extendible with any ggplot2 function
    ggplot_pca(pca_result) +
      scale_colour_viridis_d() +
      labs(title = "Title here")
  }
}

</code></pre>


</div>