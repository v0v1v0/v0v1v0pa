<div class="container">

<table style="width: 100%;"><tr>
<td>kdist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>the class of objects 'kdist' (K distance matrices)</h2>

<h3>Description</h3>

<p>An object of class <code>kdist</code> is a list of distance matrices observed on the same individuals
</p>


<h3>Usage</h3>

<pre><code class="language-R">kdist(..., epsi = 1e-07, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> a sequence of objects of the class <code>kdist</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsi</code></td>
<td>
<p> a tolerance threshold to test if distances are Euclidean (Gower's theorem) using <code class="reqn">\frac{\lambda_n}{\lambda_1}</code> is larger than -epsi. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p> a logical value indicating whether the upper of a distance matrix is used (TRUE) or not (FALSE).  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The attributs of a 'kdist' object are:<br><code>names</code>: the names of the distances<br><code>size</code>: the number of points between distances are known<br><code>labels</code>: the labels of points<br><code>euclid</code>: a logical vector indicating whether each distance of the list is Euclidean or not.<br><code>call</code>: a call order<br><code>class</code>: object 'kdist'<br></p>


<h3>Value</h3>

<p>returns an object of class 'kdist' containing a list of semidefinite matrices.
</p>


<h3>Author(s)</h3>

<p> Daniel Chessel  <br>
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a></p>


<h3>References</h3>

<p> Gower, J. C. (1966) Some distance properties of latent root and vector methods used in multivariate analysis. <em>Biometrika</em>, <b>53</b>, 325–338. </p>


<h3>Examples</h3>

<pre><code class="language-R"># starting from a list of matrices 
data(yanomama)
lapply(yanomama,class)  
kd1 = kdist(yanomama)
print(kd1)

# giving the correlations of Mantel's test
cor(as.data.frame(kd1))
pairs(as.data.frame(kd1))

# starting from a list of objects 'dist'
data(friday87)
fri.w &lt;- ktab.data.frame(friday87$fau, friday87$fau.blo, 
    tabnames = friday87$tab.names)
fri.kd = lapply(1:10, function(x) dist.binary(fri.w[[x]],2))
names(fri.kd) = friday87$tab.names
unlist(lapply(fri.kd,class)) # a list of distances
fri.kd = kdist(fri.kd)
fri.kd
s.corcircle(dudi.pca(as.data.frame(fri.kd), scan = FALSE)$co)

# starting from several distances
data(ecomor)
d1 &lt;- dist.binary(ecomor$habitat, 1)
d2 &lt;- dist.prop(ecomor$forsub, 5)
d3 &lt;- dist.prop(ecomor$diet, 5)
d4 &lt;- dist.quant(ecomor$morpho, 3)
d5 &lt;- dist.taxo(ecomor$taxo)
ecomor.kd &lt;- kdist(d1, d2, d3, d4, d5)
names(ecomor.kd) = c("habitat", "forsub", "diet", "morpho", "taxo")
class(ecomor.kd)
s.corcircle(dudi.pca(as.data.frame(ecomor.kd), scan = FALSE)$co)

data(bsetal97)
X &lt;- prep.fuzzy.var(bsetal97$biol, bsetal97$biol.blo)
w1 &lt;- attr(X, "col.num")
w2 &lt;- levels(w1)
w3 &lt;- lapply(w2, function(x) dist.quant(X[,w1==x], method = 1))
names(w3) &lt;- names(attr(X, "col.blocks"))
w3 &lt;- kdist(list = w3)
s.corcircle(dudi.pca(as.data.frame(w3), scan = FALSE)$co)

data(rpjdl)
w1 = lapply(1:10, function(x) dist.binary(rpjdl$fau, method = x))
w2 = c("JACCARD", "SOKAL_MICHENER", "SOKAL_SNEATH_S4", "ROGERS_TANIMOTO")
w2 = c(w2, "CZEKANOWSKI", "S9_GOWER_LEGENDRE", "OCHIAI", "SOKAL_SNEATH_S13")
w2 &lt;- c(w2, "Phi_PEARSON", "S2_GOWER_LEGENDRE")
names(w1) &lt;- w2
w3 = kdist(list = w1)
w4 &lt;- dudi.pca(as.data.frame(w3), scan = FALSE)$co
w4
</code></pre>


</div>