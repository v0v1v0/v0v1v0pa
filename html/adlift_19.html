<div class="container">

<table style="width: 100%;"><tr>
<td>denoiseheteromp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>denoiseheteromp</h2>

<h3>Description</h3>

<p>Denoises the multiple observation inputted signal using artificial levels noise variance estimation and bayesian thresholding, using heteroscedastic (estimated) noise variances.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">denoiseheteromp(x, f, pred, neigh, int, clo, keep, 
rule = "median", mpdet="ave",returnall=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and <code>AdaptNeigh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If clo is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>The type of bayesian thresholding used in the procedure. Possible values are <span class="env">"mean"</span>, <span class="env">"median"</span> (posterior mean or median thresholding) or "hard or <br> "soft" (hard or soft thresholding). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mpdet</code></td>
<td>
<p>how the mutiple point detail coefficients are computed.  Possible values are "ave", in which the multiple detail coefficients produced when performing the multiple predictions are averaged, or "min", where the overall minimum detail coefficient is taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses the transform matrix to normalise the detail coefficients produced from the forward transform, so that they can be used in the bayesian thresholding procedure EbayesThresh. The coefficients are divided into artificial levels, and the first (largest)level is used to estimate the noise variances of the coefficients, based on those coefficients falling in a sliding window around each gridpoint.  EbayesThresh is then used to threshold the coefficients. The resulting new coefficients are then unnormalised and the transform inverted to obtain an estimate of the true (unnoisy) signal.    
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, a list with components:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>fhat</code></td>
<td>
<p>the estimate of the function after denoising.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fhat1</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of MAD, centered at zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fhat2</code></td>
<td>
<p>the estimate of the function after denoising, using the alternate variance estimate of the median of the absolute values of the detail coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indsd</code></td>
<td>
<p>the individual coefficient variances introduced by the transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>al</code></td>
<td>
<p>the artificial levels used to estimate the noise variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>the standard deviation of the noise.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code>denoisehetero</code>, <code>heterovar</code>     </p>


<h3>Examples</h3>

<pre><code class="language-R">data(motorcycledata)
#
times&lt;-motorcycledata$time
accel&lt;-motorcycledata$accel



est1&lt;-denoiseheteromp(times,accel,AdaptNeighmp,1,TRUE,TRUE,2,
"median","ave")
#
#the estimate of the underlying curve. 


</code></pre>


</div>