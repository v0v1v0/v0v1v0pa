<div class="container">

<table style="width: 100%;"><tr>
<td>modavgPred</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute Model-averaged Predictions
</h2>

<h3>Description</h3>

<p>This function computes the model-averaged predictions, unconditional
standard errors, and confidence intervals  based on the entire candidate
model set.  The function is currently implemented for <code>glm</code>,
<code>gls</code>, <code>lm</code>, <code>lme</code>, <code>mer</code>, <code>merMod</code>,
<code>lmerModLmerTest</code>, <code>negbin</code>, <code>rlm</code>, <code>survreg</code> object
classes that are stored in a list as well as various models of
<code>unmarkedFit</code> classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">modavgPred(cand.set, modnames = NULL, newdata, second.ord = TRUE,
           nobs = NULL, uncond.se = "revised", conf.level = 0.95, ...)

## S3 method for class 'AICaov.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICglm.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        gamdisp = NULL, ...)

## S3 method for class 'AIClm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICgls'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AIClme'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICmer'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, ...)

## S3 method for class 'AICglmerMod'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1, ...)

## S3 method for class 'AIClmerMod'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AIClmerModLmerTest'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...)

## S3 method for class 'AICnegbin.glm.lm'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...)

## S3 method for class 'AICrlm.lm'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, ...) 

## S3 method for class 'AICsurvreg'
modavgPred(cand.set, modnames = NULL, newdata,
        second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", ...) 

## S3 method for class 'AICunmarkedFitOccu'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised", 
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitColExt'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)  

## S3 method for class 'AICunmarkedFitOccuRN'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitPCount'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitPCO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...) 

## S3 method for class 'AICunmarkedFitGDS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuFP'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMPois'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGMM'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitGPC'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuTTD'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitMMO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitDSO'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMS'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)

## S3 method for class 'AICunmarkedFitOccuMulti'
modavgPred(cand.set, modnames = NULL,
        newdata, second.ord = TRUE, nobs = NULL, uncond.se = "revised",
        conf.level = 0.95, type = "response", c.hat = 1,
        parm.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cand.set</code></td>
<td>

<p>a list storing each of the models in the candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modnames</code></td>
<td>

<p>a character vector of model names to facilitate the identification of
each model in the model selection table. If <code>NULL</code>, the function
uses the names in the cand.set list of candidate models. If no names
appear in the list, generic names (e.g., <code>Mod1</code>, <code>Mod2</code>) are
supplied in the table in the same order as in the list of candidate
models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>a data frame with the same structure as that of the original data frame
for which we want to make predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>second.ord</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the function returns the second-order
Akaike information criterion (i.e., AICc).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>

<p>this argument allows to specify a numeric value other than total
sample size to compute the AICc (i.e., <code>nobs</code> defaults to total
number of observations).  This is relevant only for mixed models or
various models of <code>unmarkedFit</code> classes where sample size is not
straightforward.  In such cases, one might use total number of
observations or number of independent clusters (e.g., sites) as the
value of <code>nobs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>
<p>either, <code>old</code>, or <code>revised</code>, specifying the
equation used to compute the unconditional standard error of a
model-averaged estimate.  With <code>uncond.se = "old"</code>,
computations are based on equation 4.9 of Burnham and Anderson
(2002), which was the former way to compute unconditional standard
errors.  With <code>uncond.se = "revised"</code>, equation 6.12 of Burnham
and Anderson (2002) is used.  Anderson (2008, p. 111) recommends use
of the revised version for the computation of unconditional standard
errors and it is now the default.  Note that versions of package
AICcmodavg &lt; 1.04 used the old method to compute unconditional
standard errors.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level (<code class="reqn">1 - \alpha</code>) requested for the computation of
unconditional confidence intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>the scale of prediction requested, one of <code>response</code> or
<code>link</code>.  The latter is only relevant for <code>glm</code>, <code>mer</code>,
and <code>unmarkedFit</code> classes.  Note that the value <code>terms</code> is not
defined for <code>modavgPred</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor) such
as that obtained from <code>c_hat</code>.  Note that values of <code>c.hat</code>
different from 1 are only appropriate for binomial GLM's with trials &gt; 1
(i.e., success/trial or cbind(success, failure) syntax), with Poisson
GLM's, single-season and dynamic occupancy models (MacKenzie et
al. 2002, 2003), or <em>N</em>-mixture models (Royle 2004, Dail and Madsen
2011).  If <code>c.hat &gt; 1</code>, <code>modavgPred</code> will return the
quasi-likelihood analogue of the information criteria requested and
multiply the variance-covariance matrix of the estimates by this value
(i.e., SE's are multiplied by <code>sqrt(c.hat)</code>).  This option is not
supported for generalized linear mixed models of the <code>mer</code> class.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamdisp</code></td>
<td>

<p>the value of the gamma dispersion parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
<p>  this argument specifies the parameter type on which
the predictions will be computed and is only relevant for models of
<code>unmarkedFit</code> classes.  The character strings supported vary with
the type of model fitted.  For <code>unmarkedFitOccu</code> objects, either
<code>psi</code> or <code>detect</code> can be supplied to indicate whether the
parameter is on occupancy or detectability, respectively.  For
<code>unmarkedFitColExt</code> objects, possible values are <code>psi</code>,
<code>gamma</code>, <code>epsilon</code>, and <code>detect</code>, for parameters on
occupancy in the inital year, colonization, extinction, and
detectability, respectively.  For <code>unmarkedFitOccuTTD</code> objects,
possible values are <code>psi</code>, <code>gamma</code>, <code>epsilon</code>, and
<code>detect</code>, for parameters on occupancy in the inital year,
colonization, extinction, and time-to-dection (lambda rate parameter),
respectively.  For <code>unmarkedFitOccuFP</code> objects, one can specify
<code>psi</code>, <code>detect</code>, <code>falsepos</code>, and <code>certain</code>, for
occupancy, detectability, probability of assigning false-positives,
and probability detections are certain, respectively.  For
<code>unmarkedFitOccuRN</code> objects, either <code>lambda</code> or
<code>detect</code> can be entered for abundance and detectability
parameters, respectively.  For <code>unmarkedFitPCount</code> and
<code>unmarkedFitMPois</code> objects, <code>lambda</code> or <code>detect</code> denote
parameters on abundance and detectability, respectively.  For
<code>unmarkedFitPCO</code>, <code>unmarkedFitMMO</code>, and
<code>unmarkedFitDSO</code> objects, one can enter <code>lambda</code>,
<code>gamma</code>, <code>omega</code>, <code>iota</code>, or <code>detect</code>, to specify
parameters on abundance, recruitment, apparent survival, immigration,
and detectability, respectively.  For <code>unmarkedFitDS</code> objects,
<code>lambda</code> and <code>detect</code> are supported.  For
<code>unmarkedFitGDS</code>, <code>lambda</code>, <code>phi</code>, and <code>detect</code>
denote abundance, availability, and detection probability,
respectively.  For <code>unmarkedFitGMM</code> and <code>unmarkedFitGPC</code>
objects, <code>lambda</code>, <code>phi</code>, and <code>detect</code> denote
abundance, availability, and detectability, respectively.  For
<code>unmarkedFitOccuMS</code> objects, <code>psi</code>, <code>phi</code>, and
<code>detect</code> denote occupancy, transition, and detection probability,
respectively.  For <code>unmarkedFitOccuMulti</code> objects, <code>psi</code> and
<code>detect</code> denote occupancy and detection probability,
respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The candidate models must be stored in a list.  Note that a data frame
from which to make predictions must be supplied with the <code>newdata</code>
argument and that all variables appearing in the model set must appear
in this data frame.  Variables must be of the same type as in the
original analysis (e.g., factor, numeric).
</p>
<p>One can compute unconditional confidence intervals around the
predictions from the elements returned by <code>modavgPred</code>.  The
classic computation based on asymptotic normality of the estimator is
appropriate to estimate confidence intervals on the linear predictor
(i.e., link scale).  For predictions of some types of response
variables such as counts or binary variables, the normal approximation
may be inappropriate.  In such cases, it is often better to compute
the confidence intervals on the linear predictor scale and then
back-transform the limits to the scale of the response variable.
These are the confidence intervals returned by <code>modavgPred</code>.
Burnham et al. (1987), Burnham and Anderson (2002, p. 164), and 
Williams et al. (2002) suggest alternative methods of computing
confidence intervals for small degrees of freedom with profile
likelihood intervals or bootstrapping, but these approaches are not
yet implemented in <code>modavgPred</code>.
</p>


<h3>Value</h3>

<p><code>modavgPred</code> returns an object of class <code>modavgPred</code> with the 
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>the scale of predicted values (response or link) for <code>glm</code>, <code>mer</code>,
<code>merMod</code>, or <code>unmarkedFit</code> classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.avg.pred</code></td>
<td>

<p>the model-averaged prediction over the entire candidate model set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uncond.se</code></td>
<td>

<p>the unconditional standard error of each model-averaged prediction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>

<p>the confidence level used to compute the confidence
interval.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.CL</code></td>
<td>
<p>the lower confidence limit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.CL</code></td>
<td>
<p>the upper confidence limit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix.output</code></td>
<td>
<p>a matrix with rows consisting of the model-averaged
predictions, the unconditional standard errors, and the confidence
limits.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Anderson, D. R. (2008) <em>Model-based Inference in the Life Sciences:
a primer on evidence</em>. Springer: New York.
</p>
<p>Burnham, K. P., Anderson, D. R., White, G. C., Brownie, C., Pollock,
K. H. (1987) Design and analysis methods for fish survival experiments
based on release-recapture. <em>American Fisheries Society Monographs</em>
<b>5</b>, 1–437.
</p>
<p>Burnham, K. P., Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: a practical information-theoretic
approach</em>. Second edition. Springer: New York.  
</p>
<p>Dail, D., Madsen, L. (2011) Models for estimating abundance from 
repeated counts of an open population. <em>Biometrics</em> <b>67</b>,
577–587. 
</p>
<p>MacKenzie, D. I., Nichols, J. D., Lachman, G. B., Droege, S., Royle,
J. A., Langtimm, C. A. (2002) Estimating site occupancy rates when
detection probabilities are less than one. <em>Ecology</em> <b>83</b>,
2248–2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Hines, J. E., Knutson, M. G.,
Franklin, A. B. (2003) Estimating site occupancy, colonization, and
local extinction when a species is detected imperfectly. <em>Ecology</em>
<b>84</b>, 2200–2207.
</p>
<p>Royle, J. A. (2004) <em>N</em>-mixture models for estimating population
size from spatially replicated counts. <em>Biometrics</em> <b>60</b>,
108–115.
</p>
<p>Williams, B. K., Nichols, J. D., Conroy, M. J. (2002) <em>Analysis and
Management of Animal Populations</em>. Academic Press: New York. 
</p>


<h3>See Also</h3>

<p><code>AICc</code>, <code>aictab</code>, <code>importance</code>,
<code>c_hat</code>, <code>confset</code>, <code>evidence</code>, 
<code>modavg</code>, <code>modavgCustom</code>,
<code>modavgEffect</code>, <code>modavgShrink</code>,
<code>predict</code>, <code>predictSE</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##example from subset of models in Table 1 in Mazerolle (2006)
data(dry.frog)

Cand.models &lt;- list( )
Cand.models[[1]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2,
                       data = dry.frog)
Cand.models[[2]] &lt;- lm(log_Mass_lost ~ Shade + Substrate +
                       cent_Initial_mass + Initial_mass2 +
                       Shade:Substrate, data = dry.frog)
Cand.models[[3]] &lt;- lm(log_Mass_lost ~ cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[4]] &lt;- lm(log_Mass_lost ~ Shade + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)
Cand.models[[5]] &lt;- lm(log_Mass_lost ~ Substrate + cent_Initial_mass +
                       Initial_mass2, data = dry.frog)

##setup model names
Modnames &lt;- paste("mod", 1:length(Cand.models), sep = "")

##compute model-averaged value and unconditional SE of predicted log of
##mass lost for frogs of average mass in shade for each substrate type

##first create data set to use for predictions
new.dat &lt;- data.frame(Shade = c(1, 1, 1),
                      cent_Initial_mass = c(0, 0, 0),
                      Initial_mass2 = c(0, 0, 0),
                      Substrate = c("SOIL", "SPHAGNUM", "PEAT")) 

##compare unconditional SE's using both methods
modavgPred(cand.set = Cand.models, modnames = Modnames,
           newdata = new.dat, type = "response", uncond.se = "old")
modavgPred(cand.set = Cand.models, modnames = Modnames,
           newdata = new.dat, type = "response", uncond.se = "revised")
##round to 4 digits after decimal point
print(modavgPred(cand.set = Cand.models, modnames = Modnames,
                 newdata = new.dat, type = "response",
                 uncond.se = "revised"), digits = 4)



##Gamma glm
## Not run: 
##clotting data example from 'gamma.shape' in MASS package of
##Venables and Ripley (2002, Modern applied statistics with
##S. Springer-Verlag: New York.)
clotting &lt;- data.frame(u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
                       lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18),
                       lot2 = c(69, 35, 26, 21, 18, 16, 13, 12, 12))
clot1 &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma)

require(MASS)
gamma.dispersion(clot1) #dispersion parameter
gamma.shape(clot1) #reciprocal of dispersion parameter ==
##shape parameter 
summary(clot1, dispersion = gamma.dispersion(clot1))  #better

##create list with models
Cand &lt;- list( )
Cand[[1]] &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma)
Cand[[2]] &lt;- glm(lot1 ~ 1, data = clotting, family = Gamma)

##create vector of model names
Modnames &lt;- paste("mod", 1:length(Cand), sep = "")

##compute model-averaged predictions on scale of response variable for
##all observations
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "response") 

##compute model-averaged predictions on scale of linear predictor
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "link")

##compute model-averaged predictions on scale of linear predictor
modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           gamdisp = gamma.dispersion(clot1), type = "terms") #returns an error
##because type = "terms" is not defined for 'modavgPred'

modavgPred(cand.set = Cand, modnames = Modnames, newdata = clotting,
           type = "terms") #returns an error because
##no gamma dispersion parameter was specified (i.e., 'gamdisp' missing) 

## End(Not run)


##example of model-averaged predictions from N-mixture model
##each variable appears twice in the models - this is a bit longer
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##set up models so that each variable on abundance appears twice
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF,
                      K = 30)
fm.mall.two &lt;- pcount(~ ivel + date  ~ elev + forest, mallardUMF,
                      K = 30)
fm.mall.three &lt;- pcount(~ ivel + date  ~ length + elev, mallardUMF,
                        K = 30)
fm.mall.four &lt;- pcount(~ ivel + date  ~ 1, mallardUMF, K = 30)

##model list
Cands &lt;- list(fm.mall.one, fm.mall.two, fm.mall.three, fm.mall.four)
Modnames &lt;- c("length + forest", "elev + forest", "length + elev",
              "null")

##compute model-averaged predictions of abundance for values of elev
modavgPred(cand.set = Cands, modnames = Modnames, newdata =
           data.frame(elev = seq(from = -1.4, to = 2.4, by = 0.1),
                      length = 0, forest = 0), parm.type = "lambda",
           type = "response")

##compute model-averaged predictions of detection for values of ivel
modavgPred(cand.set = Cands, modnames = Modnames, newdata =
           data.frame(ivel = seq(from = -1.75, to = 5.9, by = 0.5),
                      date = 0), parm.type = "detect",
           type = "response")
detach(package:unmarked)

## End(Not run)


##example of model-averaged abundance from distance model
## Not run: 
##this is a bit longer
data(linetran) #example from ?distsamp
     
ltUMF &lt;- with(linetran, {
  unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
                  siteCovs = data.frame(Length, area, habitat),
                  dist.breaks = c(0, 5, 10, 15, 20),
                  tlength = linetran$Length * 1000, survey = "line",
                  unitsIn = "m")
})
     
## Half-normal detection function. Density output (log scale). No covariates.
fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF)
     
## Halfnormal. Covariates affecting both density and and detection.
fm2 &lt;- distsamp(~area + habitat ~ habitat, ltUMF)

## Hazard function. Covariates affecting both density and and detection.
fm3 &lt;- distsamp(~area + habitat ~ habitat, ltUMF, keyfun="hazard")

##assemble model list
Cands &lt;- list(fm1, fm2, fm3)
Modnames &lt;- paste("mod", 1:length(Cands), sep = "")

##model-average predictions on abundance
modavgPred(cand.set = Cands, modnames = Modnames, parm.type = "lambda", type = "link",
           newdata = data.frame(area = mean(linetran$area), habitat = c("A", "B")))
detach(package:unmarked)

## End(Not run)



##example using Orthodont data set from Pinheiro and Bates (2000)
## Not run: 
require(nlme)

##set up candidate models
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

m2 &lt;- gls(distance ~ 1, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method = "ML")

##assemble in list
Cand.models &lt;- list(m1, m2)
##model names
Modnames &lt;- c("age effect", "null model")

##model selection table
aictab(cand.set = Cand.models, modnames = Modnames)

##model-averaged predictions
modavgPred(cand.set = Cand.models, modnames = Modnames, newdata =
data.frame(age = c(8, 10, 12, 14)))
detach(package:nlme)

## End(Not run)
</code></pre>


</div>