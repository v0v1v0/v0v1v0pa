<div class="container">

<table style="width: 100%;"><tr>
<td>adapt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive P-value Thresholding</h2>

<h3>Description</h3>

<p><code>adapt</code> is a framework allowing for arbitrary exponential families for computing E-steps and arbitrary algorithms for fitting M-steps.
</p>


<h3>Usage</h3>

<pre><code class="language-R">adapt(x, pvals, models, dist = beta_family(), s0 = rep(0.45, length(pvals)),
  alphas = seq(0.01, 1, 0.01), params0 = list(pix = NULL, mux = NULL),
  nfits = 20, nms = 1, niter_fit = 10, tol = 1e-04, niter_ms = 20,
  cr = "BIC", verbose = list(print = TRUE, fit = FALSE, ms = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>an object of class "<code>adapt_model</code>" or a list of objects of class "adapt_model". See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>an object of class "<code>gen_exp_family</code>". <code>beta_family()</code> as default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0</code></td>
<td>
<p>a vector of values in [0, 0.5). Initial threshold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>a vector of values in (0, 1). Target FDR levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params0</code></td>
<td>
<p>a list in the form of list(pix = , mux = ). Initial guess of pi(x) and mu(x). NULL as default</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfits</code></td>
<td>
<p>a positive integer. Number of model-fitting steps. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nms</code></td>
<td>
<p>a non-negative integer. Number of model selection steps. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter_fit</code></td>
<td>
<p>a positive integer. Number of EM iterations in model fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a positive scalar. EM algorithm stops when pi(x) and mu(x) in consecutive steps differ by at most 'tol' for each element</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter_ms</code></td>
<td>
<p>a positive integer. Number of EM iterations in model selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cr</code></td>
<td>
<p>a string. The criterion for model selection with BIC as default. Also support AIC, AICC and HIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a list of logical values in the form of list(print = , fit = , ms = ). Each element indicates whether the relevant information is outputted to the console. See Details</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>x</code> should have a type compatible to the fitting functions in <code>models</code>. For GLM and GAM, <code>x</code> should be a data.frame. For glmnet, <code>x</code> should be a matrix.
</p>
<p><code>models</code> could either be an <code>adapt_model</code> object, if a single model is used, or a list of <code>adapt_model</code> objects, each of which corresponding to a model. Each element should be generated by <code>gen_adapt_model</code>. For glm/gam/glmnet, one can use the shortcut by running <code>gen_adapt_model</code> with name = "glm" or "gam" or "glmnet" but without specifying <code>pifun</code>, <code>mufun</code>, <code>pifun_init</code> and <code>mufun_init</code>. See examples below.
</p>
<p><code>nfits</code> is the number of model fitting steps plus <code>nms</code>, the model selection steps, if <code>models</code> contains multiple <code>adapt_model</code> objects. Suppose M is the number of masked p-values at the initial step, then the model is updated at the initial step and at every time when [M/<code>nfits</code>] more p-values are revealed. If <code>nms &gt; 0</code>, model selection is performed at the initial step an at every time when [M/<code>nms</code>] more p-values are revealed. Between two consecutive model selection steps, the model selected from the last step is used for model fitting. For example, when M = 10000, nfits = 10 and nms = 2, model selection will be performed at the initial step and when 5000 p-values are revealed, while the model fitting will be performed when 1000, 2000, 3000, 4000, 6000, 7000, 8000, 9000 p-values are revealed.
</p>
<p><code>verbose</code> has three elements: <code>print</code>, <code>fit</code> and <code>ms</code>. If <code>print = TRUE</code>, the progress of the main procedure is outputted to the console, in the form of "alpha = 0.05: FDPhat 0.0333, Number of Rej. 30" (where the numbers are made up for illustration). If <code>fit = TRUE</code>, a progress bar for the model fitting is outputted to the console. Similarly, if <code>ms = TRUE</code>, a progress bar for the model selection is outputted to the console.
</p>
<p>For ultra-large scale problems (n &gt; 10^5), it is recommended to keep <code>alphas</code> short because the output <code>s</code> is of size n x <code>length(alphas)</code>.
is <code>length(alphas)</code>.
</p>
<p>The output <code>qvals</code> gives the q-values of each hypothesis. <code>qvals[i]</code> is defined as the minimum target FDR level such that <code>pvals[i]</code> is rejected. For hypotheses with p-values above s0, the q-values are set to be Inf because they are never rejected by AdaPT for whatever alpha.
</p>
<p>The output <code>order</code> gives the order of (the indices of) p-values being revealed, i.e. being in the region (s, 1-s). The latter hypotheses appeared in <code>order</code> have smaller q-values (i.e. are more likely to be rejected).
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nrejs</code></td>
<td>
<p>a vector of integers. Number of rejections for each alpha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rejs</code></td>
<td>
<p>a list of vector of integers. The set of indices of rejections for each alpha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a matrix of size <code>length(pvals) X length(alphas)</code>. Threshold curves for each alpha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a list. Each element is a list in the form of <code>list(pix = , mux = , alpha = , nmasks =)</code>, recording the parameter estimates, the achieved alpha and the number of masked p-values. To avoid massive storage cost, it only contains the information when a new target FDR level is achieved. As a result, it might be  shorter than <code>nfits</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qvals</code></td>
<td>
<p>a vector of values in [0, 1]UInf. Q-values. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a permutation of <code>1:length(pvals)</code>. Indices of hypotheses arranged in the order of reveal. See Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>same as the input <code>alphas</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>same as the input <code>dist</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>a list of <code>adapt_model</code> objects of length <code>params</code>. The model used in each fitting step. As in <code>params</code>, it only contains the model when a new target FDR level is achieved and each element corresponds to an element of <code>params</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>a list of length <code>nfits</code>. Each element is a list recording extra information in each fitting step, e.g. degree of freedom (df) and variable importance (vi). As in <code>params</code>, it only contains the model information when a new target FDR level is achieved and each element corresponds to an element of <code>params</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>a list including the other inputs <code>nfits</code>, <code>nms</code>, <code>niter_fit</code>, <code>niter_ms</code>, <code>tol</code>, <code>cr</code></p>
</td>
</tr>
</table>
<p>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Generate models for function adapt
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
models &lt;- lapply(formulas, function(formula){
    piargs &lt;- muargs &lt;- list(formula = formula)
    gen_adapt_model(name = "glm", piargs = piargs, muargs = muargs)
})

# Run adapt
res &lt;- adapt(x = x, pvals = pvals, models = models,
             dist = dist, nfits = 10)


</code></pre>


</div>