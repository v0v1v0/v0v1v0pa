<div class="container">

<table style="width: 100%;"><tr>
<td>afex_plot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>m-way Plot with Error Bars and Raw Data</h2>

<h3>Description</h3>

<p>Plots results from factorial experiments. Estimated marginal 
means and error bars are plotted in the foreground, raw data is plotted in 
the background. Error bars can be based on different standard errors (e.g.,
model-based, within-subjects, between-subjects). Functions described here
return a <span class="pkg">ggplot2</span> plot object, thus allowing further customization of
the plot.
</p>
<p><code>afex_plot</code> is the user friendly function that does data preparation
and plotting. It also allows to only return the prepared data (<code>return
  = "data"</code>).
</p>
<p><code>interaction_plot</code> does the plotting when a <code>trace</code> factor is
present. <code>oneway_plot</code> does the plotting when a <code>trace</code> factor is
absent.
</p>


<h3>Usage</h3>

<pre><code class="language-R">afex_plot(object, ...)

## S3 method for class 'afex_aov'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  plot_first = NULL,
  legend_title,
  ...
)

## S3 method for class 'mixed'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  plot_first = NULL,
  legend_title,
  ...
)

## S3 method for class 'merMod'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  plot_first = NULL,
  legend_title,
  ...
)

## Default S3 method:
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  dv,
  data,
  within_vars,
  between_vars,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  plot_first = NULL,
  legend_title,
  ...
)

interaction_plot(
  means,
  data,
  mapping = c("shape", "lineytpe"),
  error_plot = TRUE,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom = ggplot2::geom_point,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  dodge = 0.5,
  plot_first = NULL,
  legend_title,
  col_x = "x",
  col_y = "y",
  col_trace = "trace",
  col_panel = "panel",
  col_lower = "lower",
  col_upper = "upper"
)

oneway_plot(
  means,
  data,
  mapping = "",
  error_plot = TRUE,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom = ggbeeswarm::geom_beeswarm,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  plot_first = NULL,
  legend_title,
  col_x = "x",
  col_y = "y",
  col_panel = "panel",
  col_lower = "lower",
  col_upper = "upper"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>afex_aov</code>, <code>mixed</code>, <code>merMod</code> or other model
object supported by <span class="pkg">emmeans</span> (for further examples see:
<code>vignette("afex_plot_supported_models")</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>character</code> vector or one-sided <code>formula</code> specifying the
factor names of the predictors displayed on the x-axis. <code>mapping</code>
specifies further mappings for these factors if <code>trace</code> is missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>An optional <code>character</code> vector or one-sided <code>formula</code>
specifying the factor names of the predictors connected by the same line.
<code>mapping</code> specifies further mappings for these factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>panel</code></td>
<td>
<p>An optional <code>character</code> vector or one-sided <code>formula</code> 
specifying the factor names of the predictors shown in different panels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>A <code>character</code> vector specifying which aesthetic mappings 
should be applied to either the <code>trace</code> factors (if <code>trace</code> is 
specified) or the <code>x</code> factors. Useful options are any combination of 
<code>"shape"</code>, <code>"color"</code>, <code>"linetype"</code>, or also <code>"fill"</code> 
(see examples). The default (i.e., missing) uses <code>c("shape", 
"linetype")</code> if <code>trace</code> is specified and <code>""</code> otherwise (i.e., no
additional aesthetic). If specific mappings should not be applied to
specific graphical elements, one can override those via the corresponding
further arguments. For example, for <code>data_arg</code> the default is
<code>list(color = "darkgrey")</code> which prevents that <code>"color"</code> is
mapped onto points in the background.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>A scalar <code>character</code> vector specifying on which standard 
error the error bars should be based. Default is <code>"model"</code>, which
plots model-based standard errors. Further options are: <code>"none"</code> (or 
<code>NULL</code>), <code>"mean"</code>, <code>"within"</code> (or <code>"CMO"</code>), and 
<code>"between"</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_ci</code></td>
<td>
<p>Logical. Should error bars plot confidence intervals
(=<code>TRUE</code>, the default) or standard errors (=<code>FALSE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_level</code></td>
<td>
<p>Numeric value between 0 and 1 determing the width of the
confidence interval. Default is .95 corresponding to a 95% confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code>geom_errorbar</code>, which draws the errorsbars. Default 
is <code>list(width = 0)</code> which suppresses the vertical bars at the end of 
the error bar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_plot</code></td>
<td>
<p><code>logical</code>. Should raw data be plotted in the 
background? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_geom</code></td>
<td>
<p>Geom <code>function</code> or <code>list</code> of geom functions used
for plotting data in background. The default (missing) uses
<code>geom_point</code> if <code>trace</code> is specified, otherwise
<code>geom_beeswarm</code> (a good alternative in case of many
data points is <code>ggbeeswarm::geom_quasirandom</code>) . See examples fo
further options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_alpha</code></td>
<td>
<p>numeric <code>alpha</code> value between 0 and 1 passed to
<code>data_geom</code>. Default is <code>0.5</code> which correspond to semitransparent
data points in the background such that overlapping data points are plotted
darker. If <code>NULL</code> it is not passed to <code>data_geom</code>, and can be set
via <code>data_arg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_color</code></td>
<td>
<p>color that should be used for the data in the background.
Default is <code>"darkgrey"</code>. If <code>NULL</code> it is not passed to
<code>data_geom</code>, and can be set via <code>data_arg</code>. Ignored if
<code>"color"</code> or <code>"colour"</code> in <code>mapping</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to
<code>data_geom</code>. Can also be a <code>list</code> of <code>list</code>s, in case
<code>data_geom</code> is a <code>list</code> of multiple geoms, which allows having
separate argument lists per <code>data_geom</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point_arg, line_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code>geom_point</code> or <code>geom_line</code> which
draw the points and lines in the foreground. Default is <code>list()</code>.
<code>line_arg</code> is only used if <code>trace</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emmeans_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code>emmeans</code>. Of particular importance for ANOVAs is 
<code>model</code>, see <code>afex_aov-methods</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dodge</code></td>
<td>
<p>Numerical amount of dodging of factor-levels on x-axis. Default 
is <code>0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p>A scalar <code>character</code> specifying what should be returned. 
The default <code>"plot"</code> returns the <span class="pkg">ggplot2</span> plot. The other option 
<code>"data"</code> returns a list with two <code>data.frame</code>s containing the 
data used for plotting: <code>means</code> contains the means and standard errors
for the foreground, <code>data</code> contains the raw data in the background.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor_levels</code></td>
<td>
<p>A <code>list</code> of new factor levels that should be used
in the plot. The name of each list entry needs to correspond to one of the
factors in the plot. Each list element can optionally be a named character
vector where the name corresponds to the old factor level and the value to
the new factor level. Named vectors allow two things: (1) updating only a
subset of factor levels (if only a subset of levels is specified) and (2)
reordering (and renaming) the factor levels, as order of names within a
list element are the order that will be used for plotting. If specified,
emits a <code>message</code> with <code>old -&gt; new</code> factor levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_first</code></td>
<td>
<p>A <code>ggplot2</code> geom (or a list of geoms) that will be
added to the returned plot as a first element (i.e., before any of the
other graphical elements). Useful for adding reference lines or similar
(e.g., using <code>geom_hline</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend_title</code></td>
<td>
<p>A scalar <code>character</code> vector with a new title for the
legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>An optional <code>character</code> vector specifying over which variables
the raw data should be aggregated. Only relevant for <code>mixed</code>, 
<code>merMod</code>, and <code>default</code> method. The default (missing) uses all 
random effects grouping factors (for <code>mixed</code> and <code>merMod</code> method)
or assumes all data points are independent. This can lead to many data
points. <code>error = "within"</code> or <code>error = "between"</code> require that
<code>id</code> is of length 1. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dv</code></td>
<td>
<p>An optional scalar <code>character</code> vector giving the name of the
column containing the dependent variable for the <code>afex_plot.default</code>
method. If missing, the function attempts to take it from the <code>call</code>
slot of <code>object</code>. This is also used as y-axis label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>For the <code>afex_plot.default</code> method, an optional
<code>data.frame</code> containing the raw data used for fitting the model and
which will be used as basis for the data points in the background. If
missing, it will be attempted to obtain it from the model via
<code>recover_data</code>. For the plotting functions, a
<code>data.frame</code> with the data that has to be passed and contains the
background data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within_vars, between_vars</code></td>
<td>
<p>For the <code>afex_plot.default</code> method, an
optional <code>character</code> vector specifying which variables should be
treated as within-subjects (or repeated-measures) factors and which as
between-subjects (or independent-samples) factors. If one of the two
arguments is given, all other factors are assumed to fall into the other
category.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p><code>data.frame</code>s used for plotting of the plotting
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error_plot</code></td>
<td>
<p><code>logical</code>. Should error bars be plotted? Only used in 
plotting functions. To suppress plotting of error bars use <code>error =
"none"</code> in <code>afex_plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_y, col_x, col_trace, col_panel</code></td>
<td>
<p>A scalar <code>character</code> string 
specifying the name of the corresponding column containing the information
used for plotting. Each column needs to exist in both the <code>means</code> and
the <code>data</code> <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_lower, col_upper</code></td>
<td>
<p>A scalar <code>character</code> string specifying the 
name of the columns containing lower and upper bounds for the error bars. 
These columns need to exist in <code>means</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>afex_plot</code> obtains the estimated marginal means via 
<code>emmeans</code> and aggregates the raw data to the same 
level. It then calculates the desired confidence interval or standard error
(see below) and passes the prepared data to one of the two plotting
functions: <code>interaction_plot</code> when <code>trace</code> is specified and 
<code>oneway_plot</code> otherwise.
</p>


<h4>Error Bars</h4>

<p>Error bars provide a grahical representation of the
variability of the estimated means and should be routinely added to results
figures. However, there exist several possibilities which particular 
measure of variability to use. Because of this, any figure depicting error 
bars should be accompanied by a note detailing which measure the error bars
shows. The present functions allow plotting of different types of
confidence intervals (if <code>error_ci = TRUE</code>, the default) or standard 
errors (if <code>error_ci = FALSE</code>).
</p>
<p>A further complication is that readers routinely misinterpret confidence
intervals. The most common error is to assume that non-overlapping error
bars indicate a significant difference (e.g., Belia et al., 2005). This is
often too strong an assumption. (see e.g., Cumming &amp; Finch, 2005; Knol et
al., 2011; Schenker &amp; Gentleman, 2005). For example, in a fully
between-subjects design in which the error bars depict 95% confidence
intervals and groups are of approximately equal size and have equal
variance, even error bars that overlap by as much as 50% still correspond
to <em>p</em> &lt; .05. Error bars that are just touching roughly correspond to
<em>p</em> = .01.
</p>
<p>In the case of designs involving repeated-measures factors the usual
confidence intervals or standard errors (i.e., model-based confidence
intervals or intervals based on the standard error of the mean) cannot be
used to gauge significant differences as this requires knowledge about the
correlation between measures. One popular alternative in the psychological
literature are intervals based on within-subjects standard
errors/confidence intervals (e.g., Cousineau &amp; O'Brien, 2014). These
attempt to control for the correlation across individuals and thereby allow
judging differences between repeated-measures condition. As a downside,
when using within-subjects intervals no comparisons across between-subjects
conditions or with respect to a fixed-value are possible anymore.
</p>
<p>In the case of a mixed-design, no single type of error bar is possible that
allows comparison across all conditions. Likewise, for mixed models
involving multiple <em>crossed</em> random effects, no single set of error
bars (or even data aggregation) adequately represent the true varibility in
the data and adequately allows for "inference by eye". Therefore, special
care is necessary in such cases. One possiblity is to avoid error bars
altogether and plot only the raw data in the background (with <code>error =
  "none"</code>). The raw data in the background still provides a visual impression
of the variability in the data and the precision of the mean estimate, but
does not as easily suggest an incorrect inferences. Another possibility is
to use the model-based standard error and note in the figure caption that
it does not permit comparisons across repeated-measures factors.
</p>
<p>The following "rules of eye" (Cumming and Finch, 2005) hold, when permitted
by design (i.e., within-subjects bars for within-subjects comparisons;
other variants for between-subjects comparisons), and groups are
approximately equal in size and variance. Note that for more complex
designs ususally analyzed with mixed models, such as designs involving
complicated dependencies across data points, these rules of thumbs may be
highly misleading.
</p>

<ul>
<li>  <p><em>p</em> &lt; .05 when the overlap of the 95% confidence intervals
(CIs) is no more than about half the average margin of error, that is,
when proportion overlap is about .50 or less.
</p>
</li>
<li> <p><em>p</em> &lt; .01 when the two CIs do not overlap, that is, when
proportion overlap is about 0 or there is a positive gap.
</p>
</li>
<li>  <p><em>p</em> &lt; .05 when the gap between standard error (SE) bars is at
least about the size of the average SE, that is, when the proportion gap
is about 1 or greater.
</p>
</li>
<li> <p><em>p</em> &lt; .01 when the proportion gap between SE bars is about 2
or more.
</p>
</li>
</ul>
<h4>Implemented Standard Errors</h4>

<p>The following lists the 
implemented approaches to calculate confidence intervals (CIs) and standard
errors (SEs). CIs are based on the SEs using the <em>t</em>-distribution with
degrees of freedom based on the cell or group size. For ANOVA models,
<code>afex_plot</code> attempts to warn in case the chosen approach is misleading
given the design (e.g., model-based error bars for purely
within-subjects plots). For <code>mixed</code> models, no such warnings are
produced, but users should be aware that all options beside <code>"model"</code>
are not actually appropriate and have only heuristic value. But then again,
<code>"model"</code> based error bars do not permit comparisons for factors
varying within one of the random-effects grouping factors (i.e., factors
for which random-slopes should be estimated).
</p>

<dl>
<dt><code>"model"</code></dt>
<dd>
<p>Uses model-based CIs and SEs. For ANOVAs, the
variant based on the <code>lm</code> or <code>mlm</code> model (i.e.,
<code>emmeans_arg = list(model = "multivariate")</code>) seems generally
preferrable.</p>
</dd>
<dt><code>"mean"</code></dt>
<dd>
<p>Calculates the standard error of the mean for
each cell ignoring any repeated-measures factors.</p>
</dd>
<dt>
<code>"within"</code> or <code>"CMO"</code>
</dt>
<dd>
<p>Calculates within-subjects SEs
using the Cosineau-Morey-O'Brien (Cousineau &amp; O'Brien, 2014) method. This
method is based on a double normalization of the data. SEs and CIs are
then calculated independently for each cell (i.e., if the desired output
contains between-subjects factors, SEs are calculated for each cell
including the between-subjects factors).</p>
</dd>
<dt><code>"between"</code></dt>
<dd>
<p>First aggregates the data per participant and 
then calculates the SEs for each between-subjects condition. Results in 
one SE and <em>t</em>-quantile for all conditions in purely within-subjects
designs.</p>
</dd>
<dt>
<code>"none"</code> or <code>NULL</code>
</dt>
<dd>
<p>Suppresses calculation of SEs and
plots no error bars.</p>
</dd>
</dl>
<p>For <code>mixed</code> models, the within-subjects/repeated-measures factors are
relative to the chosen <code>id</code> effects grouping factor. They are
automatically detected based on the random-slopes of the random-effects
grouping factor in <code>id</code>. All other factors are treated as
independent-samples or between-subjects factors.
</p>



<h3>Value</h3>

<p>Returns a <span class="pkg">ggplot2</span> plot (i.e., object of class <code>c("gg",
  "ggplot")</code>) unless <code>return = "data"</code>.
</p>


<h3>Note</h3>

<p>Only the DV/response variable can be called <code>y</code>, but no
factor/variable used for plotting.
</p>


<h3>References</h3>

<p>Belia, S., Fidler, F., Williams, J., &amp; Cumming, G. (2005).
Researchers Misunderstand Confidence Intervals and Standard Error Bars.
<em>Psychological Methods</em>, 10(4), 389-396.
https://doi.org/10.1037/1082-989X.10.4.389
</p>
<p>Cousineau, D., &amp; O'Brien, F. (2014). Error bars in within-subject designs:
a comment on Baguley (2012). <em>Behavior Research Methods</em>, 46(4),
1149-1151. https://doi.org/10.3758/s13428-013-0441-z
</p>
<p>Cumming, G., &amp; Finch, S. (2005). Inference by Eye: Confidence Intervals and
How to Read Pictures of Data. <em>American Psychologist</em>, 60(2), 170-180.
https://doi.org/10.1037/0003-066X.60.2.170
</p>
<p>Knol, M. J., Pestman, W. R., &amp; Grobbee, D. E. (2011). The (mis)use of
overlap of confidence intervals to assess effect modification.
<em>European Journal of Epidemiology</em>, 26(4), 253-254.
https://doi.org/10.1007/s10654-011-9563-8
</p>
<p>Schenker, N., &amp; Gentleman, J. F. (2001). On Judging the Significance of
Differences by Examining the Overlap Between Confidence Intervals.
<em>The American Statistician</em>, 55(3), 182-186.
https://doi.org/10.1198/000313001317097960
</p>


<h3>Examples</h3>

<pre><code class="language-R"># note: use library("ggplot") to avoid "ggplot2::" in the following

##################################################################
##                2-factor Within-Subject Design                ##
##################################################################

data(md_12.1)
aw &lt;- aov_ez("id", "rt", md_12.1, within = c("angle", "noise"))

##---------------------------------------------------------------
##                    Basic Interaction Plots                   -
##---------------------------------------------------------------

## all examples require emmeans and ggplot2:
if (requireNamespace("emmeans") &amp;&amp; requireNamespace("ggplot2")) {

afex_plot(aw, x = "angle", trace = "noise") 
# or: afex_plot(aw, x = ~angle, trace = ~noise)

afex_plot(aw, x = "noise", trace = "angle")

### For within-subject designs, using within-subject CIs is better:
afex_plot(aw, x = "angle", trace = "noise", error = "within") 
(p1 &lt;- afex_plot(aw, x = "noise", trace = "angle", error = "within"))

## use different themes for nicer graphs:
p1 + ggplot2::theme_bw()
}
## Not run: 
p1 + ggplot2::theme_light()
p1 + ggplot2::theme_minimal()
p1 + jtools::theme_apa()
p1 + ggpubr::theme_pubr()

### set theme globally for R session:
ggplot2::theme_set(ggplot2::theme_bw())

### There are several ways to deal with overlapping points in the background besides alpha
# Using the default data geom and ggplot2::position_jitterdodge
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.3,
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 5, 
                dodge.width = 0.3  ## needs to be same as dodge
                )))

# Overlapping points are shown as larger points using geom_count
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
                data_geom = ggplot2::geom_count)

# Using ggbeeswarm::geom_quasirandom (overlapping points shown in violin shape)
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
          data_geom = ggbeeswarm::geom_quasirandom,
          data_arg = list(
            dodge.width = 0.5,  ## needs to be same as dodge
            cex = 0.8, 
            width = 0.05  ## small value ensure data points match means
            ))

# Using ggbeeswarm::geom_beeswarm (overlapping points are adjacent on y-axis)
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
          data_geom = ggbeeswarm::geom_beeswarm,
          data_arg = list(
            dodge.width = 0.5,  ## needs to be same as dodge
            cex = 0.8))

# Do not display points, but use a violinplot: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# violinplots with color: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          mapping = c("linetype", "shape", "fill"),
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# do not display points, but use a boxplot: ggplot2::geom_boxplot
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggplot2::geom_boxplot, 
          data_arg = list(width = 0.3))
          
# combine points with boxplot: ggpol::geom_boxjitter
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(width = 0.3))
## hides error bars!

# nicer variant of ggpol::geom_boxjitter
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.3, 
            jitter.params = list(width = 0, height = 10),
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0))

# nicer variant of ggpol::geom_boxjitter without lines
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.7,
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.5, 
            jitter.params = list(width = 0, height = 10),
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          line_arg = list(linetype = 0),
          error_arg = list(linewidth = 1.5, width = 0))

### we can also use multiple geoms for the background by passing a list of geoms
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = list(
            ggplot2::geom_violin, 
            ggplot2::geom_point
          ))

## with separate extra arguments:

afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          dodge = 0.5,
          data_geom = list(
            ggplot2::geom_violin, 
            ggplot2::geom_point
          ), 
          data_arg = list(
            list(width = 0.4),
            list(position = 
                   ggplot2::position_jitterdodge(
                     jitter.width = 0, 
                     jitter.height = 5, 
                     dodge.width = 0.5  ## needs to be same as dodge
                   )))
          )

## End(Not run)


##---------------------------------------------------------------
##                        One-Way Plots                         -
##---------------------------------------------------------------

## Not run: 
afex_plot(aw, x = "angle", error = "within") ## default

## with color we need larger points
afex_plot(aw, x = "angle", mapping = "color", error = "within", 
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0.05)) 

afex_plot(aw, x = "angle", error = "within", data_geom = ggpol::geom_boxjitter)

## nicer
afex_plot(aw, x = "angle", error = "within", data_geom = ggpol::geom_boxjitter, 
          mapping = "fill", data_alpha = 0.7, 
          data_arg = list(
            width = 0.6, 
            jitter.params = list(width = 0.07, height = 10),
            outlier.intersect = TRUE
          ),
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0.05))

## we can use multiple geoms with separate argument lists:
afex_plot(aw, x = "angle", error = "within", 
          data_geom = 
            list(ggplot2::geom_violin, ggplot2::geom_boxplot), 
          data_arg = 
            list(list(width = 0.7), list(width = 0.1)))

## we can add a line connecting the means using geom_point(aes(group = 1)):
afex_plot(aw, x = "angle", error = "within") +
  ggplot2::geom_line(ggplot2::aes(group = 1))

## we can also add lines connecting the individual data-point in the bg.
# to deal with overlapping points, we use geom_count and make means larger
afex_plot(aw, x = "angle", error = "within", 
          data_geom = list(ggplot2::geom_count, ggplot2::geom_line), 
          data_arg = list(list(), list(mapping = ggplot2::aes(group = id))), 
          point_arg = list(size = 2.5), 
          error_arg = list(width = 0, linewidth = 1.5)) +
  ggplot2::geom_line(ggplot2::aes(group = 1), linewidth = 1.5)

## One-way plots also supports panels:
afex_plot(aw, x = "angle", panel = "noise", error = "within")

## And panels with lines:
afex_plot(aw, x = "angle", panel = "noise", error = "within") +
  ggplot2::geom_line(ggplot2::aes(group = 1))


## For more complicated plots it is easier to attach ggplot2:
library("ggplot2")

## We can hide geoms by plotting them in transparent colour and add them
## afterward to use a mapping not directly supported. 
## For example, the next plot adds a line to a one-way plot with panels, but 
## with all geoms in the foreground having a colour conditional on the panel.

afex_plot(aw, x = "angle", panel = "noise", error = "within", 
          point_arg = list(color = "transparent"), 
          error_arg = list(color = "transparent")) +
  geom_point(aes(color = panel)) +
  geom_linerange(aes(color = panel, ymin = lower, ymax = upper)) + 
  geom_line(aes(group = 1, color = panel)) +
  guides(color = guide_legend(title = "NOISE"))
## Note that we need to use guides explicitly, otherwise the legend title would 
## be "panel". legend_title does not work in this case.

##---------------------------------------------------------------
##                      Other Basic Options                     -
##---------------------------------------------------------------

## relabel factor levels via factor_levels (with message)
afex_plot(aw, x = "noise", trace = "angle", 
          factor_levels = list(angle = c("0°", "4°", "8°"),
                               noise = c("Absent", "Present")))

## factor_levels allows named vectors which enable reordering the factor levels 
### and renaming subsets of levels:
afex_plot(aw, x = "noise", trace = "angle", 
          factor_levels = list(
            angle = c(X8 = "8°", X4 = "4°", X0 = "0°"),
            noise = c(present = "Present")
          )
)


## Change title of legend
afex_plot(aw, x = "noise", trace = "angle", 
          legend_title = "Noise Condition")

## Add reference line in the background
afex_plot(aw, x = "noise", trace = "angle", 
          plot_first = ggplot2::geom_hline(yintercept = 450, 
                                            colour = "darkgrey"))

## for plots with few factor levels, smaller dodge might be better:
afex_plot(aw, x = "angle", trace = "noise", dodge = 0.25) 

#################################################################
##                    4-factor Mixed Design                    ##
#################################################################

data(obk.long, package = "afex")
a1 &lt;- aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
              data = obk.long, observed = "gender")

## too difficult to see anything
afex_plot(a1, ~phase*hour, ~treatment) +
  ggplot2::theme_light()

## better
afex_plot(a1, ~hour, ~treatment, ~phase) +
  ggplot2::theme_light()

## even better
afex_plot(a1, ~hour, ~treatment, ~phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey")) +
  ggplot2::theme_classic()

# with color instead of linetype to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = c("shape", "color"),
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ))) +
  ggplot2::theme_light()

# only color to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = c("color"),
          dodge = 0.65, 
          data_color = NULL,  ## needs to be set to NULL to avoid error
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ))) +
  ggplot2::theme_classic()


## plot involving all 4 factors:
afex_plot(a1, ~hour, ~treatment, ~gender+phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey")) +
  ggplot2::theme_bw()


##---------------------------------------------------------------
##              Different Standard Errors Available             -
##---------------------------------------------------------------

## purely within-design
cbind(
  afex_plot(a1, ~phase, ~hour, 
            error = "model", return = "data")$means[,c("phase", "hour", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~hour,
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~hour, 
                    error = "mean", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~hour, 
                     error = "within", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~hour, 
                      error = "between", return = "data")$means$error)
## mixed design
cbind(
  afex_plot(a1, ~phase, ~treatment, 
            error = "model", return = "data")$means[,c("phase", "treatment", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~treatment,
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~treatment, 
                    error = "mean", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~treatment, 
                     error = "within", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~treatment, 
                      error = "between", return = "data")$means$error)

## End(Not run)

##################################################################
##                         Mixed Models                         ##
##################################################################
if (requireNamespace("MEMSS") &amp;&amp; 
    requireNamespace("emmeans") &amp;&amp; 
    requireNamespace("ggplot2")) {

data("Machines", package = "MEMSS") 
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines)
pairs(emmeans::emmeans(m1, "Machine"))
# contrast   estimate       SE df t.ratio p.value
# A - B     -7.966667 2.420850  5  -3.291  0.0481
# A - C    -13.916667 1.540100  5  -9.036  0.0007
# B - C     -5.950000 2.446475  5  -2.432  0.1253

## Default (i.e., model-based) error bars suggest no difference between Machines.
## This contrasts with pairwise comparisons above.
afex_plot(m1, "Machine")

## Impression from within-subject error bars is more in line with pattern of differences.
afex_plot(m1, "Machine", error = "within")
}

## Not run: 
data("fhch2010") # load 
fhch &lt;- droplevels(fhch2010[ fhch2010$correct,]) # remove errors
### following model should take less than a minute to fit:
mrt &lt;- mixed(log_rt ~ task*stimulus*frequency + (stimulus*frequency||id)+
               (task||item), fhch, method = "S", expand_re = TRUE)

## way too many points in background:
afex_plot(mrt, "stimulus", "frequency", "task") 

## better to restrict plot of data to one random-effects grouping variable
afex_plot(mrt, "stimulus", "frequency", "task", id = "id")
## when plotting data from a single random effect, different error bars are possible:
afex_plot(mrt, "stimulus", "frequency", "task", id = "id", error = "within")
afex_plot(mrt, "stimulus", "frequency", "task", id = "id", error = "mean")

## compare visual impression with:
pairs(emmeans::emmeans(mrt, c("stimulus", "frequency"), by = "task"))

## same logic also possible for other random-effects grouping factor
afex_plot(mrt, "stimulus", "frequency", "task", id = "item")
## within-item error bars are misleading here. task is sole within-items factor.
afex_plot(mrt, "stimulus", "frequency", "task", id = "item", error = "within")
## CIs based on standard error of mean look small, but not unreasonable given results.
afex_plot(mrt, "stimulus", "frequency", "task", id = "item", error = "mean")

### compare distribution of individual data for different random effects:
## requires package cowplot
p_id &lt;- afex_plot(mrt, "stimulus", "frequency", "task", id = "id", 
                  error = "within", dodge = 0.7,
                  data_geom = ggplot2::geom_violin, 
                  mapping = c("shape", "fill"),
                  data_arg = list(width = 0.7)) +
  ggplot2::scale_shape_manual(values = c(4, 17)) +
  ggplot2::labs(title = "ID")

p_item &lt;- afex_plot(mrt, "stimulus", "frequency", "task", id = "item", 
          error = "within", dodge = 0.7,
          data_geom = ggplot2::geom_violin, 
          mapping = c("shape", "fill"),
          data_arg = list(width = 0.7)) +
  ggplot2::scale_shape_manual(values = c(4, 17)) +
  ggplot2::labs(title = "Item")

### see: https://cran.r-project.org/package=cowplot/vignettes/shared_legends.html
p_comb &lt;- cowplot::plot_grid(
  p_id + ggplot2::theme_light() + ggplot2::theme(legend.position="none"),
  p_item + ggplot2::theme_light() + ggplot2::theme(legend.position="none")
  )
legend &lt;- cowplot::get_legend(p_id + ggplot2::theme(legend.position="bottom"))
cowplot::plot_grid(p_comb, legend, 
                   ncol = 1, 
                   rel_heights = c(1, 0.1))

##----------------------------------------------------------------
##                    Support for lme4::lmer                     -
##----------------------------------------------------------------

Oats &lt;- nlme::Oats
## afex_plot does currently not support implicit nesting: (1|Block/Variety)
## Instead, we need to create the factor explicitly
Oats$VarBlock &lt;- Oats$Variety:Oats$Block
Oats.lmer &lt;- lmer(yield ~ Variety * factor(nitro) + (1|VarBlock) + (1|Block),
                        data = Oats)
afex_plot(Oats.lmer, "nitro", "Variety")
afex_plot(Oats.lmer, "nitro", panel = "Variety")

##################################################################
##     Default Method works for Models Supported by emmeans     ##
##################################################################

## lm
warp.lm &lt;- lm(breaks ~ wool * tension, data = warpbreaks)
afex_plot(warp.lm, "tension")
afex_plot(warp.lm, "tension", "wool")

## poisson glm
ins &lt;- data.frame(
    n = c(500, 1200, 100, 400, 500, 300),
    size = factor(rep(1:3,2), labels = c("S","M","L")),
    age = factor(rep(1:2, each = 3)),
    claims = c(42, 37, 1, 101, 73, 14))
ins.glm &lt;- glm(claims ~ size + age + offset(log(n)), 
               data = ins, family = "poisson")
afex_plot(ins.glm, "size", "age")

## binomial glm adapted from ?predict.glm
ldose &lt;- factor(rep(0:5, 2))
numdead &lt;- c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16)
sex &lt;- factor(rep(c("M", "F"), c(6, 6)))
SF &lt;- numdead/20  ## dv should be a vector, no matrix
budworm.lg &lt;- glm(SF ~ sex*ldose, family = binomial, 
                  weights = rep(20, length(numdead)))
afex_plot(budworm.lg, "ldose")
afex_plot(budworm.lg, "ldose", "sex") ## data point is hidden behind mean!
afex_plot(budworm.lg, "ldose", "sex", 
          data_arg = list(size = 4, color = "red"))

## nlme mixed model
data(Oats, package = "nlme")
Oats$nitro &lt;- factor(Oats$nitro)
oats.1 &lt;- nlme::lme(yield ~ nitro * Variety, 
                    random = ~ 1 | Block / Variety,
                    data = Oats)
afex_plot(oats.1, "nitro", "Variety", data = Oats)
afex_plot(oats.1, "nitro", "Variety", data = Oats, id = "Block")
afex_plot(oats.1, "nitro", data = Oats)
afex_plot(oats.1, "nitro", data = Oats, id = c("Block", "Variety"))
afex_plot(oats.1, "nitro", data = Oats, id = "Block")


## End(Not run)
</code></pre>


</div>