<div class="container">

<table style="width: 100%;"><tr>
<td>mineCARs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mine Class Association Rules</h2>

<h3>Description</h3>

<p>Class Association Rules (CARs) are association rules that have only items
with class values in the RHS as introduced for the CBA algorithm by Liu et
al., 1998.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mineCARs(
  formula,
  transactions,
  parameter = NULL,
  control = NULL,
  balanceSupport = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transactions</code></td>
<td>
<p>An object of class arules::transactions
containing the training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter, control</code></td>
<td>
<p>Optional parameter and control lists for
<code>arules::apriori()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balanceSupport</code></td>
<td>
<p>logical; if <code>TRUE</code>, class imbalance is
counteracted by using class specific minimum support values. Alternatively,
a support value for each class can be specified (see Details section).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; report progress?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For convenience, the mining parameters for <code>arules::apriori()</code> can be
specified as .... Examples are the <code>support</code> and <code>confidence</code>
thresholds, and the <code>maxlen</code> of rules.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Class association rules (CARs) are of the form
</p>
<p style="text-align: center;"><code class="reqn">P \Rightarrow c_i,</code>
</p>

<p>where the LHS <code class="reqn">P</code> is a pattern (i.e., an itemset) and <code class="reqn">c_i</code> is a
single items representing the class label.
</p>
<p><strong>Mining parameters.</strong>
Mining parameters for
<code>arules::apriori()</code> can be either specified as a list (or object
of arules::APparameter) as argument <code>parameter</code> or, for
convenience, as arguments in <code>...</code>.
<em>Note:</em> <code>mineCARs()</code> uses
by default a minimum support of 0.1 (for the LHS of the rules via parameter
<code>originalSupport = FALSE</code>),
a minimum confidence of 0.5 and a <code>maxlen</code> (rule
length including items in the LHS and RHS) of 5.
</p>
<p><strong>Balancing minimum support.</strong>
Using a single minimum support threshold
for a highly class imbalanced dataset will lead to the problem, that
minority classes will only be presented in very few rules. To address this
issue, <code>balanceSupport = TRUE</code> can be used to adjust minimum support
for each class dependent on the prevalence of the class (i.e., the frequency
of the <code class="reqn">c_i</code> in the transactions) similar to the minimum class support
suggested for CBA by Liu et al (2000) we use
</p>
<p style="text-align: center;"><code class="reqn">minsupp_i = minsupp_t
  \frac{supp(c_i)}{max(supp(C))},</code>
</p>

<p>where <code class="reqn">max(supp(C))</code> is the support of the majority class. Therefore,
the defined minimum support is used for the majority class and then minimum
support is scaled down for classes which are less prevalent, giving them a
chance to also produce a reasonable amount of rules. In addition, a named
numerical vector with a support values for each class can be specified.
</p>


<h3>Value</h3>

<p>Returns an object of class arules::rules.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Liu, B. Hsu, W. and Ma, Y (1998). Integrating Classification and
Association Rule Mining. <em>KDD'98 Proceedings of the Fourth
International Conference on Knowledge Discovery and Data Mining,</em> New York,
27-31 August. AAAI. pp. 80-86.
</p>
<p>Liu B., Ma Y., Wong C.K. (2000) Improving an Association Rule Based
Classifier. In: Zighed D.A., Komorowski J., Zytkow J. (eds) <em>Principles
of Data Mining and Knowledge Discovery. PKDD 2000. Lecture Notes in Computer
Science</em>, vol 1910. Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p>Other preparation: 
<code>CBA_ruleset()</code>,
<code>discretizeDF.supervised()</code>,
<code>prepareTransactions()</code>,
<code>transactions2DF()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("iris")

# discretize and convert to transactions
iris.trans &lt;- prepareTransactions(Species ~ ., iris)

# mine CARs with items for "Species" in the RHS.
# Note: mineCars uses a default a minimum coverage (lhs support) of 0.1, a
#       minimum confidence of .5 and maxlen of 5
cars &lt;- mineCARs(Species ~ ., iris.trans)
inspect(head(cars))

# specify minimum support and confidence
cars &lt;- mineCARs(Species ~ ., iris.trans,
  parameter = list(support = 0.3, confidence = 0.9, maxlen = 3))
inspect(head(cars))

# for convenience this can also be written without a list for parameter using ...
cars &lt;- mineCARs(Species ~ ., iris.trans, support = 0.3, confidence = 0.9, maxlen = 3)

# restrict the predictors to items starting with "Sepal"
cars &lt;- mineCARs(Species ~ Sepal.Length + Sepal.Width, iris.trans)
inspect(cars)

# using different support for each class
cars &lt;- mineCARs(Species ~ ., iris.trans, balanceSupport = c(
  "Species=setosa" = 0.1,
  "Species=versicolor" = 0.5,
  "Species=virginica" = 0.01), confidence = 0.9)
cars

# balance support for class imbalance
data("Lymphography")
Lymphography_trans &lt;- as(Lymphography, "transactions")

classFrequency(class ~ ., Lymphography_trans)

# mining does not produce CARs for the minority classes
cars &lt;- mineCARs(class ~ ., Lymphography_trans, support = .3, maxlen = 3)
classFrequency(class ~ ., cars, type = "absolute")

# Balance support by reducing the minimum support for minority classes
cars &lt;- mineCARs(class ~ ., Lymphography_trans, support = .3, maxlen = 3,
  balanceSupport = TRUE)
classFrequency(class ~ ., cars, type = "absolute")

# Mine CARs from regular transactions (a negative class item is automatically added)
data(Groceries)
cars &lt;- mineCARs(`whole milk` ~ ., Groceries,
  balanceSupport = TRUE, support = 0.01, confidence = 0.8)
inspect(sort(cars, by = "lift"))
</code></pre>


</div>