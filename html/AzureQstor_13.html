<div class="container">

<table style="width: 100%;"><tr>
<td>QueueMessage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class representing a message from an Azure storage queue</h2>

<h3>Description</h3>

<p>This class stores the data, metadata and behaviour associated with a message.
</p>
<p>To generate a message object, call one of the methods exposed by the <code>StorageQueue</code> class.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>queue</code></dt>
<dd>
<p>The queue this message is from, an object of class <code>StorageQueue</code></p>
</dd>
<dt><code>id</code></dt>
<dd>
<p>The message ID.</p>
</dd>
<dt><code>insertion_time</code></dt>
<dd>
<p>The message insertion (creation) time.</p>
</dd>
<dt><code>expiry_time</code></dt>
<dd>
<p>The message expiration time.</p>
</dd>
<dt><code>text</code></dt>
<dd>
<p>The message text.</p>
</dd>
<dt><code>receipt</code></dt>
<dd>
<p>A pop receipt. This is present if the message was obtained by means other than peeking, and is required for updating or deleting the message.</p>
</dd>
<dt><code>next_visible_time</code></dt>
<dd>
<p>The time when this message will be next visible.</p>
</dd>
<dt><code>dequeue_count</code></dt>
<dd>
<p>The number of times this message has been read.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>QueueMessage$new()</code></a>
</p>
</li>
<li> <p><a href="#method-delete"><code>QueueMessage$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-update"><code>QueueMessage$update()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>QueueMessage$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>QueueMessage$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new message object. Rather than calling the <code>new</code> method manually, objects of this class should be created via the methods exposed by the <code>StorageQueue</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$new(message, queue)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>message</code></dt>
<dd>
<p>Details about the message.</p>
</dd>
<dt><code>queue</code></dt>
<dd>
<p>Object of class <code>StorageQueue</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-delete"></a>



<h4>Method <code>delete()</code>
</h4>

<p>Deletes this message from the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$delete()</pre></div>



<h5>Returns</h5>

<p>NULL, invisibly.
</p>


<hr>
<a id="method-update"></a>



<h4>Method <code>update()</code>
</h4>

<p>Updates this message in the queue.
</p>
<p>This operation can be used to continually extend the invisibility of a queue message. This functionality can be useful if you want a worker role to "lease" a message. For example, if a worker role calls <code>get_messages</code> and recognizes that it needs more time to process a message, it can continually extend the message's invisibility until it is processed. If the worker role were to fail during processing, eventually the message would become visible again and another worker role could process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$update(visibility_timeout, text = self$text)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>visibility_timeout</code></dt>
<dd>
<p>The new visibility timeout (time to when the message will again be visible).</p>
</dd>
<dt><code>text</code></dt>
<dd>
<p>Optionally, new message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print method for this class.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Not currently used.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

endp &lt;- storage_endpoint("https://mystorage.queue.core.windows.net", key="key")
queue &lt;- storage_queue(endp, "queue1")

msg &lt;- queue$get_message()
msg$update(visibility_timeout=60, text="updated message")
msg$delete()


## End(Not run)
</code></pre>


</div>