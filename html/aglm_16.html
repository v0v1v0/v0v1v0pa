<div class="container">

<table style="width: 100%;"><tr>
<td>plot.AccurateGLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot contribution of each variable and residuals</h2>

<h3>Description</h3>

<p>Plot contribution of each variable and residuals
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'AccurateGLM'
plot(
  x,
  vars = NULL,
  verbose = TRUE,
  s = NULL,
  resid = FALSE,
  smooth_resid = TRUE,
  smooth_resid_fun = NULL,
  ask = TRUE,
  layout = c(2, 2),
  only_plot = FALSE,
  main = "",
  add_rug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A model object obtained from <code>aglm()</code> or <code>cv.aglm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>Used to specify variables to be plotted (<code>NULL</code> means all the variables).
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>integer</code>: specifying variables by index.
</p>
</li>
<li> <p><code>character</code>: specifying variables by name.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Set to <code>FALSE</code> if textual outputs are not needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>A numeric value specifying <code class="reqn">\lambda</code> at which plotting is required.
Note that plotting for multiple <code class="reqn">\lambda</code>'s are not allowed and <code>s</code> always should be a single value.
When the model is trained with only a single <code class="reqn">\lambda</code> value, just set it to <code>NULL</code> to plot for that value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid</code></td>
<td>
<p>Used to display residuals in plots.
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>logical</code>(single value): If <code>TRUE</code>, working residuals are plotted.
</p>
</li>
<li> <p><code>character</code>(single value): type of residual to be plotted. See residuals.AccurateGLM for more details on types of residuals.
</p>
</li>
<li> <p><code>numerical</code>(vector): residual values to be plotted.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth_resid</code></td>
<td>
<p>Used to display smoothing lines of residuals for quantitative variables.
This parameter may have one of the following classes:
</p>

<ul>
<li> <p><code>logical</code>: If <code>TRUE</code>, smoothing lines are drawn.
</p>
</li>
<li> <p><code>character</code>:
</p>

<ul>
<li> <p><code>smooth_resid="both"</code>: Balls and smoothing lines are drawn.
</p>
</li>
<li> <p><code>smooth_resid="smooth_only"</code>: Only smoothing lines are drawn.
</p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth_resid_fun</code></td>
<td>
<p>Set if users need custom smoothing functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>By default, <code>plot()</code> stops and waits inputs each time plotting for each variable is completed.
Users can set <code>ask=FALSE</code> to avoid this.
It is useful, for example, when using devices as <code>bmp</code> to create image files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layout</code></td>
<td>
<p>Plotting multiple variables for each page is allowed.
To achieve this, set it to a pair of integer, which indicating number of rows and columns, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only_plot</code></td>
<td>
<p>Set to <code>TRUE</code> if no automatic graphical configurations are needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>Used to specify the title of plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_rug</code></td>
<td>
<p>Set to <code>TRUE</code> for rug plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments are currently not used and just discarded.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>


<ul>
<li>
<p> Kenji Kondo,
</p>
</li>
<li>
<p> Kazuhisa Takahashi and Hikari Banno (worked on L-Variable related features)
</p>
</li>
</ul>
<h3>References</h3>

<p>Suguru Fujita, Toyoto Tanaka, Kenji Kondo and Hirokazu Iwasawa. (2020)
<em>AGLM: A Hybrid Modeling Method of GLM and Data Science Techniques</em>, <br><a href="https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1">https://www.institutdesactuaires.com/global/gene/link.php?doc_id=16273&amp;fg=1</a> <br><em>Actuarial Colloquium Paris 2020</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#################### using plot() and predict() ####################

library(MASS) # For Boston
library(aglm)

## Read data
xy &lt;- Boston # xy is a data.frame to be processed.
colnames(xy)[ncol(xy)] &lt;- "y" # Let medv be the objective variable, y.

## Split data into train and test
n &lt;- nrow(xy) # Sample size.
set.seed(2018) # For reproducibility.
test.id &lt;- sample(n, round(n/4)) # ID numbders for test data.
test &lt;- xy[test.id,] # test is the data.frame for testing.
train &lt;- xy[-test.id,] # train is the data.frame for training.
x &lt;- train[-ncol(xy)]
y &lt;- train$y
newx &lt;- test[-ncol(xy)]
y_true &lt;- test$y

## With the result of aglm()
model &lt;- aglm(x, y)
lambda &lt;- 0.1

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)

## With the result of cv.aglm()
model &lt;- cv.aglm(x, y)
lambda &lt;- model@lambda.min

plot(model, s=lambda, resid=TRUE, add_rug=TRUE,
     verbose=FALSE, layout=c(3, 3))

y_pred &lt;- predict(model, newx=newx, s=lambda)
plot(y_true, y_pred)


</code></pre>


</div>