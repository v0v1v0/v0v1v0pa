<div class="container">

<table style="width: 100%;"><tr>
<td>predictSE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computing Predicted Values and Standard Errors
</h2>

<h3>Description</h3>

<p>Function to compute predicted values based on linear predictor and
associated standard errors from various fitted models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">predictSE(mod, newdata, se.fit = TRUE, print.matrix = FALSE, ...)

## S3 method for class 'gls'
predictSE(mod, newdata, se.fit = TRUE, print.matrix = 
        FALSE, ...) 

## S3 method for class 'lme'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, ...)

## S3 method for class 'mer'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, type = "response", ...)

## S3 method for class 'merMod'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, type = "response", ...)

## S3 method for class 'lmerModLmerTest'
predictSE(mod, newdata, se.fit = TRUE, print.matrix =
        FALSE, level = 0, ...)

## S3 method for class 'unmarkedFitPCount'
predictSE(mod, newdata, se.fit = TRUE,
        print.matrix = FALSE, type = "response", c.hat = 1, parm.type =
        "lambda", ...)

## S3 method for class 'unmarkedFitPCO'
predictSE(mod, newdata, se.fit = TRUE, 
        print.matrix = FALSE, type = "response", c.hat = 1,
        parm.type = "lambda", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>

<p>an object of class <code>gls</code>, <code>lme</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code>, <code>unmarkedFitPCount</code>,
or <code>unmarkedFitPCO</code> containing the output of a model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>a data frame with the same structure as that of the original data
frame for which we want to make predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>

<p>logical.  If <code>TRUE</code>, compute standard errors on predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.matrix</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the output is returned as a matrix, with
predicted values and standard errors in columns.  If <code>FALSE</code>,
the output is returned as a list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
 
<p>the level for which predicted values and standard errors are to be
computed.  The current version of the function only supports
predictions for the populations excluding random effects (i.e.,
<code>level = 0</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>specifies the type of prediction requested.  This argument can take
the value <code>response</code> or <code>link</code>, for predictions on the
scale of the response variable or on the scale of the linear
predictor, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.hat</code></td>
<td>

<p>value of overdispersion parameter (i.e., variance inflation factor)
such as that obtained from <code>Nmix.gof.test</code>.  If <code>c.hat &gt;
    1</code>, <code>predictSE</code> will multiply the variance-covariance matrix of
the predictions by this value (i.e., SE's are multiplied by
<code>sqrt(c.hat)</code>).  High values of <code>c.hat</code> (e.g., <code>c.hat
    &gt; 4</code>) may indicate that model structure is inappropriate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm.type</code></td>
<td>
 
<p>the parameter for which predictions are made based on the
<em>N</em>-mixture model of class <code>unmarkedFitPCount</code> or
<code>unmarkedFitPCO</code> classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments passed to the function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>predictSE</code> computes predicted values and associated standard
errors.  Standard errors are approximated using the delta method
(Oehlert 1992).  Predictions and standard errors for objects of
<code>gls</code> class and mixed models of <code>lme</code>, <code>mer</code>,
<code>merMod</code>, <code>lmerModLmerTest</code> classes exclude the
correlation or variance structure of the model.
</p>
<p><code>predictSE</code> computes predicted values on abundance and standard
errors based on the estimates from an <code>unmarkedFitPCount</code> or
<code>unmarkedFitPCO</code> object.  Currently, only predictions on
abundance (i.e., <code>parm.type = "lambda"</code>) with the zero-inflated
Poisson distribution is supported.  For other parameters or
distributions for models of <code>unmarkedFit</code> classes, use
<code>predict</code> from the <code>unmarked</code> package. 
</p>


<h3>Value</h3>

<p><code>predictSE</code> returns requested values either as a matrix
(<code>print.matrix = TRUE</code>) or list (<code>print.matrix = FALSE</code>)
with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>the predicted values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>

<p>the standard errors of the predicted values (if <code>se.fit = TRUE</code>). 
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For standard errors with better properties, especially for small
samples, one can opt for simulations (see Gelman and Hill 2007), or
nonparametric bootstrap (Efron and Tibshirani 1998).
</p>


<h3>Author(s)</h3>

<p>Marc J. Mazerolle
</p>


<h3>References</h3>

<p>Efron, B., Tibshirani, R. J. (1998) <em>An Introduction to the
Bootstrap</em>. Chapman &amp; Hall/CRC: New York. 
</p>
<p>Gelman, A., Hill, J. (2007) <em>Data Analysis Using Regression and
Multilevel/Hierarchical Models</em>. Cambridge University Press: New York. 
</p>
<p>Oehlert, G. W. (1992) A note on the delta method. <em>American
Statistician</em> <b>46</b>, 27â€“29.
</p>


<h3>See Also</h3>

<p><code>gls</code>, <code>lme</code>, <code>glmer</code>,
<code>simulate.merMod</code>, <code>boot</code>,
<code>parboot</code>, <code>nonparboot</code>,
<code>pcount</code>, <code>pcountOpen</code>,
<code>unmarkedFit-class</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">##Orthodont data from Pinheiro and Bates (2000) revisited
## Not run: 
require(nlme)
m1 &lt;- gls(distance ~ age, correlation = corCompSymm(value = 0.5, form = ~ 1 | Subject),
          data = Orthodont, method= "ML")

##compare against lme fit
logLik(m1)
logLik(lme(distance ~ age, random = ~1 | Subject, data = Orthodont,
          method= "ML"))
##both are identical


##compute predictions and SE's for different ages
predictSE(m1, newdata = data.frame(age = c(8, 10, 12, 14)))
detach(package:nlme)

## End(Not run)


##example with mallard data set from unmarked package
## Not run: 
require(unmarked)
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
                                  obsCovs = mallard.obs)
##run model with zero-inflated Poisson abundance
fm.mall.one &lt;- pcount(~ ivel + date  ~ length + forest, mallardUMF, K=30,
                      mixture = "ZIP")
##make prediction
predictSE(fm.mall.one, type = "response", parm.type = "lambda",
          newdata = data.frame(length = 0, forest = 0, elev = 0))
##compare against predict
predict(fm.mall.one, type = "state", backTransform = TRUE,
        newdata = data.frame(length = 0, forest = 0, elev = 0))

##add offset in model to scale abundance per transect length
fm.mall.off &lt;- pcount(~ ivel + date  ~ forest + offset(length), mallardUMF, K=30,
                      mixture = "ZIP")
##make prediction
predictSE(fm.mall.off, type = "response", parm.type = "lambda",
          newdata = data.frame(length = 10, forest = 0, elev = 0))
##compare against predict
predict(fm.mall.off, type = "state", backTransform = TRUE,
        newdata = data.frame(length = 10, forest = 0, elev = 0))
detach(package:unmarked)

## End(Not run)
</code></pre>


</div>