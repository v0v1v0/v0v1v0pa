<div class="container">

<table style="width: 100%;"><tr>
<td>Negate DNF/SOP expressions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Negate Boolean expressions</h2>

<h3>Description</h3>

<p>Functions to negate a DNF/SOP expression, or to invert a SOP to a negated POS or
a POS to a negated SOP.
</p>


<h3>Usage</h3>

<pre><code class="language-R">negate(input, snames = "", noflevels, simplify = TRUE, ...)

invert(input, snames = "", noflevels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>A string representing a SOP expression, or a minimization
object of class <code>"QCA_min"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>Logical, allow users to choose between the raw negation or
its simplest form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments (mainly for backwards compatibility).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In Boolean algebra, there are two transformation rules named after the British
mathematician Augustus De Morgan. These rules state that:
</p>
<p>1. The complement of the union of two sets is the intersection of their complements.
</p>
<p>2. The complement of the intersection of two sets is the union of their complements.
</p>
<p>In "normal" language, these would be written as:
</p>
<p>1. <code>not (A and B) = (not A) or (not B)</code>
</p>
<p>2. <code>not (A or B) = (not A) and (not B)</code>
</p>
<p>Based on these two laws, any Boolean expression written in disjunctive normal
form can be transformed into its negation.
</p>
<p>It is also possible to negate all models and solutions from the result of a
Boolean minimization from function <b><code>minimize()</code></b> in
package <b><code>QCA</code></b>. The resulting object, of class <code>"qca"</code>, is
automatically recognised by this function.
</p>
<p>In a SOP expression, the products should normally be split by using a star
<b><code>*</code></b> sign, otherwise the sets' names will be considered the individual
letters in alphabetical order, unless they are specified via <b><code>snames</code></b>.
</p>
<p>To negate multilevel expressions, the argument <b><code>noflevels</code></b> is required.
</p>
<p>It is entirely possible to obtain multiple negations of a single expression, since
the result of the negation is passed to function <b><code>simplify()</code></b>.
</p>
<p>Function <b><code>invert</code>()</b> simply transforms an expression from a sum of
products (SOP) to a negated product of sums (POS), and the other way round.
</p>


<h3>Value</h3>

<p>A character vector when the input is a SOP expresison, or a named list for
minimization input objects, each component containing all possible negations of
the model(s).
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, Charles C. 1987. <em>The Comparative Method: Moving beyond Qualitative 
and Quantitative Strategies</em>. Berkeley: University of California Press.
</p>


<h3>See Also</h3>

<p><code>minimize</code>, <code>simplify</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# example from Ragin (1987, p.99)
negate(AC + B~C, simplify = FALSE)

# the simplified, logically equivalent negation
negate(AC + B~C)

# with different intersection operators
negate(AB*EF + ~CD*EF)

# invert to POS
invert(a*b + ~c*d)

## Not run: 
# using an object of class "qca" produced with minimize()
# from package QCA
library(QCA)
cLC &lt;- minimize(LC, outcome = SURV)

negate(cLC)


# parsimonious solution
pLC &lt;- minimize(LC, outcome = SURV, include = "?")

negate(pLC)

## End(Not run)
</code></pre>


</div>