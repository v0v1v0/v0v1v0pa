<div class="container">

<table style="width: 100%;"><tr>
<td>matcond</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>matcond</h2>

<h3>Description</h3>

<p>Works out two alternative condition numbers for the transform associated to the prediction scheme given in the arguments to the function. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">matcond(x, f, Pred, neigh, int, clo, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and <code>AdaptNeigh</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If <span class="env">clo</span> is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">clo</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses the transform matrices to work out their norms and singular value decompositions.  Condition numbers are calculated by <code class="reqn">||T_j ||*||T_j^{-1} ||</code> and <code>svd$d[1]/svd$d[nrow(T_j)]</code> respectively.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cno</code></td>
<td>
<p>the condition numbers for the augmented transform matrices, calculated using the Frobenius norm (see condno).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>the condition numbers for the augmented transform matrices, calculated using the ratio between the largest to the smallest singular values in the singular value decomposition of the augmented matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>the transform matrix information for the transform (output from fwtnp).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight </p>


<h3>See Also</h3>

<p><code>condno</code>, <code>fwtnp</code>     </p>


<h3>Examples</h3>

<pre><code class="language-R">x1&lt;-runif(256)
y1&lt;-make.signal2("doppler",x=x1)
#
m&lt;-matcond(x1,y1,AdaptNeigh,2,TRUE,TRUE,2)
#
m$cno
#
m$v
# shows the two different condition number measures for the matrix associated
# to the transform performed.
#
</code></pre>


</div>