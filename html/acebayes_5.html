<div class="container">

<table style="width: 100%;"><tr>
<td>acenlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Approximate Coordinate Exchange (ACE) Algorithm for Non-Linear Models
</h2>

<h3>Description</h3>

<p>Functions implementing the approximate coordinate exchange algorithm (Overstall &amp; Woods, 2017) for finding optimal Bayesian designs for non-linear regression models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">acenlm(formula, start.d, prior, B, criterion = c("D", "A", "E", "SIG", "NSEL"), 
method = c("quadrature", "MC"),  Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
progress = FALSE, limits = NULL)

pacenlm(formula, start.d, prior, B, criterion = c("D", "A", "E", "SIG", "NSEL"), 
method = c("quadrature", "MC"),  Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, mc.cores = 1, n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>An object of class <code>"formula"</code>: a symbolic description of the model. The terms should correspond to the column names of the argument <code>start.d</code> and the argument <code>prior</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>For <code>aceglm</code>, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for the ACE algorithm.
</p>
<p>For <code>paceglm</code>, a list with each element, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for each repetition of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>An argument specifying the prior distribution.  	
</p>
<p>For <code>method = "MC"</code>, a function with one argument: <code>B</code>; a scalar integer. This function should return a <code>B</code> by <code>p</code> matrix (or <code>p+1</code> for <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code>), with <code>p</code> the number of model parameters, containing a random sample from the prior distribution of the parameters. The value of <code>p</code> should correspond to the number of terms specified by the <code>formula</code> argument. The column names must match the names of parameters in the <code>formula</code> argument. For <code>criterion="SIG"</code> or <code>criterion="NSEL"</code>, an extra column (named <code>sig2</code>) should contain a sample from the prior distribution of the error variance.
</p>
<p>For <code>method = "quadrature"</code>, a list specifying a normal or uniform prior for the model parameters. For a normal prior distribution, the list should have named entries <code>mu</code> and <code>sigma2</code> specifying the prior mean and variance-covariance matrix. The prior mean may be specified as a scalar, which will then be replicated to form an vector of common prior means, or a vector of length <code>p</code>. The prior variance-covariance matrix may be specified as either a scalar common variance or a vector of length <code>p</code> of variances (for independent prior distributions) or as a <code>p</code> by <code>p</code> matrix. The names attribute of <code>mu</code> must match the names of the parameters in the <code>formula</code> argument. For a uniform prior distribution, the list should have a named entry <code>support</code>, a <code>2</code> by <code>p</code> matrix with each column giving the lower and upper limits of the support of the independent continuous uniform distribution for the corresponding parameter. The column names of <code>support</code> must match the names of parameters in the <code>formula</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>An optional argument for controlling the approximation to the expected utility. It should be a vector of length two. 
</p>
<p>For <code>criterion = "MC"</code>, it specifies the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If left unspecified, the default value is <code>c(20000,1000)</code>.
</p>
<p>For <code>criterion = "quadrature"</code>, it specifies the tuning parameters (numbers of radial abscissas and random rotations) for the implemented quadrature method; see <b>Details</b> for more information. If left unspecified, the default value is <code>c(2, 8)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>An optional character argument specifying the utility function. There are currently five utility functions implemented consisting of 
</p>

<ol>
<li>
<p><b>pseudo-Bayesian D-optimality</b> (<code>criterion = "D"</code>); 
</p>
</li>
<li>
<p><b>pseudo-Bayesian A-optimality</b> (<code>criterion = "A"</code>); 
</p>
</li>
<li>
<p><b>pseudo-Bayesian E-optimality</b> (<code>criterion = "E"</code>); 
</p>
</li>
<li>
<p><b>Shannon information gain</b> (<code>criterion = "SIG"</code>); 
</p>
</li>
<li>
<p><b>negative squared error loss</b> (<code>criterion = "NSEL"</code>). 
</p>
</li>
</ol>
<p>The default value is <code>"D"</code> denoting pseudo-Bayesian D-optimality. See <b>Details</b> for more information. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>An optional character argument specifying the method of approximating the expected utility function. Current choices are <code>method = "quadrature"</code> for a deterministic quadrature approximation and <code>method = "MC"</code> for a stochastic Monte Carlo approximation. The first of these choices is <b>only</b> available when the argument <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code>. The second choice is available for all possible values of the argument <code>criterion</code>. If left unspecified, the argument defaults to <code>"quadrature"</code> for <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code> and to <code>"MC"</code> otherwise. See <b>Details</b> for more information. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number should be printed. The default value is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code>mclapply</code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.assess</code></td>
<td>

<p>If <code>method = "MC"</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>acenlm</code> function implements the ACE algorithm to find designs for general classes of nonlinear regression models with identically and independently normally distributed errors meaning the user does not have to write their own utility function.
</p>
<p>Two utility functions are implemented.
</p>

<ol>
<li>
<p><b>Shannon information gain (SIG)</b> 
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{SIG}(d) = \pi(\theta|y,d) - \pi(\theta),</code>
</p>

<p>where <code class="reqn">\pi(\theta|y,d)</code> and <code class="reqn">\pi(\theta)</code> denote the posterior and prior densities of the parameters <code class="reqn">\theta</code>, respectively.
</p>
</li>
<li>
<p><b>Negative squared error loss (NSEL)</b>
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{NSEL}(d) = - \left(\theta - E(\theta |y,d)\right)^T \left(\theta - E(\theta |y,d)\right),</code>
</p>

<p>where <code class="reqn">E(\theta | y,d)</code> denotes the posterior mean of <code class="reqn">\theta</code>.
</p>
</li>
</ol>
<p>In both cases the utility function is not available in closed form due to the analytical intractability of either the posterior distribution (for SIG) or the posterior mean (for NSEL). Sampling-based Monte Carlo or importance sampling approximations will be employed. This was the original approach used by Overstall &amp; Woods (2017). 
</p>
<p>A normal approximation to the posterior can be taken leading to the approximation by some scalar function of the Fisher information matrix, <code class="reqn">\mathcal{I} (\theta;d)</code>, which only depends on <code class="reqn">\theta</code> (Chaloner &amp; Verdinelli, 1995). In the case of SIG, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^{D}(d) = \log \vert \mathcal{I} (\theta;d) \vert,</code>
</p>

<p>and the resulting design is typically called pseudo-Bayesian D-optimal. For NSEL, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^A(d) = - \mathrm{tr} \left\{ \mathcal{I} (\theta;d)^{-1} \right\} </code>
</p>

<p>with the resulting design termed pseudo-Bayesian A-optimal. These designs are often used under the frequentist approach to optimal experimental design and so to complete the usual set, the following utility for finding a pseudo-Bayesian E-optimal design is also implemented:
</p>
<p style="text-align: center;"><code class="reqn">u^E(d) = \mathrm{min} \mbox{ } e\left(\mathcal{I} (\theta;d) \right),</code>
</p>

<p>where <code class="reqn">e()</code> denotes the function that calculates the eigenvalues of its argument.
</p>
<p>The expected utilities can be approximated using Monte Carlo methods (<code>method = "MC"</code> for all criteria) or using a deterministic quadrature method (<code>method = "quadrature"</code>, implemented for the D, A and E criteria). The former approach approximates the expected utility via sampling from the prior. The latter approach uses a radial-spherical integration rule (Monahan and Genz, 1997) and <code>B[1]</code> specifies the number, <code class="reqn">n_r</code>, of radial abscissas and <code>B[2]</code> specifies the number,  <code class="reqn">n_q</code>, of random rotations. Larger values of  <code class="reqn">n_r</code> will produce more accurate, but also more computationally expensive, approximations. See Gotwalt et al. (2009) for further details.   
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>pacenlm</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>pacenlm</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for <code>acenlm</code>) or <code>"pace"</code> (for <code>pacenlm</code>)  which is a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>utility</code></td>
<td>

<p>The utility function resulting from the choice of arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm</code></td>
<td>

<p>This will be <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlm</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>criterion</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>method</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>prior</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>formula</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>. Will be <code>FALSE</code> for the utility functions currently implemented.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The terminal design (<code>pacenlm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval</code></td>
<td>

<p>If <code>deterministic = "MC"</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>pacenlm</code> only).
</p>
<p>If <code>deterministic = "quadrature"</code>, a scalar giving the approximate expected utility for the terminal design (<code>pacenlm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>pacenlm</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>pacenlm</code> only).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>These are wrapper functions for <code>ace</code> and <code>pace</code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian experimental design: a review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C. M., Jones, B. A.  &amp; Steinberg, D. M. (2009). Fast computation of designs robust to parameter uncertainty for nonlinear settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The coordinate exchange algorithm for constructing exact
optimal experimental designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Monahan, J. and Genz, A. (1997). Spherical-radial integration rules for
Bayesian computation,” Journal of the American Statistical Association, 92, 664–674.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>


<h3>See Also</h3>

<p><code>ace</code>, <code>aceglm</code>, <code>pace</code>, <code>paceglm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## This example uses aceglm to find a Bayesian D-optimal design for a 
## compartmental model with 6 runs 1 factor. The priors are 
## those used by Overstall &amp; Woods (2017). The design space for each 
## coordinate is [0, 24] hours.

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix(24 * randomLHS(n = n, k = 1), nrow = n, ncol = 1,
dimnames = list(as.character(1:n), c("t")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

low&lt;-c(0.01884, 0.298, 21.8)
upp&lt;-c(0.09884, 8.298, 21.8)
## Lower and upper limits of the support of the uniform prior distributions. Note that the prior
## for the third element is a point mass.

prior&lt;-function(B){
out&lt;-cbind(runif(n = B, min = low[1], max = upp[1]), runif(n = B, min = low[2],max = upp[2]),
runif(n = B, min = low[3], max = upp[3]))
colnames(out)&lt;-c("a", "b", "c")
out}

## Create a function which specifies the prior. This function will return a 
## B by 3 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

example1&lt;-acenlm(formula = ~ c*(exp( - a * t) - exp( - b * t)), start.d = start.d, prior = prior, 
N1 = 1, N2 = 0, B = c(1000, 1000), lower = 0, upper = 24, method = "MC")
## Call the acenlm function which implements the ACE algorithm requesting 
## only one iteration of Phase I and zero iterations of Phase II. The Monte
## Carlo sample size for the comparison procedure (B[1]) is set to 1000.

example1
## Print out a short summary.

#Non Linear Model 
#Criterion = Bayesian D-optimality 
#Formula: ~c * (exp(-a * t) - exp(-b * t))
#Method:  MC 
#
#B:  1000 1000 
#
#Number of runs = 6
#
#Number of factors = 1
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 0
#
#Computer time = 00:00:00

example1$phase2.d
## Look at the final design.

#           t
#1 19.7787011
#2  2.6431912
#3  0.2356938
#4  8.2471451
#5  1.4742319
#6 12.7062270

prior2 &lt;- list(support = cbind(rbind(low, upp)))
colnames(prior2$support) &lt;- c("a", "b", "c")
example2 &lt;- acenlm(formula = ~ c * (exp( - a * t) - exp( - b *t)), start.d = start.d, 
prior = prior2, lower = 0, upper = 24, N1 = 1, N2 = 0 )
## Call the acenlm function with the default method of "quadrature"

example2$phase2.d
## Final design

#           t
#1  0.5167335
#2  2.3194434
#3  1.5365409
#4  8.2471451
#5 21.9402670
#6 12.7062270

utility &lt;- utilitynlm(formula = ~c * (exp( - a * t) - exp( - b *t)), prior = prior, 
                            desvars = "t", method = "MC" )$utility
## create a utility function to compare designs

mean(utility(example1$phase1.d, B = 20000))
#[1] 12.13773
mean(utility(example2$phase1.d, B = 20000))
#[1] 11.19745
## Compare the two designs using the Monte Carlo approximation
</code></pre>


</div>