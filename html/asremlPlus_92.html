<div class="container">

<table style="width: 100%;"><tr>
<td>pickLSDstatistics.alldiffs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pick LSDstatistics whose values minimize the number of errors in pairwise comparisons of predictions.</h2>

<h3>Description</h3>

<p>Given an <code>alldiffs.object</code> with an <code>sed</code> component, 
<code>exploreLSDs.alldiffs</code> is used to calculate the LSD values for each set of 
prediction comparisons specified by <code>LSDtype</code> and <code>LSDby</code> using each of the 
statistics <code>minimum</code>, <code>q10</code>, <code>q25</code>,  <code>mean</code>, <code>median</code>, <code>q75</code>, 
<code>q90</code>  and <code>maximum</code>. Then the numbers of false positives and 
false negatives resulting from employing each of the calculated LSDs is obtained. For 
each set of comparisons, the LSD value(s) with the lowest number of false positives are 
identified and, from these, the smallest value with the lowest number of false negatives. 
That is, a conservative approach is taken to picking LSD values by putting the priority on 
avoiding false positives. Before using the LSDstatistics that this function suggests, the number 
of false positives and negatives generated by them should be checked. For example, it may be 
that there are too many false negatives and a better balance between the numbers of false 
positives and negatives can be identified using <code>exploreLSDs.alldiffs</code>,</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'alldiffs'
pickLSDstatistics(alldiffs.obj, 
                  LSDtype = "overall", LSDby = NULL, 
                  alpha = 0.05, digits = 3, 
                  false.pos.wt = NULL, retain.zeroLSDs = FALSE, 
                  zero.tolerance = .Machine$double.eps ^ 0.5, 
                  ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alldiffs.obj</code></td>
<td>
<p>An <code>alldiffs.object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LSDtype</code></td>
<td>
<p>A <code>character</code> string that can be <code>overall</code> or <code>factor.combinations</code>. 
It determines whether the LSD values that are investigated and stored are  
(i) the <code>overall</code> minimum, quantile10, quantile25, mean, median, quantile75, quantile90, 
and maximum of all pairwise LSDs, or 
(ii) the minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum 
for the pairwise LSDs for each combination of the values of the <code>factors</code> and 
<code>numerics</code> named in <code>LSDby</code>, unless there is only one prediction for a 
combination, when notional LSDs are calculated. The <code>LSDtype</code> specified here does not 
have to match that used in the creating the <code>alldiffs.object</code>.
</p>
<p>See <code>LSD.frame</code> for further information on how the LSD statistics are calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LSDby</code></td>
<td>
<p>A <code>character</code> (vector) of variables names, being the names of the 
<code>factors</code> or <code>numerics</code> in the <code>classify</code>; for each 
combination of the values the of the <code>factors</code> and <code>numerics</code>, the 
LSD errors are to be computed when <code>LSDtype</code> is <code>factor.combinatons</code>. The <code>LSDby</code> 
specified here does not have to match that used in the creating the 
<code>alldiffs.object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A <code>numeric</code> specifying the significance level for an LSD to compare a pair of 
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>A <code>numeric</code> specifying the number of significant digits to retain in rounding 
the LSDs before determining the distinct rounded LSDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>false.pos.wt</code></td>
<td>
<p>When it is not <code>NULL</code>, it should be a <code>numeric</code> that specifies the 
weight (e.g. 3 so that a false positive is considered to be equivalent to three false negatives) 
to apply to the number of false positives in calculating the weighted sums of the numbers of 
false positives and negatives to use in comparing different LSD statistics, one being the weight 
for the number false negatives. The <code>LSDstatistic</code> that is chosen for making comparisons 
will be the one that minimizes the weighted sum, has the smallest number of false positives and, 
amongst these, has the smallest LSD value. If it is <code>NULL</code>, the <code>LSDstatistic</code> that 
will be chosen is the one that minimizes the number of false negatives from amongst those that 
minimize the number of false positives. 
</p>
<p>If, amongst the LSD statistices, the least number of  false negatives that occurs is <em>m</em>, 
then for a particular statistic with <em>p</em> the number of false positives, <em>n</em> the number 
of false negatives and <em>w</em> the value of <code>false.pos.wt</code>,  that statistic will be a 
candidate LSD value if <code class="reqn">(w p) + n &lt; m</code> and i.e. 
if <code class="reqn">p &lt; (m - n) / w</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retain.zeroLSDs</code></td>
<td>
<p>A <code>logical</code> indicating whether to retain or omit LSDs that are zero when 
calculating the summaries of LSDs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.tolerance</code></td>
<td>
<p>A <code>numeric</code> specifying the value such that if an LSD is less than it, the LSD will be 
considered to be zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>character</code> of length one for <code>LSDby</code> set to <code>overall</code> or of length equal to the 
number of observed combinations of the values of the <code>factors</code> and <code>numerics</code> 
in <code>LSDby</code>. Each element of the returned <code>character</code> is one of <code>minimum</code>, 
<code>q10</code>, <code>q25</code>,  <code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code>, 
reflecting the value(s) of the LSD from amongst those calculated that minimizes the number of false 
positives; if there is more than one such value, then the element will be correspond to the value 
of the LSD from amongst those with the minimum number of false positives that minimizes 
the number of false negatives.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>asremlPlus-package</code>, <code>exploreLSDs.alldiffs</code> <code>plotLSDs.data.frame</code>, 
<code>plotLSDs.alldiffs</code>, <br><code>plotLSDerrors.alldiffs</code>, <code>plotLSDerrors.data.frame</code>, <code>recalcLSD.alldiffs</code>, <br><code>redoErrorIntervals.alldiffs</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Pick the LSD values for predictions obtained using asreml or lmerTest  
  LSDstat &lt;- pickLSDstatistics(TS.diffs)
  TS.diffs &lt;- redoErrorIntervals(TS.diffs, LSDstatistic = LSDstat)
  TS.diffs$LSD
  LSDstat &lt;- pickLSDstatistics(TS.diffs, LSDtype = "factor.combinations", 
                         LSDby = "Sources")
  TS.diffs &lt;- redoErrorIntervals(TS.diffs, LSDtype = "factor.combinations", 
                                 LSDby = "Sources", LSDstatistic = LSDstat)
  TS.diffs$LSD
}
</code></pre>


</div>