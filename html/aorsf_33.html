<div class="container">

<table style="width: 100%;"><tr>
<td>predict.ObliqueForest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction for ObliqueForest Objects</h2>

<h3>Description</h3>

<p>Compute predicted values from an oblique random forest. Predictions
may be returned in aggregate (i.e., averaging over all the trees)
or tree-specific.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ObliqueForest'
predict(
  object,
  new_data = NULL,
  pred_type = NULL,
  pred_horizon = NULL,
  pred_aggregate = TRUE,
  pred_simplify = FALSE,
  oobag = FALSE,
  na_action = NULL,
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see orsf).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_data</code></td>
<td>
<p>a data.frame, tibble, or data.table to compute predictions in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_type</code></td>
<td>
<p>(<em>character</em>) the type of predictions to compute. Valid
options for survival are:
</p>

<ul>
<li>
<p> 'risk' : probability of having an event at or before <code>pred_horizon</code>.
</p>
</li>
<li>
<p> 'surv' : 1 - risk.
</p>
</li>
<li>
<p> 'chf': cumulative hazard function
</p>
</li>
<li>
<p> 'mort': mortality prediction
</p>
</li>
<li>
<p> 'time': survival time prediction
</p>
</li>
</ul>
<p>For classification:
</p>

<ul>
<li>
<p> 'prob': probability for each class
</p>
</li>
<li>
<p> 'class': predicted class
</p>
</li>
</ul>
<p>For regression:
</p>

<ul><li>
<p> 'mean': predicted mean, i.e., the expected value
</p>
</li></ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_horizon</code></td>
<td>
<p>(<em>double</em>) Only relevent for survival forests.
A value or vector indicating the time(s) that predictions will be
calibrated to. E.g., if you were predicting risk of incident heart
failure within the next 10 years, then <code>pred_horizon = 10</code>.
<code>pred_horizon</code> can be <code>NULL</code> if <code>pred_type</code> is <code>'mort'</code>, since
mortality predictions are aggregated over all event times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_aggregate</code></td>
<td>
<p>(<em>logical</em>) If <code>TRUE</code> (the default), predictions
will be aggregated over all trees by taking the mean. If <code>FALSE</code>, the
returned output will contain one row per observation and one column
for each tree. If the length of <code>pred_horizon</code> is two or more and
<code>pred_aggregate</code> is <code>FALSE</code>, then the result will be a list of such
matrices, with the i'th item in the list corresponding to the i'th
value of <code>pred_horizon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_simplify</code></td>
<td>
<p>(<em>logical</em>) If <code>FALSE</code> (the default), predictions
will always be returned in a numeric matrix or a list of numeric matrices.
If <code>TRUE</code>, predictions may be simplified to a vector, e.g., if <code>pred_type</code>
is <code>'mort'</code> for survival or <code>'class'</code> for classification, or an array of
matrices if <code>length(pred_horizon) &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oobag</code></td>
<td>
<p>(<em>logical</em>) If <code>FALSE</code> (the default), predictions will
be computed using all trees for each observation. If <code>TRUE</code>, then
out-of-bag predictions will be computed. This input parameter should
only be set to <code>TRUE</code> if <code>new_data</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_action</code></td>
<td>
<p>(<em>character</em>) what should happen when <code>new_data</code> contains missing values (i.e., <code>NA</code> values). Valid options are:
</p>

<ul>
<li>
<p> 'fail' : an error is thrown if <code>new_data</code> contains <code>NA</code> values
</p>
</li>
<li>
<p> 'pass' : the output will have <code>NA</code> in all rows where <code>new_data</code> has 1 or more <code>NA</code> value for the predictors used by <code>object</code>
</p>
</li>
<li>
<p> 'omit' : rows in <code>new_data</code> with incomplete data will be dropped
</p>
</li>
<li>
<p> 'impute_meanmode' : missing values for continuous and categorical variables in <code>new_data</code> will be imputed using the mean and mode, respectively. To clarify,
the mean and mode used to impute missing values are from the
training data of <code>object</code>, not from <code>new_data</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_checks</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, <code>pred_horizon</code> will be
checked to make sure the requested values are less than the maximum
observed time in <code>object</code>'s training data. If <code>FALSE</code>, these checks
are skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while computing predictions. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress messages are
printed in the console. If <code>FALSE</code> (the default), nothing is printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>new_data</code> must have the same columns with equivalent types as the data
used to train <code>object</code>. Also, factors in <code>new_data</code> must not have levels
that were not in the data used to train <code>object</code>.
</p>
<p><code>pred_horizon</code> values should not exceed the maximum follow-up time in
<code>object</code>'s training data, but if you truly want to do this, set
<code>boundary_checks = FALSE</code> and you can use a <code>pred_horizon</code> as large
as you want. Note that predictions beyond the maximum follow-up time
in the <code>object</code>'s training data are equal to predictions at the
maximum follow-up time, because <code>aorsf</code> does not estimate survival
beyond its maximum observed time.
</p>
<p>If unspecified, <code>pred_horizon</code> may be automatically specified as the value
used for <code>oobag_pred_horizon</code> when <code>object</code> was created (see orsf).
</p>


<h3>Value</h3>

<p>a <code>matrix</code> of predictions. Column <code>j</code> of the matrix corresponds
to value <code>j</code> in <code>pred_horizon</code>. Row <code>i</code> of the matrix corresponds to
row <code>i</code> in <code>new_data</code>.
</p>


<h3>Examples</h3>

<div class="sourceCode r"><pre>library(aorsf)
</pre></div>


<h4>Classification</h4>

<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_clsf &lt;- orsf(data = penguins_orsf_train, 
                 formula = species ~ .)
</pre></div>
<p>Predict probability for each class or the predicted class:
</p>
<div class="sourceCode r"><pre># predicted probabilities, the default
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'prob')
</pre></div>
<div class="sourceCode"><pre>##         Adelie  Chinstrap      Gentoo
## [1,] 0.9405310 0.04121955 0.018249405
## [2,] 0.9628988 0.03455909 0.002542096
## [3,] 0.9032074 0.08510528 0.011687309
## [4,] 0.9300133 0.05209040 0.017896329
## [5,] 0.7965703 0.16243492 0.040994821
</pre></div>
<div class="sourceCode r"><pre># predicted class (as a matrix by default)
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'class')
</pre></div>
<div class="sourceCode"><pre>##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
## [4,]    1
## [5,]    1
</pre></div>
<div class="sourceCode r"><pre># predicted class (as a factor if you use simplify)
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'class',
        pred_simplify = TRUE)
</pre></div>
<div class="sourceCode"><pre>## [1] Adelie Adelie Adelie Adelie Adelie
## Levels: Adelie Chinstrap Gentoo
</pre></div>



<h4>Regression</h4>

<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_regr &lt;- orsf(data = penguins_orsf_train, 
                 formula = bill_length_mm ~ .)
</pre></div>
<p>Predict the mean value of the outcome:
</p>
<div class="sourceCode r"><pre>predict(fit_regr, 
        new_data = penguins_orsf_test[1:5, ], 
        pred_type = 'mean')
</pre></div>
<div class="sourceCode"><pre>##          [,1]
## [1,] 37.74136
## [2,] 37.42367
## [3,] 37.04598
## [4,] 39.89602
## [5,] 39.14848
</pre></div>



<h4>Survival</h4>

<p>Begin by fitting an oblique survival random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(pbc_orsf), 150) 

pbc_orsf_train &lt;- pbc_orsf[index_train, ]
pbc_orsf_test &lt;- pbc_orsf[-index_train, ]

fit_surv &lt;- orsf(data = pbc_orsf_train, 
                 formula = Surv(time, status) ~ . - id,
                 oobag_pred_horizon = 365.25 * 5)
</pre></div>
<p>Predict risk, survival, or cumulative hazard at one or several times:
</p>
<div class="sourceCode r"><pre># predicted risk, the default
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'risk', 
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##             [,1]        [,2]       [,3]
## [1,] 0.013648562 0.058393393 0.11184029
## [2,] 0.003811413 0.026857586 0.04774151
## [3,] 0.030548361 0.100600301 0.14847107
## [4,] 0.040381075 0.169596943 0.27018952
## [5,] 0.001484698 0.006663576 0.01337655
</pre></div>
<div class="sourceCode r"><pre># predicted survival, i.e., 1 - risk
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'surv',
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##           [,1]      [,2]      [,3]
## [1,] 0.9863514 0.9416066 0.8881597
## [2,] 0.9961886 0.9731424 0.9522585
## [3,] 0.9694516 0.8993997 0.8515289
## [4,] 0.9596189 0.8304031 0.7298105
## [5,] 0.9985153 0.9933364 0.9866235
</pre></div>
<div class="sourceCode r"><pre># predicted cumulative hazard function
# (expected number of events for person i at time j)
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'chf',
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##             [,1]        [,2]       [,3]
## [1,] 0.015395388 0.067815817 0.14942956
## [2,] 0.004022524 0.028740305 0.05424314
## [3,] 0.034832754 0.127687156 0.20899732
## [4,] 0.059978334 0.233048809 0.42562310
## [5,] 0.001651365 0.007173177 0.01393016
</pre></div>
<p>Predict mortality, defined as the number of events in the forestâ€™s
population if all observations had characteristics like the current
observation. This type of prediction does not require you to specify a
prediction horizon
</p>
<div class="sourceCode r"><pre>predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'mort')
</pre></div>
<div class="sourceCode"><pre>##           [,1]
## [1,] 23.405016
## [2,] 15.362916
## [3,] 26.180648
## [4,] 36.515629
## [5,]  5.856674
</pre></div>



</div>