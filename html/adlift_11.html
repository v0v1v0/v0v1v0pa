<div class="container">

<table style="width: 100%;"><tr>
<td>basisfns</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>basisfns</h2>

<h3>Description</h3>

<p>This function plots all mother and father wavelets associated with a given wavelet transform.   
</p>


<h3>Usage</h3>

<pre><code class="language-R">basisfns(x, f, pred, neigh, int, clo, keep, plot.f = FALSE, 
plot.bas = FALSE, separate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a gridpoint vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>the vector of associated function values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>The type of regression to be performed. Possible options are LinearPred, QuadPred, CubicPred, AdaptPred and AdaptNeigh.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neigh</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step. If <span class="env">closest</span> is false, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Indicates whether or not the regression curve includes an intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clo</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is false, the neighbours will be chosen symmetrically around the removed point. Otherwise, the closest neighbours will be chosen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal. This must be at least two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.f</code></td>
<td>
<p>a boolean value indicating whether to plot the original function or not. If so, the signal is plotted with vertical coloured lines, showing which prediction method was used on the different parts of the signal. The plot also shows which gridpoints correspond to scaling functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.bas</code></td>
<td>
<p> subset of <code>1:length(f)</code>, denoting which basis functions to plot. Each basis function is colour-coded according to which prediction scheme was used in the lifting of the corresponding gridpoint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>separate</code></td>
<td>
<p>a boolean argument indicating if the basis functions should be plotted on a single graphsheet.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The procedure constructs <span class="env">W</span>, the matrix representation of the forward transform specified in the arguments to the function, and then uses the inverse matrix to calculate the vectors of basis function values: to work out the basis function values, one inverts the transform with a delta vector, with a one in the position corresponding to the basis function required. Since this is equivalent to pre-multiplying the delta vector by the matrix representation for the inverse transform <code class="reqn">(W^{-1})</code>, the basis function values are precisely the columns of <code class="reqn">W^{-1}</code>. The procedure then plots the basis functions (each on a separate graphsheet, if chosen), colour coded according to the prediction scheme used or whether it is a scaling function. </p>


<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>out</code></td>
<td>
<p>the output from the forward transform which is specified in the arguments to this function</p>
</td>
</tr></table>
<p>$</p>
<table>
<tr style="vertical-align: top;">
<td><code>pointsin</code></td>
<td>
<p>the vector of indices of points still to be removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>schhist</code></td>
<td>
<p>a character string vector of the prediction scheme used for the prediction of each gridpoint (in the order of <span class="env">x</span>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inthist</code></td>
<td>
<p>vector of boolean values indicating whether an intercept was used in the prediction steps during the transform (in the order of <span class="env">x</span>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basmat</code></td>
<td>
<p>a matrix of wavelet basis function values. The row <span class="env">i</span> represents the function values corresponding to the grid for the basis function associated to the gridpoint <code class="reqn">i</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>If <span class="env">plot.bas=T</span>, since the function produces one graph for each gridpoint, R or Splus is likely to exceed the total number of open devices for large datasets.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:nunesrpackages@gmail.com">nunesrpackages@gmail.com</a>), Marina Knight</p>


<h3>See Also</h3>

<p><code>fwtnp</code>,<code>fwtnp</code>     </p>


<h3>Examples</h3>

<pre><code class="language-R">#create test signal data
#
x&lt;-runif(100)
y&lt;-make.signal2("blocks",x=x)
#
#perform procedure...
#
a&lt;-basisfns(x,y,AdaptNeigh,2,TRUE,TRUE,2,FALSE,c(1,14,15),FALSE)
#
#this produces plots of three basis functions all on one graph.
</code></pre>


</div>