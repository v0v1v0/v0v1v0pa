<div class="container">

<table style="width: 100%;"><tr>
<td>ace</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Approximate Coordinate Exchange (ACE) Algorithm
</h2>

<h3>Description</h3>

<p>These functions implement the approximate coordinate exchange (ACE) algorithm (Overstall &amp; Woods, 2017) for finding optimal Bayesian experimental designs by maximising an approximation to an intractable expected utility function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ace(utility, start.d, B, Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, progress = FALSE, binary = FALSE, deterministic = FALSE)

acephase1(utility, start.d, B, Q = 20, N1 = 20, lower, upper, limits = NULL, 
progress = FALSE, binary = FALSE, deterministic = FALSE)

acephase2(utility, start.d, B, N2 = 100, progress = FALSE, binary = FALSE, 
deterministic = FALSE)

pace(utility, start.d, B, Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, binary = FALSE, deterministic = FALSE, mc.cores = 1, 
n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>utility</code></td>
<td>

<p>A function with two arguments: <code>d</code> and <code>B</code>. 
</p>
<p>For a Monte Carlo approximation (<code>deterministic = FALSE</code>), it should return a <em><b>vector</b></em> of length <code>B</code> where each element gives the value of the utility function for design <code>d</code>, for a value generated from the joint distribution of all unknown quantities. The mean of the elements of this vector provides a Monte Carlo approximation to the expected utility for design <code>d</code>.
</p>
<p>For a deterministic approximation (<code>deterministic = TRUE</code>), it should return a <em><b>scalar</b></em> giving the approximate value of the expected utility for design <code>d</code>. In this latter case, the argument <code>B</code> can be a list containing tuning parameters for the deterministic approximation. If <code>B</code> is not required, the utility function must still accept the argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>For <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>, an <code>n</code> by <code>k</code> matrix specifying the initial design for the ACE algorithm.
</p>
<p>For <code>pace</code>, a list with each element being an <code>n</code> by <code>k</code> matrix specifying the initial design for each repetition of the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>An argument for controlling the approximation to the expected utility.
</p>
<p>For a Monte Carlo approximation (<code>deterministic = FALSE</code>), a vector of length two specifying the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If missing when <code>deterministic = FALSE</code>, the default value is <code>c(20000,1000)</code>. 
</p>
<p>For a deterministic approximation (<code>deterministic = TRUE</code>), then <code>B</code> may be a list of length two containing any necessary tuning parameters for the expected utility calculations for the comparison and emulation steps.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>

<p>An argument specifying the bounds on the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>

<p>An argument specifying the bounds on the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number and other information detailing the progress of the algorithm should be printed. The default value is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>

<p>A logical argument indicating whether the utility function has binary or continuous output. In some cases, the utility function is an indicator function of some event giving binary output. The expected utility function will then be the expected posterior probability of the event. Utility functions such as Shannon information gain and negative squared error loss give continuous output. The type of output guides the choice of comparison procedure used in the ACE algorithm. The default value is <code>FALSE</code>, indicating the utility function has continuous output.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deterministic</code></td>
<td>

<p>A logical argument indicating if a Monte Carlo (<code>FALSE</code>, default) or deterministic (<code>TRUE</code>) approximation to the expected utility is being used. 		
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code>mclapply</code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.assess</code></td>
<td>

<p>If <code>deterministic = FALSE</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Finding an optimal Bayesian experimental design (Chaloner &amp; Verdinelli, 1995) involves maximising 
an objective function given by the expectation of some appropriately chosen utility 
function with respect to the joint distribution of unknown quantities (including responses). This objective 
function is usually not available in closed form and the design space can be continuous and of high 
dimensionality.
</p>
<p>Overstall &amp; Woods (2017) proposed the approximate coordinate exchange (ACE) algorithm 
to approximately maximise the expectation of the utility function. ACE consists of
two phases.
</p>
<p>Phase I uses a continuous version of the coordinate exchange algorithm (Meyer &amp; 
Nachtsheim, 1995) to maximise an approximation to the expected utility. Very briefly, 
the approximate expected utility is sequentially maximised over each one-dimensional element
of the design space. The approximate expected utility is given by the predictive mean of a 
Gaussian process (GP) regression model (also known as an emulator or surrogate) fitted 
to a 'small' number (argument <code>Q</code>) of evaluations of either a Monte Carlo (MC) or deterministic (e.g. quadrature) approximation to the expected utility (the MC sample size or arguments for the deterministic approximation are given by <code>B</code>). A GP 
emulator is a statistical model and, similar to all statistical models, can be an 
inadequate representation of the underlying process (i.e. the expected utility). 
Instead of automatically accepting the new design given by the value that maximises 
the GP emulator, for MC approximations a Bayesian hypothesis test, independent of the GP emulator, is 
performed to assess whether the expected utility of the new design is larger than the 
current design. For deterministic approximations, the approximate expected utility is calculated for the new design, and compared to that for the current design.
</p>
<p>Phase I tends to produce clusters of design points. This is where, for example, two
design points are separated by small Euclidean distance. Phase II allows these points 
to be consolidated into a single repeated design point by using a point exchange 
algorithm (e.g Gotwalt et al., 2009) with a candidate set given by the final design 
from Phase I. In the same way as Phase I, comparisons of the expected loss between 
two designs is made on the basis of either a Bayesian hypothesis test or a direct comparison of deterministic approximations.
</p>
<p>The original Bayesian hypothesis test proposed by Overstall &amp; Woods (2017) is 
appropriate for utility functions with continuous output. Overstall et al. (2017) 
extended the idea to utility functions with binary output, e.g. the utility 
function is an indicator function for some event. The type of test can be specified by
the argument <code>binary</code>.
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>pace</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>pace</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for functions <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>) or <code>"pace"</code> (for function <code>"pace"</code>) which is a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>utility</code></td>
<td>

<p>The argument <code>utility</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm (only for <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm (only for <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>)..
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase1.trace</code></td>
<td>

<p>A vector containing the approximated expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence for MC approximations.
If <code>deterministic = FALSE</code>, this will be the mean of a call to <code>utility</code> with <code>d</code> being the current design and <code>B</code> being equal to the argument <code>B[1]</code>. If <code>deterministic = TRUE</code>, 
this will be a call to <code>utility</code> with <code>d</code> being the current design.
</p>
<p>For <code>pace</code>, this will be <code>phase1.trace</code> for the terminal design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase2.trace</code></td>
<td>

<p>A vector containing the approximated expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence for MC approximations.
If <code>deterministic = FALSE</code>, this will be the mean of a call to <code>utility</code> with <code>d</code> being the current design and <code>B</code> being equal to the argument <code>B[1]</code>. If <code>deterministic = TRUE</code>, 
this will be a call to <code>utility</code> with <code>d</code> being the current design.
</p>
<p>For <code>pace</code>, this will be <code>phase2.trace</code> for the terminal design.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlm</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>"NA"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>"NA"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deterministic</code></td>
<td>

<p>The argument <code>deterministic</code>.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>The terminal design (<code>pace</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval</code></td>
<td>

<p>If <code>deterministic = FALSE</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>pace</code> only).
</p>
<p>If <code>deterministic = TRUE</code>, a scalar giving the approximate expected utility for the terminal design (<code>pace</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>pace</code> only).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>pace</code> only).
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For more details on the <code>R</code> implementation of the utility function used in the <b>Examples</b> section, see <code>utilcomp18bad</code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian Experimental Design: A Review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C., Jones, B. &amp; Steinberg, D. (2009). Fast Computation of Designs Robust to Parameter
Uncertainty for Nonlinear Settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The Coordinate Exchange Algorithm for Constructing Exact
Optimal Experimental Designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Overstall, A.M., McGree, J.M. &amp; Drovandi, C.C. (2018). An approach for finding fully Bayesian optimal designs using normal-based approximations to loss functions. <em>Statistics and Computing</em>, <b>28</b>(2), 343-358.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
## Set seed for reproducibility.

## This example involves finding a pseudo-Bayesian D-optimal design for a 
## compartmental model with n = 18 runs. There are three parameters. 
## Two parameters have uniform priors and the third has a prior 
## point mass. For more details see Overstall &amp; Woods (2017).

start.d&lt;-optimumLHS(n = 18, k = 1)
## Create an initial design.

## Using a MC approximation
example1&lt;-ace(utility = utilcomp18bad, start.d = start.d, N1 = 1, N2 = 2, B = c(100, 20))
## Implement the ACE algorithm with 1 Phase I iterations and 2 Phase II
## iterations. The Monte Carlo sample sizes are 100 (for comparison) and 20 for
## fitting the GP emulator.

example1
## Produce a short summary.

#User-defined model &amp; utility 
#
#Number of runs = 18
#
#Number of factors = 1
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 2
#
#Computer time = 00:00:00

mean(utilcomp18bad(d = example1$phase2.d, B = 100))
## Calculate an approximation to the expected utility for the final design.
## Should get:

#[1] 9.254198

## Not run: 
plot(example1)
## Produces a trace plot of the current value of the expected utility. This
## can be used to assess convergence.

## End(Not run)

</code></pre>


</div>