<div class="container">

<table style="width: 100%;"><tr>
<td>packBitmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A routine to (un)pack bitmap data</h2>

<h3>Description</h3>

<p>A very simplistic lossless routine to (un)pack repetitive bitmap data. Often
used in InterLeaved BitMap (ILBM) images in IFF containers (<code>IFFChunk()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">packBitmap(x)

unPackBitmap(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>raw</code> data, usually representing a (packed) bitmap.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>InterLeaved BitMap (ILBM) images on the Amiga often use a packing algorithm
referred to as ‘ByteRun1’. This routine was introduced first on
the Macintosh where it was called PackBits. It is a form of run-length encoding
and is very simple:
when a specific byte is repeated in a bitmap, it is replaced by
a (signed negative) byte telling how many times the following byte
should be repeated. When a series of bytes are not repetitive, it
is preceded by a (signed positive) byte telling how long the non
repetitive part is.
</p>
<p>Not very complicated, but for most images some bytes can be shaved
off the file. This was very useful when everything had to be stored
on 880 kilobyte floppy disks with little CPU time to spare. Note
that the file size can also increase for (noisy) images.
</p>
<p>This packing routine will pack the entire bitmap (<code>x</code>)
at once. The IFF file format requires packing of bitmap data per
scanline. This is done automatically by the <code>rasterToIFF()</code>
function, which calls this packing routine per scanline.
</p>


<h3>Value</h3>

<p>Returns packed or unpacked <code>raw</code> data, depending on
whether <code>packBitmap</code> or <code>unPackBitmap</code> was called.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>References</h3>

<p><a href="http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node01C0.html">http://amigadev.elowar.com/read/ADCD_2.1/Devices_Manual_guide/node01C0.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/PackBits">https://en.wikipedia.org/wiki/PackBits</a>
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code>as.AmigaBasic()</code>,
<code>as.raw.AmigaBasic()</code>,
<code>colourToAmigaRaw()</code>,
<code>rawToAmigaBasicBMAP()</code>,
<code>rawToAmigaBasicShape()</code>,
<code>rawToAmigaBasic()</code>,
<code>rawToAmigaBitmapFontSet()</code>,
<code>rawToAmigaBitmapFont()</code>,
<code>rawToAmigaIcon()</code>,
<code>rawToHWSprite()</code>,
<code>rawToIFFChunk()</code>,
<code>rawToSysConfig()</code>,
<code>simpleAmigaIcon()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate some random raw data:
dat.rnd &lt;- as.raw(sample.int(10, 100, TRUE))

## try to pack it:
pack.rnd &lt;- packBitmap(dat.rnd)

## due to the random nature of the source data
## the data could not be packed efficiently.
## The length of the packed data is close to
## the length of the original data:
length(pack.rnd) - length(dat.rnd)

## Now generate similar data but sort it
## to generate more repetitive data:
dat.srt  &lt;- as.raw(sort(sample.int(10, 100, TRUE)))
pack.srt &lt;- packBitmap(dat.srt)

## This time the packing routing is more successful:
length(pack.srt) - length(dat.srt)

## The original data can always be obtained
## from the packed data:
all(dat.rnd == unPackBitmap(pack.rnd))
all(dat.srt == unPackBitmap(pack.srt))
</code></pre>


</div>