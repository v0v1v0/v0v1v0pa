<div class="container">

<table style="width: 100%;"><tr>
<td>bayespolr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Ordered Logistic or Probit Regression</h2>

<h3>Description</h3>

<p>Bayesian functions for ordered logistic or probit modeling
with independent normal, t, or Cauchy prior distribution
for the coefficients.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayespolr(formula, data, weights, start,  ...,
    subset, na.action, contrasts = NULL,
    Hess = TRUE, model = TRUE,
    method = c("logistic", "probit", "cloglog", "cauchit"),
    drop.unused.levels=TRUE,
    prior.mean = 0,
    prior.scale = 2.5,
    prior.df = 1,
    prior.counts.for.bins = NULL,
    min.prior.scale=1e-12,
    scaled = TRUE,
    maxit = 100,
    print.unnormalized.log.posterior = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula expression as for regression models, of the form
<code>response ~ predictors</code>. The response should be a factor
(preferably an ordered factor), which will be interpreted as
an ordinal response, with levels ordered as in the factor.  A
proportional odds model will be fitted.  The model must have
an intercept: attempts to remove one will lead to a warning
and be ignored. An offset may be used.  See the documentation
of <code>formula</code> for other details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame in which to interpret the variables
occurring in <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional case weights in fitting.  Default to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>initial values for the parameters.  This is in the format
<code>c(coefficients, zeta)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to <code>optim</code>, most often a
<code>control</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>expression saying which subset of the rows of the data should
be used in the fit.  All observations are included by
default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function to filter missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of the
factors appearing as variables in the model formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hess</code></td>
<td>
<p>logical for whether the Hessian (the observed information
matrix) should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>logical for whether the model matrix should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>logistic or probit or complementary log-log or cauchit
(corresponding to a Cauchy latent variable and only available
in R &gt;= 2.1.0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.unused.levels</code></td>
<td>
<p>default <code>TRUE</code>, if <code>FALSE</code>, it interpolates the
intermediate values if the data have integer levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mean</code></td>
<td>
<p>prior mean for the coefficients: default is 0.
Can be a vector of length equal to the number of predictors
(not counting the intercepts). If it is a scalar, it is
expanded to the length of this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.scale</code></td>
<td>
<p>prior scale for the coefficients: default is 2.5.
Can be a vector of length equal to the number of predictors
(not counting the intercepts). If it is a scalar, it is expanded
to the length of this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.df</code></td>
<td>
<p>for t distribution: default is 1 (Cauchy).
Set to <code>Inf</code> to get normal prior distributions. Can
be a vector of length equal to the number of predictors (not counting
the intercepts). If it is a scalar, it is expanded to the length of this
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.counts.for.bins</code></td>
<td>
<p>default is <code>NULL</code>, which will augment the data by
giving each cut point a <code>1/levels(y)</code>. To use a noninformative prior, assign
prior.counts.for.bins = 0. If it is a scalar, it is expanded to the number
of levels of y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.prior.scale</code></td>
<td>
<p>Minimum prior scale for the coefficients: default is 1e-12.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaled</code></td>
<td>
<p>if <code>scaled = TRUE</code>, then the prior distribution is rescaled.
Can be a vector of length equal to the number of cutpoints
(intercepts). If it is a scalar, it is expanded to the length of
this vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>integer giving the maximal number of IWLS iterations, default is 100. This can also be controlled by <code>control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.unnormalized.log.posterior</code></td>
<td>
<p>display the unnormalized log posterior
likelihood for bayesglm fit, default=<code>FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The program is a simple alteration of <code>polr</code> in
<code>VR</code> version 7.2-31 that augments the
loglikelihood with the log of the t prior distributions for the
coefficients.
</p>
<p>We use Student-t prior distributions for the coefficients. The prior
distributions for the intercepts (the cutpoints) are set so they apply
to the value when all predictors are set to their mean values.
</p>
<p>If scaled=TRUE, the scales for the prior distributions of the
coefficients are determined as follows: For a predictor with only one
value, we just use <code>prior.scale</code>. For a predictor with two
values, we use prior.scale/range(x).
For a predictor with more than two values, we use prior.scale/(2*sd(x)).
</p>


<h3>Value</h3>

<p>See <code>polr</code> for details.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>prior.mean</code></td>
<td>
<p>prior means for the cofficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.scale</code></td>
<td>
<p>prior scales for the cofficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.df</code></td>
<td>
<p>prior dfs for the cofficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.counts.for.bins</code></td>
<td>
<p>prior counts for the cutpoints.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andrew Gelman <a href="mailto:gelman@stat.columbia.edu">gelman@stat.columbia.edu</a>;
Yu-Sung Su <a href="mailto:suyusung@tsinghua.edu.cn">suyusung@tsinghua.edu.cn</a>;
Maria Grazia Pittau <a href="mailto:grazia@stat.columbia.edu">grazia@stat.columbia.edu</a>
</p>


<h3>See Also</h3>

<p><code>bayesglm</code>,
<code>polr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">    M1 &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
    display (M1)

    M2 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=Inf, prior.df=Inf) # Same as M1
    display (M2)

    M3 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
    display (M3)

    M4 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=1)  # Same as M3
    display (M4)

    M5 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=7)
    display (M5)

    M6 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.scale=2.5, prior.df=Inf)
    display (M6)

    # Assign priors
    M7 &lt;- bayespolr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing,
        prior.mean=rep(0,6), prior.scale=rep(2.5,6), prior.df=c(1,1,1,7,7,7))
    display (M7)


    #### Another example
    y &lt;- factor (rep (1:10,1:10))
    x &lt;- rnorm (length(y))
    x &lt;- x - mean(x)

    M8 &lt;- polr (y ~ x)
    display (M8)

    M9 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=0)
    display (M9) # same as M1

    M10 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=10000)
    display (M10)


    #### Another example

    y &lt;- factor (rep (1:3,1:3))
    x &lt;- rnorm (length(y))
    x &lt;- x - mean(x)

    M11 &lt;- polr (y ~ x)
    display (M11)

    M12 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=0)
    display (M12) # same as M1

    M13 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=1)
    display (M13)

    M14 &lt;- bayespolr (y ~ x,  prior.scale=Inf, prior.df=Inf, prior.counts.for.bins=10)
    display (M14)

</code></pre>


</div>