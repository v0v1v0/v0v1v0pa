<div class="container">

<table style="width: 100%;"><tr>
<td>gather</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collect iterator / channel items into a vector.</h2>

<h3>Description</h3>

<p><code>gather</code> takes a channel as argument and returns a
promise. All values emitted by the channel will be collected
into a vector matching the prototype mode. After the source
channel closes, the promise will resolve with the collected
vector.
</p>
<p>Method <code>as.promise.channel</code> is a synonym for <code>gather</code>.
</p>
<p><code>collect</code> and <code>collector</code> are used in the
implementation of the above functions.  <code>collect</code> calls the
function <code>fn</code> in its argument, supplying a callback of the form
<code>function (val, name=NULL).</code> I like to call it <code>emit</code>.  While
<code>fn</code> is running, it can call <code>emit(x)</code> any number of times.
After <code>fn</code> returns, all the values passed to <code>emit</code> are returned
in a vector, with optional names.
</p>
<p><code>collector()</code> works similarly to collect() but does
not gather values when your inner function returns. Instead, it
provides your inner function with two callbacks, one to add a
value and the second to extract the value; so you can use that
callback to extract values at a later time. For an example of
<code>collector</code> usage see the definition of gather.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gather(ch, type = list())

## S3 method for class 'channel'
as.promise(x)

collect(fn, type = list())

collector(fn, type = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ch</code></td>
<td>
<p>a channel object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A prototype output vector (similar to the <code>FUN.VALUE</code>
argument of vapply) Defaults to <code>list()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a channel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A function, which should accept a single argument, here
called <code>emit</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>gather(ch, list())</code> returns a [promise] that eventually
resolves with a list. If the channel emits an error, the promise
will reject with that error. The partial results will be attached
to the error's <code>attr(err, "partialResults")</code>.
</p>
<p><code>collect</code> returns a vector of the same mode as <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class="language-R">
ch &lt;- stream(for (i in 1:10) {await(delay(0.1)); if (i %% 3 == 0) yield(i)})
## Not run:  ch |&gt; gather(numeric(0)) |&gt; then(\(x)cat(x, "\n")) 

#cumulative sum with collect
cumsum &lt;- function(vec) {
  total &lt;- 0
  collect(type=0, function(emit) {
    for (i in vec) total &lt;- emit(total+i)
  })
}

# `as.list.iteror` is implemented simply with `collect`:
as.list.iteror &lt;- function(it) {
  collect(\(yield) repeat yield(nextOr(it, break)))
}
</code></pre>


</div>