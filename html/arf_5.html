<div class="container">

<table style="width: 100%;"><tr>
<td>forge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Forests for Generative Modeling</h2>

<h3>Description</h3>

<p>Uses pre-trained FORDE model to simulate synthetic data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">forge(params, n_synth, evidence = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>Circuit parameters learned via <code>forde</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_synth</code></td>
<td>
<p>Number of synthetic samples to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evidence</code></td>
<td>
<p>Optional set of conditioning events. This can take one of
three forms: (1) a partial sample, i.e. a single row of data with
some but not all columns; (2) a data frame of conditioning events,
which allows for inequalities; or (3) a posterior distribution over leaves.
See Details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>forge</code> simulates a synthetic dataset of <code>n_synth</code> samples. First,
leaves are sampled in proportion to either their coverage (if
<code>evidence = NULL</code>) or their posterior probability. Then, each feature is
sampled independently within each leaf according to the probability mass or
density function learned by <code>forde</code>. This will create realistic
data so long as the adversarial RF used in the previous step satisfies the
local independence criterion. See Watson et al. (2023).
</p>
<p>There are three methods for (optionally) encoding conditioning events via the
<code>evidence</code> argument. The first is to provide a partial sample, where
some but not all columns from the training data are present. The second is to
provide a data frame with three columns: <code>variable</code>, <code>relation</code>,
and <code>value</code>. This supports inequalities via <code>relation</code>.
Alternatively, users may directly input a pre-calculated posterior
distribution over leaves, with columns <code>f_idx</code> and <code>wt</code>. This may
be preferable for complex constraints. See Examples.
</p>


<h3>Value</h3>

<p>A dataset of <code>n_synth</code> synthetic samples.
</p>


<h3>References</h3>

<p>Watson, D., Blesch, K., Kapar, J., &amp; Wright, M. (2023). Adversarial random
forests for density estimation and generative modeling. In <em>Proceedings
of the 26th International Conference on Artificial Intelligence and
Statistics</em>, pp. 5357-5375.
</p>


<h3>See Also</h3>

<p><code>adversarial_rf</code>, <code>forde</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">arf &lt;- adversarial_rf(iris)
psi &lt;- forde(arf, iris)
x_synth &lt;- forge(psi, n_synth = 100)

# Condition on Species = "setosa"
evi &lt;- data.frame(Species = "setosa")
x_synth &lt;- forge(psi, n_synth = 100, evidence = evi)

# Condition in Species = "setosa" and Sepal.Length &gt; 6
evi &lt;- data.frame(variable = c("Species", "Sepal.Length"),
                  relation = c("==", "&gt;"), 
                  value = c("setosa", 6))
x_synth &lt;- forge(psi, n_synth = 100, evidence = evi)

# Or just input some distribution on leaves
# (Weights that do not sum to unity are automatically scaled)
n_leaves &lt;- nrow(psi$forest)
evi &lt;- data.frame(f_idx = psi$forest$f_idx, wt = rexp(n_leaves))
x_synth &lt;- forge(psi, n_synth = 100, evidence = evi)


</code></pre>


</div>